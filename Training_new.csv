id,question,solution_a,total_runtime_a,avg_memory_a,solution_b,total_runtime_b,avg_memory_b,solution_c,total_runtime_c,avg_memory_c,order
1,"
def digit_parity_match(numbers: list[int]) -> list[int]:
""""""
Filter a list of positive integers, returning only the numbers where the parity
(even or odd status) of the number itself matches the parity of the sum of its digits.

For example, 24 is even and 2+4=6 is even, so it passes.
12 is even but 1+2=3 is odd, so it fails.

Examples:
digit_parity_match([12, 24, 55, 23]) == [24, 23]
digit_parity_match([10, 20, 30]) == []
digit_parity_match([11, 22, 33]) == [22]
digit_parity_match([]) == []
""""""
","def digit_parity_match(numbers: list[int]) -> list[int]:
    return [n for n in numbers if n % 2 == sum(int(d) for d in str(n)) % 2]",0.0007409,26.97421875,"def digit_parity_match(numbers: list[int]) -> list[int]:
    result = []
    for n in numbers:
        total = 0
        temp = n
        while temp > 0:
            total += temp % 10
            temp //= 10
        if total % 2 == n % 2:
            result.append(n)
    return result",0.0005312,26.97421875,"def digit_parity_match(numbers: list[int]) -> list[int]:
    parity = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]

    def digit_parity_of(n: int) -> int:
        if n == 0:
            return 0
        acc = 0
        while n:
            acc ^= parity[n % 10]
            n //= 10
        return acc

    result = []
    for n in numbers:
        if digit_parity_of(n) == (n & 1):
            result.append(n)
    return result",0.0006331,26.97421875,"['b', 'c', 'a']"
2,"
def reverse_target_words(sentence: str, target: str) -> str:
""""""
Given a string `sentence` and a single character `target`, return a new string
where every word containing the `target` character is reversed.
All other words remain the same. Words are separated by spaces.

>>> reverse_target_words(""hello world"", ""l"")
""olleh dlrow""
>>> reverse_target_words("" is cool"", ""o"")
"" is looc""
>>> reverse_target_words(""simple example"", ""z"")
""simple example""
>>> reverse_target_words(""catch the cat"", ""c"")
""hctac the tac""
""""""
","def reverse_target_words(sentence: str, target: str) -> str:
    return ' '.join(word[::-1] if target in word else word for word in sentence.split(' '))",0.0004011,26.13242188,"def reverse_target_words(sentence: str, target: str) -> str:
    res = []
    word = """"
    for char in sentence:
        if char == "" "":
            if target in word:
                res.append(word[::-1])
            else:
                res.append(word)
            res.append("" "")
            word = """"
        else:
            word += char
    if target in word:
        res.append(word[::-1])
    else:
        res.append(word)
    return """".join(res)",0.0005044,26.13242188,"def reverse_target_words(sentence: str, target: str) -> str:
    res = []
    i = 0
    n = len(sentence)
    while i < n:
        if sentence[i] == ' ':
            res.append(' ')
            i += 1
        else:
            j = i
            while j < n and sentence[j] != ' ':
                j += 1
            word = sentence[i:j]
            if target in word:
                res.append(word[::-1])
            else:
                res.append(word)
            i = j
    return ''.join(res)
",0.0007658,26.13242188,"['a', 'b', 'c']"
3,"
def select_unique_vowel_words(text: str) -> list:
""""""
Given a string of space-separated words, return a list of words that satisfy two conditions:
1. The word contains at least one vowel (a, e, i, o, u), case-insensitive.
2. The word consists of unique characters only (case-insensitive).

Return the list sorted by word length in descending order. If two words have the same length,
sort them alphabetically in ascending order.

Examples:
select_unique_vowel_words(""Apple banana Cat dog"") == ['Cat', 'dog']
select_unique_vowel_words("" is great"") == [' ', 'great', 'is']
select_unique_vowel_words(""level radar civic"") == []
select_unique_vowel_words(""Hi World"") == ['World', 'Hi']
""""""
","def select_unique_vowel_words(text: str) -> list:
    vowels = set('aeiouAEIOU')
    result = []
    for word in text.split():
        lower_word = word.lower()
        if any(c in vowels for c in word) and len(set(lower_word)) == len(lower_word):
            result.append(word)
    return sorted(result, key=lambda w: (-len(w), w))",0.000649,26.04921875,"def select_unique_vowel_words(text: str) -> list:
    vowels = ""aeiou""
    results = []
    for word in text.split():
        low = word.lower()
        # Word must contain at least one vowel and have no repeating characters
        if any(v in low for v in vowels) and all(low.count(c) == 1 for c in low):
            results.append(word)
    # Sort alphabetically first, then by length descending for a stable multi-key sort
    results.sort()
    results.sort(key=len, reverse=True)
    return results",0.0005479,26.04921875,"def select_unique_vowel_words(text: str) -> list:
    vowels = set('aeiou')
    words = text.split()
    result = []
    for w in words:
        lw = w.lower()
        if not vowels.isdisjoint(lw) and len(set(lw)) == len(lw):
            result.append(w)
    return sorted(result, key=lambda x: (-len(x), x))",0.0008891,26.04921875,"['b', 'a', 'c']"
4,"
from typing import List

def running_max_difference(numbers: List[int]) -> List[int]:
""""""
Generate a list where the i-th element is the difference between the maximum
value seen in the input list up to index i (inclusive) and the element at index i.

The result at index i is calculated as: max(numbers[0]...numbers[i]) - numbers[i].

Examples:
running_max_difference([1, 2, 3, 4, 5]) == [0, 0, 0, 0, 0]
running_max_difference([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4]
running_max_difference([3, 1, 4, 1, 5, 9, 2]) == [0, 2, 0, 3, 0, 0, 7]
running_max_difference([]) == []
""""""
","from typing import List

def running_max_difference(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    result = []
    current_max = numbers[0]
    for n in numbers:
        current_max = max(current_max, n)
        result.append(current_max - n)
    return result",0.0006194,26.690625,"from typing import List
import itertools

def running_max_difference(numbers: List[int]) -> List[int]:
    max_values = itertools.accumulate(numbers, max)
    return [m - x for m, x in zip(max_values, numbers)]",0.0005274,26.690625,"from typing import List

def running_max_difference(numbers: List[int]) -> List[int]:
    return [max(numbers[:i+1]) - x for i, x in enumerate(numbers)]
",0.0004889,26.690625,"['c', 'b', 'a']"
5,"
def max_parity_sum(nums: list) -> int:
""""""
Given a list of integers, find the maximum sum of a contiguous subarray
where all elements share the same parity (i.e., they are all odd or all even).

If the list is empty, return 0.
The subarray must contain at least one element.

max_parity_sum([1, 2, 3, 5]) == 8 # Subarrays: [1], [2], [3, 5]. Sums: 1, 2, 8.
max_parity_sum([2, 4, 6, 1, 3]) == 12 # Subarrays: [2, 4, 6], [1, 3]. Sums: 12, 4.
max_parity_sum([10, 20, 3, 40]) == 40 # Subarrays: [10, 20], [3], [40]. Sums: 30, 3, 40.
max_parity_sum([-2, -4, 5]) == 5 # Subarrays: [-2, -4], [5]. Sums: -6, 5.
""""""
pass
","def max_parity_sum(nums: list) -> int:
    if not nums:
        return 0
    max_sum = float('-inf')
    i = 0
    while i < len(nums):
        parity = nums[i] % 2
        current_sum = 0
        while i < len(nums) and nums[i] % 2 == parity:
            current_sum += nums[i]
            i += 1
        max_sum = max(max_sum, current_sum)
    return max_sum",0,0,"def max_parity_sum(nums: list) -> int:
    if not nums:
        return 0
    splits = [0] + [i for i in range(1, len(nums)) if nums[i] % 2 != nums[i-1] % 2] + [len(nums)]
    return max(sum(nums[i:j]) for i, j in zip(splits, splits[1:]))",0,0,"def max_parity_sum(nums: list) -> int:
    if not nums:
        return 0
    current = nums[0]
    best = nums[0]
    prev_par = nums[0] & 1
    for x in nums[1:]:
        if (x & 1) == prev_par:
            s = current + x
            current = x if s < x else s
        else:
            current = x
        if current > best:
            best = current
        prev_par = x & 1
    return best
",0.0004473,26.44863281,"['c', 'a', 'b']"
6,"
def filter_divisible_by_digit_sum(numbers: list) -> list:
""""""
Given a list of positive integers, return a new list containing only the numbers
that are divisible by the sum of their own digits.

- The order of numbers in the output should match their original order.
- Assume all input numbers are integers > 0.

Examples:
filter_divisible_by_digit_sum([12, 13, 18, 20]) == [12, 18, 20]
filter_divisible_by_digit_sum([10, 11, 22]) == [10]
filter_divisible_by_digit_sum([1, 7, 9]) == [1, 7, 9]
filter_divisible_by_digit_sum([100, 101, 102]) == [100, 102]
""""""
","def filter_divisible_by_digit_sum(numbers: list) -> list:
    result = []
    for n in numbers:
        digit_sum = sum(int(d) for d in str(n))
        if digit_sum > 0 and n % digit_sum == 0:
            result.append(n)
    return result",0.0005653,26.90429688,"def filter_divisible_by_digit_sum(numbers: list) -> list:
    output = []
    for n in numbers:
        s, t = 0, n
        while t > 0:
            s += t % 10
            t //= 10
        if n % s == 0:
            output.append(n)
    return output",0.0005301,26.90429688,"def filter_divisible_by_digit_sum(numbers: list) -> list:
    from functools import lru_cache

    @lru_cache(maxsize=None)
    def digit_sum(n: int) -> int:
        if n < 10:
            return n
        return (n % 10) + digit_sum(n // 10)

    result = []
    for n in numbers:
        s = digit_sum(n)
        if s and n % s == 0:
            result.append(n)
    return result",0.0010713,26.90429688,"['b', 'a', 'c']"
7,"
def interleave_and_flip(a: list, b: list) -> list:
""""""
Create a new list by interleaving elements from list 'a' and list 'b',
starting with the first element of 'a'.

Once the shorter list is exhausted, take the remaining elements of the
longer list, reverse their order, and append them to the result.

Examples:
interleave_and_flip([1, 2, 3], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c']
interleave_and_flip([1, 2, 3, 4, 5], ['x', 'y']) == [1, 'x', 2, 'y', 5, 4, 3]
interleave_and_flip([], [1, 2, 3]) == [3, 2, 1]
interleave_and_flip([5], []) == [5]
""""""
","def interleave_and_flip(a: list, b: list) -> list:
    result = []
    min_len = min(len(a), len(b))
    for i in range(min_len):
        result.append(a[i])
        result.append(b[i])
    if len(a) > min_len:
        result.extend(a[min_len:][::-1])
    elif len(b) > min_len:
        result.extend(b[min_len:][::-1])
    return result",0.0011234,27.05390625,"def interleave_and_flip(a: list, b: list) -> list:
    combined = []
    i = 0
    while i < len(a) and i < len(b):
        combined.append(a[i])
        combined.append(b[i])
        i += 1
    tail = a[i:] + b[i:]
    while tail:
        combined.append(tail.pop())
    return combined",0.0006033,27.05390625,"def interleave_and_flip(a: list, b: list) -> list:
    min_len = min(len(a), len(b))
    result = [x for pair in zip(a[:min_len], b[:min_len]) for x in pair]
    if len(a) > min_len:
        result.extend(a[min_len:][::-1])
    elif len(b) > min_len:
        result.extend(b[min_len:][::-1])
    return result",0.0006256,27.05390625,"['b', 'c', 'a']"
8,"
def filter_by_digit_sum(numbers: list[int], target: int) -> list[int]:
""""""
Filter the input list to include only positive integers whose digits sum up to the specified target.
Return the result in the original order.

>>> filter_by_digit_sum([12, 30, 25, 111], 3)
[12, 30, 111]
>>> filter_by_digit_sum([5, 14, 23], 5)
[5, 14, 23]
>>> filter_by_digit_sum([99, 100], 1)
[100]
>>> filter_by_digit_sum([], 10)
[]
""""""
","def filter_by_digit_sum(numbers: list[int], target: int) -> list[int]:
    return [n for n in numbers if sum(int(d) for d in str(n)) == target]",0,0,"def filter_by_digit_sum(numbers: list[int], target: int) -> list[int]:
    result = []
    for n in numbers:
        if n > 0:
            total = 0
            temp = n
            while temp > 0:
                total += temp % 10
                temp //= 10
            if total == target:
                result.append(n)
    return result",0.0005994,31.92070313,"def filter_by_digit_sum(numbers: list[int], target: int) -> list[int]:
    def sum_digits(n: int) -> int:
        if n < 10:
            return n
        return (n % 10) + sum_digits(n // 10)
    result = []
    for n in numbers:
        if n > 0 and sum_digits(n) == target:
            result.append(n)
    return result",0.0005252,26.70761719,"['c', 'b', 'a']"
9,"
def max_digit_spread(numbers):
""""""
Given a list of non-negative integers, return the number that has the largest difference
between its maximum and minimum digit.
If multiple numbers have the same maximal difference, return the one that appears first in the list.
Return None if the list is empty.

>>> max_digit_spread([14, 29, 0])
29
>>> max_digit_spread([11, 22, 33])
11
>>> max_digit_spread([105, 90, 81])
90
>>> max_digit_spread([])
None
""""""
","def max_digit_spread(numbers):
    if not numbers:
        return None
    best_num = numbers[0]
    best_spread = max(int(d) for d in str(numbers[0])) - min(int(d) for d in str(numbers[0]))
    for n in numbers[1:]:
        digits = [int(d) for d in str(n)]
        spread = max(digits) - min(digits)
        if spread > best_spread:
            best_spread = spread
            best_num = n
    return best_num",0.0005745,26.51777344,"def max_digit_spread(numbers):
    if not numbers:
        return None
    
    spreads = []
    for n in numbers:
        val = n
        hi = lo = val % 10
        val //= 10
        while val > 0:
            digit = val % 10
            if digit > hi:
                hi = digit
            if digit < lo:
                lo = digit
            val //= 10
        spreads.append(hi - lo)
    
    max_diff = max(spreads)
    return numbers[spreads.index(max_diff)]",0.0004749,26.51777344,"def max_digit_spread(numbers):
    if not numbers:
        return None

    def spread_of(n):
        s = str(n)
        digits = sorted(s)
        return int(digits[-1]) - int(digits[0])

    best_num = numbers[0]
    best_spread = spread_of(best_num)

    for n in numbers[1:]:
        cur = spread_of(n)
        if cur > best_spread:
            best_spread = cur
            best_num = n

    return best_num",0.0005745,26.51777344,"['b', 'a', 'c']"
10,"
def shift_even_strings(words):
""""""
Given a list of strings, filter out strings with odd lengths. For the remaining
strings (even length), move the first character to the end (cyclic left shift).
Return the resulting list sorted in alphabetical order.

Examples:
shift_even_strings([""apple"", ""banana"", ""pear"", ""kiwi""]) == [""ananab"", ""earp"", ""iwik""]
shift_even_strings([""cat"", ""dog""]) == []
shift_even_strings([""go"", ""to"", ""bed""]) == [""og"", ""ot""]
""""""
","def shift_even_strings(words):
    result = []
    for word in words:
        if len(word) % 2 == 0:
            result.append(word[1:] + word[0])
    return sorted(result)",0.0008348,26.47851563,"def shift_even_strings(words):
    i = 0
    res = []
    while i < len(words):
        s = words[i]
        if len(s) % 2 == 0:
            res.append(s[1:] + s[:1])
        i += 1
    res.sort()
    return res",0.0013012,26.47851563,"def shift_even_strings(words):
    from collections import deque
    res = []
    for w in words:
        if len(w) % 2 == 0:
            d = deque(w)
            d.rotate(-1)
            res.append(''.join(d))
    return sorted(res)",0.0006565,26.47851563,"['c', 'a', 'b']"
11,"
def sum_segment_products(numbers: list) -> int:
""""""
Given a list of integers, the list is logically split into segments by the number 0.
For each contiguous segment of non-zero numbers, calculate the product of its elements.
Return the sum of these products.

Empty segments (caused by consecutive zeros or boundary zeros) should be ignored.
If the list is empty or contains only zeros, return 0.

Examples:
sum_segment_products([1, 2, 0, 3, 4]) == 14 # (1*2) + (3*4) = 2 + 12 = 14
sum_segment_products([0, 5, 1, 0, 2]) == 7 # (5*1) + 2 = 5 + 2 = 7
sum_segment_products([2, 3]) == 6 # 2*3 = 6
sum_segment_products([0, 0, 0]) == 0
""""""
","def sum_segment_products(numbers: list) -> int:
    if not numbers:
        return 0
    total = 0
    product = 1
    in_segment = False
    for n in numbers:
        if n != 0:
            product *= n
            in_segment = True
        else:
            if in_segment:
                total += product
                product = 1
                in_segment = False
    if in_segment:
        total += product
    return total",0.0004645,26.65800781,"def sum_segment_products(numbers: list) -> int:
    total = 0
    i = 0
    while i < len(numbers):
        if numbers[i] != 0:
            product = 1
            while i < len(numbers) and numbers[i] != 0:
                product *= numbers[i]
                i += 1
            total += product
        else:
            i += 1
    return total",0.0005162,26.65800781,"def sum_segment_products(numbers: list) -> int:
    from itertools import groupby
    total = 0
    for is_zero, grp in groupby(numbers, key=lambda x: x == 0):
        if not is_zero:
            prod = 1
            for v in grp:
                prod *= v
            total += prod
    return total",0.0004813,26.65800781,"['a', 'c', 'b']"
12,"
def conditional_step_sum(numbers, k):
""""""
Given a list of integers and a step size 'k', calculate the sum of elements that satisfy
two conditions:
1. The element is located at an index that is a multiple of 'k' (0-indexed).
2. The element itself is an even number.
Assume 'k' is a positive integer.

Examples:
conditional_step_sum([10, 15, 20, 25, 30], 2) == 60 # Indices 0, 2, 4 are checked. Elements 10, 20, 30 are all even.
conditional_step_sum([10, 15, 21, 25, 30], 2) == 40 # Indices 0, 2, 4 checked. 10 and 30 are even; 21 is odd.
conditional_step_sum([1, 2, 3, 4], 1) == 6 # All indices checked. Evens are 2 and 4.
conditional_step_sum([], 3) == 0
""""""
","def conditional_step_sum(numbers, k):
    return sum(numbers[i] for i in range(0, len(numbers), k) if numbers[i] % 2 == 0)",0.0005967,26.92363281,"def conditional_step_sum(numbers, k):
    total = 0
    idx = 0
    while idx < len(numbers):
        if numbers[idx] % 2 == 0:
            total += numbers[idx]
        idx += k
    return total",0.0005791,26.92363281,"def conditional_step_sum(numbers, k):
    from functools import reduce

    def step(acc, idx_val):
        i, v = idx_val
        if i % k == 0 and v % 2 == 0:
            return acc + v
        return acc

    return reduce(step, enumerate(numbers), 0)",0.0009527,26.92363281,"['b', 'a', 'c']"
13,"
def count_valid_rotations(strings: list[str], target: str) -> int:
""""""
You are given a list of strings and a target string.
Return the number of strings in the list that are valid rotations of the target.
A rotation involves moving any number of characters from the front of the string
to the back without changing the relative order of the remaining characters.

Examples:
count_valid_rotations([""bcda"", ""abdc"", ""dabc"", ""abcd""], ""abcd"") == 3
# Matches: ""bcda"", ""dabc"", ""abcd""

count_valid_rotations([""noon"", ""onno"", ""onon""], ""noon"") == 2
# Matches: ""noon"", ""onno"" (""onon"" is not a rotation)

count_valid_rotations([""a"", ""b"", ""c""], ""a"") == 1
count_valid_rotations([], ""test"") == 0
""""""
pass
","def count_valid_rotations(strings: list[str], target: str) -> int:
    if not target:
        return 0
    doubled = target + target
    return sum(1 for s in strings if len(s) == len(target) and s in doubled)",0.0005809,26.72363281,"def count_valid_rotations(strings: list[str], target: str) -> int:
    if not target:
        return strings.count("""")
    
    rotations = set()
    for i in range(len(target)):
        rotations.add(target[i:] + target[:i])
        
    count = 0
    for s in strings:
        if s in rotations:
            count += 1
    return count",0.0014551,26.72363281,"def count_valid_rotations(strings: list[str], target: str) -> int:
    n = len(target)
    if n == 0:
        return sum(1 for s in strings if s == """")
    count = 0
    for s in strings:
        if len(s) != n:
            continue
        for shift in range(n):
            if s == target[shift:] + target[:shift]:
                count += 1
                break
    return count",0.0011614,26.72363281,"['a', 'c', 'b']"
14,"
def cyclic_shift_by_index(words: list) -> list:
""""""
Given a list of strings, return a new list where each string at index `i`
is rotated to the left by `i` characters.

The rotation is cyclic, meaning characters shifted off the left end reappear
at the right end. If a string is shorter than its index `i`, use the modulo
of the length to determine the shift. Empty strings remain unchanged.

Examples:
cyclic_shift_by_index([""hello"", ""world""])
# Returns [""hello"", ""orldw""] (Index 0 shift 0, Index 1 shift 1)

cyclic_shift_by_index([""a"", ""bc"", ""def"", ""ghij""])
# Returns [""a"", ""cb"", ""fde"", ""jghi""]
# Logic: ""a"" (shift 0), ""bc"" (shift 1), ""def"" (shift 2), ""ghij"" (shift 3)

cyclic_shift_by_index([""algorithm"", ""data""])
# Returns [""algorithm"", ""atad""]
""""""
pass
","def cyclic_shift_by_index(words: list) -> list:
    result = []
    for i, word in enumerate(words):
        if not word:
            result.append(word)
        else:
            shift = i % len(word)
            result.append(word[shift:] + word[:shift])
    return result",0.0012089,26.59726563,"def cyclic_shift_by_index(words: list) -> list:
    rotated_list = []
    for i in range(len(words)):
        s = words[i]
        if not s:
            rotated_list.append(s)
        else:
            n = len(s)
            chars = [s[(i + j) % n] for j in range(n)]
            rotated_list.append("""".join(chars))
    return rotated_list",0.0008587,26.59726563,"def cyclic_shift_by_index(words: list) -> list:
    from collections import deque
    result = []
    for i, s in enumerate(words):
        if not s:
            result.append(s)
        else:
            d = deque(s)
            d.rotate(-i)
            result.append(''.join(d))
    return result",0.0008301,26.59726563,"['c', 'b', 'a']"
15,"
from typing import List

def best_consonant_word(words: List[str]) -> str:
""""""
Return the word from the list that contains the most unique consonants (case-insensitive).
If there is a tie in the count of unique consonants, choose the shortest word.
If there is still a tie, return the word that appears first in the list.
Return an empty string if the list is empty or no consonants are present.

best_consonant_word([""apple"", ""banana""]) == ""apple""
best_consonant_word([""cat"", ""dog""]) == ""cat""
best_consonant_word([""race"", ""car""]) == ""car""
best_consonant_word([""a"", ""e"", ""i""]) == """"
best_consonant_word([]) == """"
""""""
pass
","from typing import List

def best_consonant_word(words: List[str]) -> str:
    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')
    best = """"
    best_count = 0
    for word in words:
        unique_consonants = len(set(c.lower() for c in word if c in consonants))
        if unique_consonants > best_count or (unique_consonants == best_count and (not best or len(word) < len(best))):
            best_count = unique_consonants
            best = word
    return best if best_count > 0 else """"",0.0008911,26.53574219,"from typing import List

def best_consonant_word(words: List[str]) -> str:
    consonants = set(""bcdfghjklmnpqrstvwxyz"")
    
    def get_score(word):
        return len(set(word.lower()) & consonants)

    candidates = [w for w in words if get_score(w) > 0]
    if not candidates:
        return """"

    return max(candidates, key=lambda w: (get_score(w), -len(w)))",0.0006658,26.53574219,"def best_consonant_word(words: list[str]) -> str:
    if not words:
        return """"
    consonants = ""bcdfghjklmnpqrstvwxyz""
    index_map = {ch: i for i, ch in enumerate(consonants)}
    best_word = """"
    best_count = 0
    best_len = 0
    best_index = -1
    for i, w in enumerate(words):
        mask = 0
        for ch in w:
            idx = index_map.get(ch.lower())
            if idx is not None:
                mask |= 1 << idx
        count = mask.bit_count() if hasattr(mask, ""bit_count"") else bin(mask).count(""1"")
        if count > best_count:
            best_count = count
            best_word = w
            best_len = len(w)
            best_index = i
        elif count == best_count and count > 0:
            lw = len(w)
            if lw < best_len:
                best_word = w
                best_len = lw
                best_index = i
            elif lw == best_len and i < best_index:
                best_word = w
                best_index = i
    return best_word if best_count > 0 else """"",0.0005223,26.53574219,"['c', 'b', 'a']"
16,"
def cyclic_group_shift(s: str, n: int) -> str:
""""""
Split the string s into groups of length n. For every group that has exactly n characters,
rotate its characters 1 position to the right (the last character becomes the first).
If the last group has fewer than n characters, leave it unchanged. Return the new string.

>>> cyclic_group_shift(""abcdef"", 2)
'badcfe'
>>> cyclic_group_shift(""abcdef"", 3)
'cabfde'
>>> cyclic_group_shift(""12345"", 2)
'21435'
>>> cyclic_group_shift(""coding"", 10)
'coding'
""""""
pass
","def cyclic_group_shift(s: str, n: int) -> str:
    result = []
    for i in range(0, len(s), n):
        group = s[i:i+n]
        if len(group) == n:
            result.append(group[-1] + group[:-1])
        else:
            result.append(group)
    return ''.join(result)",0.0003763,26.06621094,"def cyclic_group_shift(s: str, n: int) -> str:
    if n < 2:
        return s
    num_full_chars = (len(s) // n) * n
    return """".join(s[(i // n) * n + (i - 1) % n] if i < num_full_chars else s[i] for i in range(len(s)))",0.0003773,26.06621094,"def cyclic_group_shift(s: str, n: int) -> str:
    """"""
    Rotate each full group of length n by one to the right; last incomplete group unchanged.
    """"""
    if n <= 1 or not s:
        return s
    L = len(s)
    full = L // n
    last_start = full * n
    res = []
    for i in range(L):
        if i < last_start:
            if i % n == 0:
                res.append(s[i + n - 1])
            else:
                res.append(s[i - 1])
        else:
            res.append(s[i])
    return ''.join(res)
",0.0003627,26.06621094,"['c', 'a', 'b']"
17,"
def digit_product_transform(numbers: list) -> list:
""""""
Given a list of integers, return a new list where each element is the product
of the non-zero digits of the corresponding number in the input.

Rules:
1. If the input number is 0, the result should be 0.
2. Negative numbers should be treated as positive (ignore the sign).
3. Zeros within the number (e.g., 105) should be ignored in the product calculation.

Examples:
digit_product_transform([123, -405, 0, 101])
# Returns [6, 20, 0, 1]
# Explanation: 1*2*3=6; 4*5=20; 0 is 0; 1*1=1

digit_product_transform([5, -22, 100])
# Returns [5, 4, 1]
# Explanation: 5=5; 2*2=4; 1=1
""""""
result = []
for num in numbers:
if num == 0:
result.append(0)
continue

# Convert to string and ignore sign
s_num = str(abs(num))
product = 1
has_non_zero = False

for char in s_num:
digit = int(char)
if digit != 0:
product *= digit
has_non_zero = True

# If the number was something like 0 (already handled) or effectively 0 logic
# though input 0 is handled, this handles cases if any obscure logic slipped
if not has_non_zero:
result.append(0)
else:
result.append(product)

return result
","def digit_product_transform(numbers: list) -> list:
    result = []
    for num in numbers:
        if num == 0:
            result.append(0)
            continue
        s_num = str(abs(num))
        product = 1
        has_non_zero = False
        for char in s_num:
            digit = int(char)
            if digit != 0:
                product *= digit
                has_non_zero = True
        if not has_non_zero:
            result.append(0)
        else:
            result.append(product)
    return result",0.0004794,26.52617188,"import math

def digit_product_transform(numbers: list) -> list:
    return [math.prod(int(d) for d in str(abs(n)) if d != '0') if n != 0 else 0 for n in numbers]",0.0004883,26.52617188,"def digit_product_transform(numbers: list) -> list:
    result = []
    for num in numbers:
        if num == 0:
            result.append(0)
            continue
        n = abs(num)
        product = 1
        while n:
            d = n % 10
            if d != 0:
                product *= d
            n //= 10
        result.append(product)
    return result",0.0006871,26.52617188,"['a', 'b', 'c']"
18,"
def filter_by_consonant_count(strings: list[str], n: int) -> list[str]:
""""""
Given a list of strings and an integer n, return a new list containing only the strings
that have exactly n consonants.
Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case-insensitive). All other alphabetic characters
are considered consonants. The output should preserve the original order of the strings.

>>> filter_by_consonant_count(['apple', 'banana', 'cat'], 3)
['apple', 'banana']
>>> filter_by_consonant_count(['hello', 'world'], 4)
['world']
>>> filter_by_consonant_count(['a', 'e', 'i'], 0)
['a', 'e', 'i']
>>> filter_by_consonant_count(['sky', 'py'], 3)
['sky']
""""""
","def filter_by_consonant_count(strings: list[str], n: int) -> list[str]:
    vowels = set('aeiouAEIOU')
    return [s for s in strings if sum(1 for c in s if c.isalpha() and c not in vowels) == n]",0.0008452,26.79042969,"def filter_by_consonant_count(strings: list[str], n: int) -> list[str]:
    result = []
    for s in strings:
        consonants_only = """".join(char for char in s if char.isalpha())
        for vowel in ""aeiouAEIOU"":
            consonants_only = consonants_only.replace(vowel, """")
        if len(consonants_only) == n:
            result.append(s)
    return result",0.0008351,26.79042969,"def filter_by_consonant_count(strings: list[str], n: int) -> list[str]:
    import re
    pattern = re.compile(r'[b-df-hj-np-tv-z]', re.IGNORECASE)
    return [s for s in strings if len(pattern.findall(s)) == n]
",0.0007253,26.79042969,"['c', 'b', 'a']"
19,"
def sum_mixed_parity_differences(numbers: list[int]) -> int:
""""""
Given a list of integers, calculate the sum of absolute differences between adjacent
elements, but ONLY include the difference if the two adjacent elements have
different parity (one is even and the other is odd).

If the list has fewer than 2 elements, return 0.

>>> sum_mixed_parity_differences([1, 2, 3, 4])
3
>>> sum_mixed_parity_differences([2, 4, 6, 8])
0
>>> sum_mixed_parity_differences([10, 5, 3, 8])
10
""""""
pass
","def sum_mixed_parity_differences(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    for i in range(len(numbers) - 1):
        if numbers[i] % 2 != numbers[i+1] % 2:
            total += abs(numbers[i] - numbers[i+1])
    return total",0.000445,26.42910156,"def sum_mixed_parity_differences(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    it = iter(numbers)
    last = next(it)
    res = 0
    for x in it:
        if (last + x) % 2:
            res += abs(last - x)
        last = x
    return res",0.0004132,26.42910156,"def sum_mixed_parity_differences(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    return sum(abs(a - b) for a, b in zip(numbers, numbers[1:]) if (a ^ b) & 1)
",0.0004704,26.42910156,"['b', 'a', 'c']"
20,"
def binary_dominance_filter(numbers: list[int]) -> list[int]:
""""""
Given a list of non-negative integers, return a new list containing only
the numbers whose binary representation (without leading zeros)
contains strictly more ones than zeros.

Examples:
binary_dominance_filter([5, 7, 4]) == [5, 7] # 5 is '101' (2>1), 7 is '111' (3>0), 4 is '100' (1<2)
binary_dominance_filter([1, 2, 8]) == [1] # 1 is '1', 2 is '10', 8 is '1000'
binary_dominance_filter([0, 3, 15]) == [3, 15]
""""""
pass
","def binary_dominance_filter(numbers: list[int]) -> list[int]:
    result = []
    for n in numbers:
        if n == 0:
            continue
        binary = bin(n)[2:]
        ones = binary.count('1')
        zeros = binary.count('0')
        if ones > zeros:
            result.append(n)
    return result",0.0004393,26.48359375,"def binary_dominance_filter(numbers: list[int]) -> list[int]:
    res = []
    for n in numbers:
        if n > 0:
            diff = 0
            temp = n
            while temp:
                if temp & 1:
                    diff += 1
                else:
                    diff -= 1
                temp >>= 1
            if diff > 0:
                res.append(n)
    return res",0.0004177,26.48359375,"def binary_dominance_filter(numbers: list[int]) -> list[int]:
    result = []
    for n in numbers:
        ones = n.bit_count()
        length = n.bit_length()
        if 2 * ones > length:
            result.append(n)
    return result",0.0004251,26.48359375,"['b', 'c', 'a']"
21,"
def sum_divisible_indices(nums):
""""""
Calculates the sum of all integers in the list that are evenly divisible by their
1-based index.

The index is 1-based, meaning the first element corresponds to index 1, the
second element to index 2, and so on.

Examples:
sum_divisible_indices([5, 6, 7]) -> 11 # 5%1==0 (Add), 6%2==0 (Add), 7%3!=0 (Skip) -> 5+6=11
sum_divisible_indices([1, 2, 3, 4]) -> 10
sum_divisible_indices([10, 5, 2]) -> 10 # 10%1==0 (Add), 5%2!=0 (Skip), 2%3!=0 (Skip)
sum_divisible_indices([]) -> 0
""""""
","def sum_divisible_indices(nums):
    return sum(nums[i] for i in range(len(nums)) if nums[i] % (i + 1) == 0)",0.00042,26.45488281,"def sum_divisible_indices(nums):
    result = 0
    pos = 1
    while pos <= len(nums):
        if nums[pos - 1] % pos == 0:
            result += nums[pos - 1]
        pos += 1
    return result",0.0004121,26.45488281,"def sum_divisible_indices(nums):
    nums = list(nums)
    def rec(arr, start):
        if not arr:
            return 0
        if len(arr) == 1:
            return arr[0] if arr[0] % start == 0 else 0
        mid = len(arr) // 2
        return rec(arr[:mid], start) + rec(arr[mid:], start + mid)
    return rec(nums, 1)",0.0004415,26.45488281,"['b', 'a', 'c']"
22,"
from typing import List

def chain_merge(strings: List[str]) -> str:
""""""
Concatenate a list of strings into a single result string.
When appending a non-empty string, if its first character matches the last character
of the current result, discard the first character of the new string before appending.

The first non-empty string is added as-is. Empty strings in the list are ignored.

>>> chain_merge([""hello"", ""orb"", ""bit""])
'hellorbit'
>>> chain_merge([""alpha"", ""a"", ""alpha""])
'alphalpha'
>>> chain_merge([""start"", ""top"", ""pop""])
'startopop'
>>> chain_merge([])
''
""""""
","from typing import List

def chain_merge(strings: List[str]) -> str:
    result = """"
    for s in strings:
        if not s:
            continue
        if result and s[0] == result[-1]:
            result += s[1:]
        else:
            result += s
    return result",0.0004418,26.575,"from typing import List

def chain_merge(strings: List[str]) -> str:
    words = [s for s in strings if s]
    if not words:
        return """"
    result = words[0]
    for item in words[1:]:
        result += item[1:] if item.startswith(result[-1]) else item
    return result",0.000455,26.575,"def chain_merge(strings: ""List[str]"") -> str:
    parts = []
    for s in strings:
        if not s:
            continue
        if not parts:
            parts.append(s)
        else:
            last = parts[-1][-1]
            if s[0] == last:
                tail = s[1:]
                if tail:
                    parts.append(tail)
            else:
                parts.append(s)
    return """".join(parts)
",0.000442,26.575,"['a', 'c', 'b']"
23,"
def count_special_pairs(numbers):
""""""
Given a list of integers, count the number of distinct pairs (numbers[i], numbers[j])
where i < j, such that the sum of the pair is odd and the product of the pair is divisible by 3.

>>> count_special_pairs([1, 2, 3, 4])
2
>>> count_special_pairs([3, 3, 3])
0
>>> count_special_pairs([1, 2, 3])
1
>>> count_special_pairs([3, 2, 1, 6])
3
""""""
","def count_special_pairs(numbers):
    count = 0
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            if (numbers[i] + numbers[j]) % 2 == 1 and (numbers[i] * numbers[j]) % 3 == 0:
                count += 1
    return count",0.0006981,26.44003906,"def count_special_pairs(numbers):
    evens = 0
    odds = 0
    evens_3 = 0
    odds_3 = 0
    count = 0
    for x in numbers:
        if x % 2 == 0:
            if x % 3 == 0:
                count += odds
                evens_3 += 1
            else:
                count += odds_3
            evens += 1
        else:
            if x % 3 == 0:
                count += evens
                odds_3 += 1
            else:
                count += evens_3
            odds += 1
    return count",0.0006625,26.44003906,"def count_special_pairs(numbers):
    E3 = E0 = O3 = O0 = 0
    for x in numbers:
        if x % 2 == 0:
            if x % 3 == 0:
                E3 += 1
            else:
                E0 += 1
        else:
            if x % 3 == 0:
                O3 += 1
            else:
                O0 += 1
    total_opposite = (E3 + E0) * (O3 + O0)
    neither_three = E0 * O0
    return total_opposite - neither_three",0.0005958,26.44003906,"['c', 'b', 'a']"
24,"
def group_shift(arr: list[int], k: int) -> list[int]:
""""""
Split the list `arr` into groups of size `k`. For every group that has exactly `k` elements,
cyclically shift its elements to the right by 1. Groups with fewer than `k` elements
(typically the last group) remain unchanged. Return the reconstructed list.

>>> group_shift([1, 2, 3, 4, 5], 2)
[2, 1, 4, 3, 5]
>>> group_shift([1, 2, 3, 4, 5], 3)
[3, 1, 2, 4, 5]
>>> group_shift([10, 20, 30], 5)
[10, 20, 30]
>>> group_shift([], 2)
[]
""""""
","def group_shift(arr: list[int], k: int) -> list[int]:
    result = []
    for i in range(0, len(arr), k):
        group = arr[i:i+k]
        if len(group) == k:
            result.append(group[-1])
            result.extend(group[:-1])
        else:
            result.extend(group)
    return result",0.000832,26.88828125,"def group_shift(arr: list[int], k: int) -> list[int]:
    result = []
    for i, x in enumerate(arr):
        start = (i // k) * k
        if start + k <= len(arr):
            result.append(arr[start + (i - 1) % k])
        else:
            result.append(x)
    return result",0.0005758,26.88828125,"def group_shift(arr: list[int], k: int) -> list[int]:
    n = len(arr)
    if k <= 0 or n == 0:
        return arr[:]
    res = [None] * n
    for i in range(n):
        g = i // k
        start = g * k
        if start + k <= n:
            dest = start + ((i - start + 1) % k)
        else:
            dest = i
        res[dest] = arr[i]
    return res",0.0004915,26.88828125,"['c', 'b', 'a']"
25,"
def keep_frequent(numbers: list, k: int) -> list:
""""""
Given a list of integers and an integer k, return a new list containing
only the elements that appear strictly more than k times in the original list.

The relative order of the remaining elements must be preserved.

Examples:
keep_frequent([1, 2, 3, 1, 2, 4], 1) -> [1, 2, 1, 2]
keep_frequent([5, 5, 5, 2, 2], 2) -> [5, 5, 5]
keep_frequent([10, 20, 30], 0) -> [10, 20, 30]
keep_frequent([1, 1, 1], 3) -> []
""""""
pass
","def keep_frequent(numbers: list, k: int) -> list:
    from collections import Counter
    counts = Counter(numbers)
    return [n for n in numbers if counts[n] > k]",0.000507,26.64863281,"def keep_frequent(numbers: list, k: int) -> list:
    frequent = {val for val in set(numbers) if numbers.count(val) > k}
    return [val for val in numbers if val in frequent]",0.0004354,26.64863281,"def keep_frequent(numbers: list, k: int) -> list:
    counts = {}
    for v in numbers:
        counts[v] = counts.get(v, 0) + 1
    result = []
    for v in numbers:
        if counts[v] > k:
            result.append(v)
    return result",0.0005069,26.64863281,"['b', 'c', 'a']"
26,"
def mixed_direction_sort(lst):
""""""
Given a list of integers, return a new list where all even numbers from the original
list are sorted in ascending order and all odd numbers are sorted in descending order.
Crucially, the sorted numbers must be placed such that the parity (even or odd) of the
number at each index in the result matches the parity of the number at that same index
in the original input.

mixed_direction_sort([1, 2, 3, 4]) == [3, 2, 1, 4]
mixed_direction_sort([10, 20, 5, 2]) == [2, 10, 5, 20]
mixed_direction_sort([3, 1, 5]) == [5, 3, 1]
mixed_direction_sort([]) == []
""""""
","def mixed_direction_sort(lst):
    evens = sorted([x for x in lst if x % 2 == 0])
    odds = sorted([x for x in lst if x % 2 == 1], reverse=True)
    result = []
    even_idx, odd_idx = 0, 0
    for x in lst:
        if x % 2 == 0:
            result.append(evens[even_idx])
            even_idx += 1
        else:
            result.append(odds[odd_idx])
            odd_idx += 1
    return result",0.0004856,26.85488281,"def mixed_direction_sort(lst):
    evens = sorted(x for x in lst if x % 2 == 0)
    odds = sorted((x for x in lst if x % 2 != 0), reverse=True)
    e_pos = [i for i, x in enumerate(lst) if x % 2 == 0]
    o_pos = [i for i, x in enumerate(lst) if x % 2 != 0]
    res = [0] * len(lst)
    for i, v in zip(e_pos + o_pos, evens + odds):
        res[i] = v
    return res",0.0006072,26.85488281,"def mixed_direction_sort(lst):
    import heapq
    evens = [x for x in lst if x % 2 == 0]
    odds = [x for x in lst if x % 2 != 0]
    ev_heap = evens[:]
    od_heap = [-x for x in odds]
    heapq.heapify(ev_heap)
    heapq.heapify(od_heap)
    res = []
    for x in lst:
        if x % 2 == 0:
            res.append(heapq.heappop(ev_heap))
        else:
            res.append(-heapq.heappop(od_heap))
    return res",0.0005283,26.85488281,"['a', 'c', 'b']"
27,"
def sum_even_odd_pairs(nums):
""""""
Given a list of integers, calculate the sum of products `nums[i] * nums[j]` for all
pairs of indices (i, j) such that i < j, nums[i] is even, and nums[j] is odd.

Return 0 if the input list is empty or contains no such pairs.

Examples:
sum_even_odd_pairs([2, 3]) == 6
sum_even_odd_pairs([2, 4, 3]) == 18
sum_even_odd_pairs([2, 3, 4, 5]) == 36
sum_even_odd_pairs([1, 5, 7]) == 0
""""""
","def sum_even_odd_pairs(nums):
    total = 0
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            for j in range(i + 1, len(nums)):
                if nums[j] % 2 == 1:
                    total += nums[i] * nums[j]
    return total",0.0004222,26.42539063,"def sum_even_odd_pairs(nums):
    res = 0
    odd_sum = 0
    for n in reversed(nums):
        if n % 2 != 0:
            odd_sum += n
        else:
            res += n * odd_sum
    return res",0.000411,26.42539063,"def sum_even_odd_pairs(nums):
    total = 0
    sum_evens = 0
    for x in nums:
        if x % 2 == 0:
            sum_evens += x
        else:
            total += x * sum_evens
    return total",0.0004094,26.42539063,"['c', 'b', 'a']"
28,"
def cyclic_three_shift(text: str) -> str:
""""""
Split the input string into groups of three characters. Within each group,
cycle the characters to the right by one position (e.g., 'abc' becomes 'cab').
If the last group has fewer than 3 characters, leave it unchanged.
Return the resulting string.

>>> cyclic_three_shift("" "")
'tPynho'
>>> cyclic_three_shift(""abcdefg"")
'cabfdeg'
>>> cyclic_three_shift(""12345"")
'31245'
>>> cyclic_three_shift("""")
''
""""""
","def cyclic_three_shift(text: str) -> str:
    result = []
    for i in range(0, len(text), 3):
        group = text[i:i+3]
        if len(group) == 3:
            result.append(group[-1] + group[:-1])
        else:
            result.append(group)
    return ''.join(result)",0.0003632,25.99257813,"def cyclic_three_shift(text: str) -> str:
    res = list(text)
    i = 0
    while i + 2 < len(res):
        res[i], res[i+1], res[i+2] = res[i+2], res[i], res[i+1]
        i += 3
    return """".join(res)",0.0003784,25.99257813,"def cyclic_three_shift(text: str) -> str:
    import re
    return re.sub(r'(.)(.)(.)', r'\\3\\1\\2', text)
",0,0,"['a', 'b', 'c']"
29,"
def align_max_start(nums):
""""""
Given a list of integers nums, cyclically rotate the list to the left
until the maximum value of the list is at the first position (index 0).
If there are multiple occurrences of the maximum value, rotate based on
the first occurrence found in the original list.
Return the rotated list. Returns an empty list if the input is empty.

align_max_start([1, 2, 5, 3, 4]) -> [5, 3, 4, 1, 2]
align_max_start([1, 4, 2, 4, 3]) -> [4, 2, 4, 3, 1]
align_max_start([7, 1, 2]) -> [7, 1, 2]
align_max_start([]) -> []
""""""
","def align_max_start(nums):
    if not nums:
        return []
    max_idx = nums.index(max(nums))
    return nums[max_idx:] + nums[:max_idx]",0.0004513,26.34023438,"def align_max_start(nums):
    if not nums:
        return []
    
    result = list(nums)
    highest = max(nums)
    while result[0] != highest:
        first = result.pop(0)
        result.append(first)
        
    return result",0.0005264,26.34023438,"def align_max_start(nums):
    from collections import deque
    if not nums:
        return []
    max_val = max(nums)
    k = 0
    for i, v in enumerate(nums):
        if v == max_val:
            k = i
            break
    dq = deque(nums)
    dq.rotate(-k)
    return list(dq)
",0.0005982,26.34023438,"['a', 'b', 'c']"
30,"
def parity_cross_transform(lst1: list, lst2: list) -> list:
""""""
Given two lists of integers, return a new list by processing elements at the same index
up to the length of the shorter list.
For each pair (a, b):
- If both numbers are even or both are odd, add them (a + b).
- If one is even and the other is odd, multiply them (a * b).

Examples:
parity_cross_transform([1, 2, 3], [4, 5, 6]) == [4, 10, 18]
parity_cross_transform([2, 4, 6], [2, 3, 4]) == [4, 12, 10]
parity_cross_transform([], [1, 2]) == []
""""""
pass
","def parity_cross_transform(lst1: list, lst2: list) -> list:
    result = []
    for a, b in zip(lst1, lst2):
        if a % 2 == b % 2:
            result.append(a + b)
        else:
            result.append(a * b)
    return result",0.0006149,27.44101563,"def parity_cross_transform(lst1: list, lst2: list) -> list:
    return list(map(lambda x, y: x + y if (x + y) % 2 == 0 else x * y, lst1, lst2))",0.0006158,27.44101563,"def parity_cross_transform(lst1: list, lst2: list) -> list:
    return [a + b if ((a ^ b) & 1) == 0 else a * b for a, b in zip(lst1, lst2)]",0.0005762,27.44101563,"['c', 'a', 'b']"
31,"
def prune_below_average(numbers: list) -> list:
""""""
Given a list of numbers, generate a new list by iterating through the input sequence.
The first element of the input is always included. For subsequent elements, include
the number only if it is greater than or equal to the average of the elements
already accepted into the new list.

Args:
numbers: A list of floats or integers.

Returns:
A list of numbers that satisfy the dynamic average condition.
Returns an empty list if the input is empty.

Examples:
prune_below_average([10, 20, 5, 30])
# Returns [10, 20, 30]
# Logic:
# 10 is kept (avg: 10).
# 20 >= 10 (kept, new avg: 15).
# 5 < 15 (dropped).
# 30 >= 15 (kept).

prune_below_average([5, 4, 3, 2])
# Returns [5]

prune_below_average([1, 2, 3, 4])
# Returns [1, 2, 3, 4]
""""""
","def prune_below_average(numbers: list) -> list:
    if not numbers:
        return []
    result = [numbers[0]]
    for num in numbers[1:]:
        avg = sum(result) / len(result)
        if num >= avg:
            result.append(num)
    return result",0.0006123,26.51386719,"def prune_below_average(numbers: list) -> list:
    if not numbers:
        return []
    items = iter(numbers)
    result = [next(items)]
    total = result[0]
    for x in items:
        if x * len(result) >= total:
            result.append(x)
            total += x
    return result",0.0004495,26.48574219,"def prune_below_average(numbers: list) -> list:
    if not numbers:
        return []
    result = [numbers[0]]
    mean = numbers[0]
    count = 1
    for x in numbers[1:]:
        if x >= mean:
            result.append(x)
            count += 1
            mean = mean + (x - mean) / count
    return result",0.0004237,26.48574219,"['c', 'b', 'a']"
32,"
from typing import List

def longest_above(numbers: List[int], threshold: int) -> int:
""""""
Given a list of integers and a threshold, return the length of the
longest contiguous subsequence where all elements are strictly greater
than the threshold. Return 0 if no such subsequence exists.

Examples:
longest_above([1, 5, 6, 2, 8, 9, 10], 4) -> 3
longest_above([1, 2, 3], 5) -> 0
longest_above([10, 20, 30], 5) -> 3
longest_above([], 1) -> 0
""""""
pass
","from typing import List

def longest_above(numbers: List[int], threshold: int) -> int:
    max_len = 0
    current_len = 0
    for n in numbers:
        if n > threshold:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 0
    return max_len",0.0005225,26.97617188,"from typing import List

def longest_above(numbers: List[int], threshold: int) -> int:
    idx = [-1] + [i for i, x in enumerate(numbers) if x <= threshold] + [len(numbers)]
    return max(idx[i+1] - idx[i] - 1 for i in range(len(idx) - 1))",0.0004955,26.97617188,"def longest_above(numbers: 'List[int]', threshold: int) -> int:
    from itertools import groupby
    result = 0
    for above, grp in groupby(numbers, key=lambda x: x > threshold):
        if above:
            count = sum(1 for _ in grp)
            if count > result:
                result = count
    return result",0.00049,26.97617188,"['c', 'b', 'a']"
33,"
def compress_parity(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, compress the list by summing consecutive elements
that share the same parity (both even or both odd).

Groups of adjacent numbers with the same parity are replaced by their sum in the resulting list.

Examples:
compress_parity([1, 3, 2, 4, 6, 5]) == [4, 12, 5]
compress_parity([2, 4, 6, 8]) == [20]
compress_parity([1, 2, 3, 4]) == [1, 2, 3, 4]
compress_parity([10]) == [10]
compress_parity([]) == []
""""""
","def compress_parity(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0004554,26.84921875,"def compress_parity(numbers: list[int]) -> list[int]:
    compressed = []
    k = 0
    while k < len(numbers):
        target_parity = numbers[k] % 2
        group_sum = 0
        while k < len(numbers) and numbers[k] % 2 == target_parity:
            group_sum += numbers[k]
            k += 1
        compressed.append(group_sum)
    return compressed",0.0004501,26.84921875,"def compress_parity(numbers: list[int]) -> list[int]:
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers, key=lambda x: x & 1)]",0.0004752,26.84921875,"['b', 'a', 'c']"
34,"
def digit_position_distance(n1: int, n2: int) -> int:
""""""
Given two non-negative integers n1 and n2, calculate the sum of absolute differences
between their digits at corresponding positions. Align the numbers from the
least significant digit (right side). If one number is shorter, treat the
missing leading digits as 0.

digit_position_distance(123, 456) == 9 # |3-6| + |2-5| + |1-4| = 9
digit_position_distance(105, 5) == 1 # |5-5| + |0-0| + |1-0| = 1
digit_position_distance(1, 10) == 2 # |1-0| + |0-1| = 2
digit_position_distance(9, 19) == 1 # |9-9| + |0-1| = 1
""""""
pass
","def digit_position_distance(n1: int, n2: int) -> int:
    s1, s2 = str(n1), str(n2)
    max_len = max(len(s1), len(s2))
    s1 = s1.zfill(max_len)
    s2 = s2.zfill(max_len)
    return sum(abs(int(a) - int(b)) for a, b in zip(s1, s2))",0.00042,26.04765625,"def digit_position_distance(n1: int, n2: int) -> int:
    s1 = list(str(n1))
    s2 = list(str(n2))
    total = 0
    while s1 or s2:
        v1 = int(s1.pop()) if s1 else 0
        v2 = int(s2.pop()) if s2 else 0
        total += abs(v1 - v2)
    return total",0.0004016,26.04765625,"def digit_position_distance(n1: int, n2: int) -> int:
    a, b = n1, n2
    total = 0
    while a > 0 or b > 0:
        total += abs(a % 10 - b % 10)
        a //= 10
        b //= 10
    return total",0.0003463,26.04765625,"['c', 'b', 'a']"
35,"
def sort_by_distinct_char_count(text: str) -> str:
""""""
Given a string of words separated by spaces, reorder the words based on the number
of distinct characters they contain in ascending order.
If two words have the same number of distinct characters, preserve their original relative order.

Args:
text: A string containing words separated by single spaces.

Returns:
A new string with the reordered words joined by single spaces.

Examples:
>>> sort_by_distinct_char_count(""apple banana cat"")
""banana cat apple""
>>> sort_by_distinct_char_count(""hello world"")
""hello world""
>>> sort_by_distinct_char_count(""aaa b bb ccc"")
""aaa b bb ccc""
>>> sort_by_distinct_char_count(""zebra bee"")
""bee zebra""
""""""
","def sort_by_distinct_char_count(text: str) -> str:
    words = text.split()
    sorted_words = sorted(words, key=lambda w: len(set(w)))
    return ' '.join(sorted_words)",0.0004063,26.02636719,"def sort_by_distinct_char_count(text: str) -> str:
    words = text.split()
    buckets = {}
    for word in words:
        chars = []
        for c in word:
            if c not in chars:
                chars.append(c)
        count = len(chars)
        if count not in buckets:
            buckets[count] = []
        buckets[count].append(word)
    result = []
    for n in sorted(buckets):
        result.extend(buckets[n])
    return "" "".join(result)",0.0012306,26.02636719,"def sort_by_distinct_char_count(text: str) -> str:
    words = text.split()
    if not words:
        return """"
    counts = [len(set(w)) for w in words]
    n = len(words)
    used = [False] * n
    result = []
    remaining = n
    while remaining > 0:
        min_count = None
        for i in range(n):
            if not used[i]:
                c = counts[i]
                if min_count is None or c < min_count:
                    min_count = c
        for i in range(n):
            if not used[i] and counts[i] == min_count:
                result.append(words[i])
                used[i] = True
                remaining -= 1
    return "" "".join(result)",0.0005443,26.02636719,"['a', 'c', 'b']"
36,"
def special_ordering(numbers: list) -> list:
""""""
Given a list of integers, return a new list where all numbers divisible by 3
appear first, sorted in ascending order, followed by all other numbers,
sorted in descending order.

Examples:
special_ordering([1, 2, 3, 4, 5, 6, 9]) == [3, 6, 9, 5, 4, 2, 1]
special_ordering([10, 20, 5]) == [20, 10, 5]
special_ordering([9, 3, 6]) == [3, 6, 9]
special_ordering([]) == []
""""""
","def special_ordering(numbers: list) -> list:
    div3 = sorted([n for n in numbers if n % 3 == 0])
    not_div3 = sorted([n for n in numbers if n % 3 != 0], reverse=True)
    return div3 + not_div3",0.0006803,26.88535156,"def special_ordering(numbers: list) -> list:
    return sorted(numbers, key=lambda x: (x % 3 != 0, x if x % 3 == 0 else -x))",0.000533,26.88535156,"def special_ordering(numbers: list) -> list:
    import heapq
    h = []
    for n in numbers:
        if n % 3 == 0:
            heapq.heappush(h, (0, n))
        else:
            heapq.heappush(h, (1, -n))
    res = []
    while h:
        grp, val = heapq.heappop(h)
        if grp == 0:
            res.append(val)
        else:
            res.append(-val)
    return res",0.0004624,26.88535156,"['c', 'b', 'a']"
37,"
def calculate_running_diff(numbers):
""""""
Given a list of integers, return a new list where each element at index i is
calculated as the value of the input element at i minus the sum of all
preceding elements (from index 0 to i-1).
For the first element, the preceding sum is considered 0.

Examples:
calculate_running_diff([10, 20, 30]) -> [10, 10, 0]
calculate_running_diff([1, 2, 3, 4]) -> [1, 1, 0, -2]
calculate_running_diff([5]) -> [5]
calculate_running_diff([]) -> []
""""""
","def calculate_running_diff(numbers):
    if not numbers:
        return []
    result = []
    prefix_sum = 0
    for n in numbers:
        result.append(n - prefix_sum)
        prefix_sum += n
    return result",0.0004014,26.33984375,"def calculate_running_diff(numbers):
    return [numbers[i] - sum(numbers[:i]) for i in range(len(numbers))]",0.0004119,26.33984375,"def calculate_running_diff(numbers):
    if not numbers:
        return []
    from itertools import accumulate
    prev_sums = list(accumulate(numbers))
    return [numbers[i] - (prev_sums[i-1] if i else 0) for i in range(len(numbers))",0,0,"['a', 'b', 'c']"
38,"
def reorder_case_logic(text: str) -> str:
""""""
Given a string `text`, return a new string where all lowercase letters are sorted in
ascending order and all uppercase letters are sorted in descending order.
The sorted letters must occupy the original indices where lowercase and uppercase
letters appeared respectively. Non-alphabetic characters remain in their original positions.

Constraints:
- The input string length is between 0 and 1000.
- The string can contain alphanumeric characters and symbols.

Examples:
>>> reorder_case_logic(""cBaA"")
'aBcA'
>>> reorder_case_logic(""World123"")
'Wdlor123'
>>> reorder_case_logic("" "")
'Phnoty'
>>> reorder_case_logic(""a-B-c"")
'a-B-c'
""""""
","def reorder_case_logic(text: str) -> str:
    lower = sorted([c for c in text if c.islower()])
    upper = sorted([c for c in text if c.isupper()], reverse=True)
    result = []
    li, ui = 0, 0
    for c in text:
        if c.islower():
            result.append(lower[li])
            li += 1
        elif c.isupper():
            result.append(upper[ui])
            ui += 1
        else:
            result.append(c)
    return ''.join(result)",0.000381,25.99960938,"def reorder_case_logic(text: str) -> str:
    low = sorted([c for c in text if c.islower()], reverse=True)
    up = sorted([c for c in text if c.isupper()])
    output = list(text)
    for i, char in enumerate(text):
        if char.islower():
            output[i] = low.pop()
        elif char.isupper():
            output[i] = up.pop()
    return """".join(output)",0.0003735,25.99960938,"def reorder_case_logic(text: str) -> str:
    lowers = sorted([c for c in text if c.islower()])
    uppers = sorted([c for c in text if c.isupper()], reverse=True)
    li = iter(lowers)
    ui = iter(uppers)
    res = []
    for ch in text:
        if ch.islower():
            res.append(next(li))
        elif ch.isupper():
            res.append(next(ui))
        else:
            res.append(ch)
    return ''.join(res)
",0.0004705,25.99960938,"['b', 'a', 'c']"
39,"
from typing import List

def concat_overlap(words: List[str]) -> str:
""""""
Concatenate a list of non-empty strings into a single string with a specific overlapping rule.
Start with the first word. For each subsequent word, if its first character matches the
last character of the currently assembled string, discard that first character from the
new word before concatenating it. Otherwise, simply concatenate the word.

If the list is empty, return an empty string.

Examples:
concat_overlap([""cat"", ""track"", ""kcart""]) == ""catrackcart""
concat_overlap([""blue"", ""eye"", ""ear""]) == ""blueyear""
concat_overlap([""a"", ""a"", ""b"", ""b""]) == ""ab""
concat_overlap([]) == """"
""""""
","from typing import List

def concat_overlap(words: List[str]) -> str:
    if not words:
        return """"
    result = words[0]
    for word in words[1:]:
        if result and word and result[-1] == word[0]:
            result += word[1:]
        else:
            result += word
    return result",0,0,"from typing import List

def concat_overlap(words: List[str]) -> str:
    if not words:
        return """"
    
    parts = [words[0]]
    for first, second in zip(words, words[1:]):
        if first[-1] == second[0]:
            parts.append(second[1:])
        else:
            parts.append(second)
            
    return """".join(parts)",0,0,"def concat_overlap(words: List[str]) -> str:
    if not words:
        return """"
    def dfs(i: int, current: str) -> str:
        if i >= len(words):
            return current
        w = words[i]
        if current and w and current[-1] == w[0]:
            return dfs(i + 1, current + w[1:])
        else:
            return dfs(i + 1, current + w)
    return dfs(1, words[0])",0,0,"['a', 'b', 'c']"
40,"
def sum_between_parity_anchors(nums: list[int]) -> int:
""""""
Find the index of the first even number and the index of the last odd number
in the list. Return the sum of all elements found between these two indices
(inclusive of the boundaries).

If the list does not contain at least one even number and at least one
odd number, return 0. The order of the indices does not matter; calculate
the sum from the smaller index to the larger index.

Examples:
sum_between_parity_anchors([1, 2, 3, 4, 6]) == 5 # First even: 2 (idx 1), Last odd: 3 (idx 2). Sum: 2+3
sum_between_parity_anchors([10, 5, 2]) == 15 # First even: 10 (idx 0), Last odd: 5 (idx 1). Sum: 10+5
sum_between_parity_anchors([5, 8, 4, 1, 2]) == 13 # First even: 8 (idx 1), Last odd: 1 (idx 3). Sum: 8+4+1
sum_between_parity_anchors([2, 4, 6]) == 0 # Missing odd number
sum_between_parity_anchors([]) == 0 # Empty list
""""""
","def sum_between_parity_anchors(nums: list[int]) -> int:
    first_even = -1
    last_odd = -1
    for i, n in enumerate(nums):
        if n % 2 == 0 and first_even == -1:
            first_even = i
        if n % 2 == 1:
            last_odd = i
    if first_even == -1 or last_odd == -1:
        return 0
    start, end = min(first_even, last_odd), max(first_even, last_odd)
    return sum(nums[start:end+1])",0.0005094,26.77597656,"def sum_between_parity_anchors(nums: list[int]) -> int:
    evens = [i for i, x in enumerate(nums) if x % 2 == 0]
    odds = [i for i, x in enumerate(nums) if x % 2 != 0]
    if not evens or not odds:
        return 0
    idx_even = evens[0]
    idx_odd = odds[-1]
    start, end = (idx_even, idx_odd) if idx_even < idx_odd else (idx_odd, idx_even)
    return sum(nums[start : end + 1])",0.0004972,26.77597656,"def sum_between_parity_anchors(nums: list[int]) -> int:
    first_even = next((i for i, x in enumerate(nums) if x % 2 == 0), None)
    last_odd = next((i for i in range(len(nums) - 1, -1, -1) if nums[i] % 2 != 0), None)
    if first_even is None or last_odd is None:
        return 0
    start, end = (first_even, last_odd) if first_even <= last_odd else (last_odd, first_even)
    total = 0
    for i in range(start, end + 1):
        total += nums[i]
    return total",0.0005198,26.77597656,"['b', 'a', 'c']"
41,"
from typing import List

def sum_symmetric_even_pairs(numbers: List[int]) -> int:
""""""
Given a list of integers, calculate the sum of the absolute differences between
elements at symmetric positions (first vs last, second vs second-to-last, etc.).
However, a pair contributes to the sum only if BOTH integers in the pair are even.

If the list has an odd length, the middle element is ignored.

>>> sum_symmetric_even_pairs([2, 5, 8, 10])
8
>>> sum_symmetric_even_pairs([4, 2, 6, 1, 12])
8
>>> sum_symmetric_even_pairs([1, 2, 3, 4])
0
>>> sum_symmetric_even_pairs([10, 20])
10
""""""
","from typing import List

def sum_symmetric_even_pairs(numbers: List[int]) -> int:
    total = 0
    n = len(numbers)
    for i in range(n // 2):
        left, right = numbers[i], numbers[n - 1 - i]
        if left % 2 == 0 and right % 2 == 0:
            total += abs(left - right)
    return total",0.0005026,26.44941406,"from typing import List

def sum_symmetric_even_pairs(numbers: List[int]) -> int:
    mid = len(numbers) // 2
    left_side = numbers[:mid]
    right_side = numbers[::-1][:mid]
    
    total_diff = 0
    for x, y in zip(left_side, right_side):
        if x % 2 == 0 and y % 2 == 0:
            total_diff += abs(x - y)
    return total_diff",0.0004291,26.44941406,"def sum_symmetric_even_pairs(numbers: List[int]) -> int:
    from collections import deque
    d = deque(numbers)
    total = 0
    while len(d) > 1:
        a = d.popleft()
        b = d.pop()
        if a % 2 == 0 and b % 2 == 0:
            total += abs(a - b)
    return total",0,0,"['b', 'a', 'c']"
42,"
from typing import List

def outlier_digit_sum(nums: List[int]) -> int:
""""""
Given a list of non-negative integers, first calculate the average of the list.
Then, identify all numbers in the list that are strictly greater than this average.
Return the total sum of the digits of these identified numbers.

If the list is empty, return 0.

Examples:
outlier_digit_sum([10, 20, 3]) # Returns 2 (Average is 11. Only 20 > 11. Digits of 20 sum to 2)
outlier_digit_sum([1, 2, 3]) # Returns 3 (Average is 2. Only 3 > 2. Digits of 3 sum to 3)
outlier_digit_sum([5, 5, 5]) # Returns 0 (Average is 5. No number is strictly greater than 5)
outlier_digit_sum([100, 1]) # Returns 1 (Average is 50.5. Only 100 > 50.5. Digits of 100 sum to 1)
""""""
pass
","from typing import List

def outlier_digit_sum(nums: List[int]) -> int:
    if not nums:
        return 0
    avg = sum(nums) / len(nums)
    total = 0
    for n in nums:
        if n > avg:
            total += sum(int(d) for d in str(n))
    return total",0.0005232,26.43554688,"from typing import List

def outlier_digit_sum(nums: List[int]) -> int:
    if not nums:
        return 0
    
    avg = sum(nums) / len(nums)
    outliers = [n for n in nums if n > avg]
    
    combined_digits = """".join(map(str, outliers))
    
    return sum(map(int, combined_digits))",0.000432,26.43554688,"def outlier_digit_sum(nums: List[int]) -> int:
    if not nums:
        return 0
    avg = sum(nums) / len(nums)
    def digit_sum(x: int) -> int:
        s = 0
        while x:
            s += x % 10
            x //= 10
        return s
    total = 0
    for v in nums:
        if v > avg:
            total += digit_sum(v)
    return total",0,0,"['b', 'a', 'c']"
43,"
def rolling_parity_score(numbers: list[int]) -> int:
""""""
Compute a rolling score by iterating through a list of integers with the following rules:
Start with a score of 0.
For each number in the list:
- If the number is even, add it to the current score.
- If the number is odd, subtract it from the current score.
- If the score becomes negative after any operation, reset it to 0 immediately.

Return the final score after processing all numbers.

Examples:
rolling_parity_score([1, 2, 3]) == 0
rolling_parity_score([2, 4, 1]) == 5
rolling_parity_score([10, 3, 5, 4]) == 6
rolling_parity_score([]) == 0
""""""
","def rolling_parity_score(numbers: list[int]) -> int:
    score = 0
    for n in numbers:
        if n % 2 == 0:
            score += n
        else:
            score -= n
        if score < 0:
            score = 0
    return score",0.0004545,26.46953125,"def rolling_parity_score(numbers: list[int]) -> int:
    score = 0
    for num in numbers:
        delta = num if num % 2 == 0 else -num
        score = max(0, score + delta)
    return score
 ",0,0,"def rolling_parity_score(numbers: list[int]) -> int:
    from itertools import accumulate
    if not numbers:
        return 0
    def step(score, n):
        delta = n if n % 2 == 0 else -n
        s = score + delta
        return s if s >= 0 else 0
    last = 0
    for last in accumulate(numbers, step):
        pass
    return last",0.0006672,26.46953125,"['a', 'c', 'b']"
44,"
def parity_compress(lst):
""""""
Given a list of integers, return a new list where adjacent integers
having the same parity (both even or both odd) are summed together.

Examples:
parity_compress([1, 3, 2, 8, 5, 7]) == [4, 10, 12]
parity_compress([1, 2, 3]) == [1, 2, 3]
parity_compress([2, 4, 6, 8]) == [20]
parity_compress([]) == []
""""""
","def parity_compress(lst):
    if not lst:
        return []
    result = []
    current_sum = lst[0]
    current_parity = lst[0] % 2
    for n in lst[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0008454,26.57011719,"def parity_compress(lst):
    result = []
    i = 0
    while i < len(lst):
        start = i
        parity = lst[i] % 2
        while i < len(lst) and lst[i] % 2 == parity:
            i += 1
        result.append(sum(lst[start:i]))
    return result",0.0006346,26.57011719,"def parity_compress(lst):
    from itertools import groupby
    return [sum(group) for _, group in groupby(lst, key=lambda x: x % 2)]",0.0004949,26.57011719,"['c', 'b', 'a']"
45,"
def sum_isolated_evens(numbers: list) -> int:
""""""
Given a list of integers, return the sum of all even numbers that are not
immediately adjacent to another even number.

An even number is considered ""isolated"" and added to the sum if:
- The number itself is even.
- The element immediately preceding it (if valid) is odd.
- The element immediately following it (if valid) is odd.

Examples:
sum_isolated_evens([1, 2, 3]) == 2
sum_isolated_evens([2, 4, 6]) == 0
sum_isolated_evens([1, 2, 3, 4]) == 6
sum_isolated_evens([1, 2, 1, 4, 2, 3]) == 6 # 2 and 4 are isolated, second 2 is not
sum_isolated_evens([2, 1, 2, 1, 2]) == 6
""""""
","def sum_isolated_evens(numbers: list) -> int:
    total = 0
    for i, n in enumerate(numbers):
        if n % 2 == 0:
            left_ok = (i == 0 or numbers[i-1] % 2 == 1)
            right_ok = (i == len(numbers) - 1 or numbers[i+1] % 2 == 1)
            if left_ok and right_ok:
                total += n
    return total",0.000453,26.70546875,"def sum_isolated_evens(numbers: list) -> int:
    seq = [1] + numbers + [1]
    total = 0
    for a, b, c in zip(seq, seq[1:], seq[2:]):
        if b % 2 == 0 and a % 2 != 0 and c % 2 != 0:
            total += b
    return total",0.000463,26.70546875,"def sum_isolated_evens(numbers: list) -> int:
    total = 0
    i = 0
    n = len(numbers)
    while i < n:
        if numbers[i] % 2 == 0:
            j = i + 1
            while j < n and numbers[j] % 2 == 0:
                j += 1
            if j - i == 1:
                total += numbers[i]
            i = j
        else:
            i += 1
    return total",0.0004408,26.70546875,"['c', 'a', 'b']"
46,"
from typing import List

def select_even_odd(numbers: List[int]) -> List[int]:
""""""
Given a list of positive integers, return a new list containing only the numbers
that are even, but whose sum of digits is odd. The resulting list must be
sorted in ascending order.

Examples:
select_even_odd([12, 23, 34, 45, 56]) == [12, 34, 56]
select_even_odd([2, 4, 6, 8]) == []
select_even_odd([10, 20, 30, 100]) == [10, 30, 100]
select_even_odd([90, 81, 72, 63]) == [90]
""""""
","from typing import List

def select_even_odd(numbers: List[int]) -> List[int]:
    result = []
    for n in numbers:
        if n % 2 == 0:
            digit_sum = sum(int(d) for d in str(n))
            if digit_sum % 2 == 1:
                result.append(n)
    return sorted(result)",0.0005416,26.55371094,"from typing import List

def select_even_odd(numbers: List[int]) -> List[int]:
    result = []
    for n in sorted(numbers):
        if n % 2 == 0:
            digit_sum = 0
            val = n
            while val > 0:
                digit_sum += val % 10
                val //= 10
            if digit_sum % 2:
                result.append(n)
    return result",0.0004458,26.55371094,"def select_even_odd(numbers: List[int]) -> List[int]:
    def digit_sum(n: int) -> int:
        if n < 10:
            return n
        return (n % 10) + digit_sum(n // 10)
    res = [n for n in numbers if n % 2 == 0 and digit_sum(n) % 2 == 1]
    return sorted(res)
",0,0,"['b', 'a', 'c']"
47,"
def count_divisible_pairs(lst: list, k: int) -> int:
""""""
Returns the number of consecutive pairs of elements in the list `lst`
whose sum is divisible by the integer `k`.

Constraints:
- k is always a positive integer.
- The list may contain positive or negative integers.

Examples:
count_divisible_pairs([1, 2, 3, 4, 5], 3) == 2
count_divisible_pairs([10, 11, 12], 2) == 0
count_divisible_pairs([5, 5, 5], 5) == 2
count_divisible_pairs([], 10) == 0
""""""
","def count_divisible_pairs(lst: list, k: int) -> int:
    count = 0
    for i in range(len(lst) - 1):
        if (lst[i] + lst[i+1]) % k == 0:
            count += 1
    return count",0.0004602,26.86855469,"def count_divisible_pairs(lst: list, k: int) -> int:
    total = 0
    for a, b in zip(lst, lst[1:]):
        if (a + b) % k == 0:
            total += 1
    return total",0.0005689,26.86855469,"def count_divisible_pairs(lst: list, k: int) -> int:
    def rec(i: int) -> int:
        if i >= len(lst) - 1:
            return 0
        return (1 if (lst[i] + lst[i+1]) % k == 0 else 0) + rec(i + 1)
    return rec(0)
",0.0006039,26.86855469,"['a', 'b', 'c']"
48,"
def count_same_char_set(words: list[str]) -> int:
""""""
Given a list of strings, return the count of words that are composed of
the exact same set of unique characters as the first word in the list.

If the list is empty, return 0. The comparison is case-sensitive.

Examples:
count_same_char_set([""apple"", ""papel"", ""pale"", ""leap""]) == 4
count_same_char_set([""cat"", ""act"", ""tact"", ""bat""]) == 3
count_same_char_set([""hello"", ""world""]) == 1
count_same_char_set([""a"", ""aa"", ""aaa""]) == 3
count_same_char_set([]) == 0
""""""
","def count_same_char_set(words: list[str]) -> int:
    if not words:
        return 0
    first_set = set(words[0])
    return sum(1 for word in words if set(word) == first_set)",0.0006121,26.65664063,"def count_same_char_set(words: list[str]) -> int:
    if not words:
        return 0
    word_sets = [set(word) for word in words]
    return word_sets.count(word_sets[0])",0.0005574,26.65664063,"def count_same_char_set(words: list[str]) -> int:
    if not words:
        return 0
    target = set(words[0])
    count = 0
    for w in words:
        if all(ch in target for ch in w) and len(set(w)) == len(target):
            count += 1
    return count",0.000652,26.65664063,"['b', 'a', 'c']"
49,"
def parity_group_sums(nums: list) -> list:
""""""
Given a list of integers, calculate the sum of contiguous groups of numbers
that share the same parity (both even or both odd).

Return the resulting sums as a new list.

Examples:
parity_group_sums([1, 3, 2, 4, 4, 5]) == [4, 10, 5]
parity_group_sums([1, 2, 3, 4]) == [1, 2, 3, 4]
parity_group_sums([2, 4, 6, 8]) == [20]
parity_group_sums([]) == []
""""""
pass
","def parity_group_sums(nums: list) -> list:
    if not nums:
        return []
    result = []
    current_sum = nums[0]
    current_parity = nums[0] % 2
    for n in nums[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0005091,26.91347656,"def parity_group_sums(nums: list) -> list:
    sums = []
    i = 0
    while i < len(nums):
        total = 0
        parity = nums[i] % 2
        while i < len(nums) and nums[i] % 2 == parity:
            total += nums[i]
            i += 1
        sums.append(total)
    return sums",0.0004579,26.91347656,"def parity_group_sums(nums: list) -> list:
    from itertools import groupby
    return [sum(group) for _, group in groupby(nums, key=lambda x: x % 2)]",0.0004765,26.91347656,"['b', 'c', 'a']"
50,"
def sum_consecutive_by_parity(numbers: list) -> list:
""""""
Given a list of integers, group consecutive elements that share the same parity
(both even or both odd) and sum them up to form a new list.

Examples:
sum_consecutive_by_parity([1, 3, 5, 2, 4, 1]) == [9, 6, 1]
sum_consecutive_by_parity([10, 20, 30]) == [60]
sum_consecutive_by_parity([1, 2, 3]) == [1, 2, 3]
sum_consecutive_by_parity([]) == []
""""""
","def sum_consecutive_by_parity(numbers: list) -> list:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0004685,26.98515625,"def sum_consecutive_by_parity(numbers: list) -> list:
    result = []
    i = 0
    while i < len(numbers):
        start = i
        target_parity = numbers[start] % 2
        while i < len(numbers) and numbers[i] % 2 == target_parity:
            i += 1
        result.append(sum(numbers[start:i]))
        start = i
    return result",0.0004617,26.98515625,"def sum_consecutive_by_parity(numbers: list) -> list:
    """"""
    Given a list of integers, group consecutive elements that share the same parity
    (both even or both odd) and sum them up to form a new list.

    Examples:
    sum_consecutive_by_parity([1, 3, 5, 2, 4, 1]) == [9, 6, 1]
    sum_consecutive_by_parity([10, 20, 30]) == [60]
    sum_consecutive_by_parity([1, 2, 3]) == [1, 2, 3]
    sum_consecutive_by_parity([]) == []
    """"""
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers, key=lambda x: x % 2)]
",0.0004647,26.98515625,"['b', 'c', 'a']"
51,"
def reverse_alternate_groups(items: list, k: int) -> list:
""""""
Given a list of items and a positive integer k, split the list into groups of size k.
Reverse the elements of every group at an odd index (1st group is index 0), while
keeping groups at even indices in their original order.
Concatenate the groups back together to form the result.

If the list is empty, return an empty list. k is guaranteed to be >= 1.

Examples:
reverse_alternate_groups([1, 2, 3, 4, 5, 6], 2) == [1, 2, 4, 3, 5, 6]
reverse_alternate_groups([1, 2, 3, 4, 5, 6, 7], 3) == [1, 2, 3, 6, 5, 4, 7]
reverse_alternate_groups([10, 20, 30], 1) == [10, 20, 30]
reverse_alternate_groups([1, 2], 5) == [1, 2]
""""""
","def reverse_alternate_groups(items: list, k: int) -> list:
    result = []
    groups = [items[i:i+k] for i in range(0, len(items), k)]
    for idx, group in enumerate(groups):
        if idx % 2 == 1:
            result.extend(group[::-1])
        else:
            result.extend(group)
    return result",0.0005464,27.15859375,"def reverse_alternate_groups(items: list, k: int) -> list:
    result = list(items)
    for i in range(k, len(items), 2 * k):
        result[i:i + k] = result[i:i + k][::-1]
    return result",0.0005037,27.15859375,"def reverse_alternate_groups(items: list, k: int) -> list:
    n = len(items)
    res = [None] * n
    for base in range(0, n, k):
        end = min(base + k, n)
        g = base // k
        for off in range(end - base):
            i = base + off
            if g % 2 == 1:
                new_i = end - 1 - off
            else:
                new_i = i
            res[new_i] = items[i]
    return res",0.0005274,27.15859375,"['b', 'c', 'a']"
52,"
def running_max_min_difference(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, generate a new list where the element at index i represents
the difference between the maximum and minimum values found in the input list
from index 0 up to index i (inclusive).

examples:
running_max_min_difference([1, 10, 2, 9]) -> [0, 9, 9, 9]
running_max_min_difference([5, 1, 3, 0, 7]) -> [0, 4, 4, 5, 7]
running_max_min_difference([4]) -> [0]
running_max_min_difference([]) -> []
""""""
","def running_max_min_difference(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_max = numbers[0]
    current_min = numbers[0]
    for n in numbers:
        current_max = max(current_max, n)
        current_min = min(current_min, n)
        result.append(current_max - current_min)
    return result",0.00042,26.42753906,def running_max_min_difference(numbers: list[int]) -> list[int]: return [max(numbers[:i+1]) - min(numbers[:i+1]) for i in range(len(numbers))],0.0004437,26.42753906,"def running_max_min_difference(numbers: list[int]) -> list[int]:
    from itertools import accumulate
    cum_max = list(accumulate(numbers, max))
    cum_min = list(accumulate(numbers, min))
    return [mx - mn for mx, mn in zip(cum_max, cum_min)]",0.0004383,26.42753906,"['a', 'c', 'b']"
53,"
from typing import List

def group_and_sum_parity(numbers: List[int]) -> List[int]:
""""""
Given a list of integers, group consecutive elements that share the same parity
(both even or both odd) and sum the numbers in each group.
Return the resulting list of sums.

Examples:
group_and_sum_parity([1, 3, 2, 4, 6, 5]) == [4, 12, 5]
group_and_sum_parity([1, 1, 1, 1]) == [4]
group_and_sum_parity([2, 3, 4, 5]) == [2, 3, 4, 5]
group_and_sum_parity([]) == []
""""""
","from typing import List

def group_and_sum_parity(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0008186,27.06289063,"from typing import List

def group_and_sum_parity(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    
    indices = [0]
    for i in range(1, len(numbers)):
        if numbers[i] % 2 != numbers[i-1] % 2:
            indices.append(i)
    indices.append(len(numbers))
    
    return [sum(numbers[indices[j]:indices[j+1]]) for j in range(len(indices) - 1)]",0.0006089,27.06289063,"def group_and_sum_parity(numbers):
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers, key=lambda x: x % 2)]",0.0006291,27.06289063,"['b', 'c', 'a']"
54,"
def word_parity_score(words: list) -> int:
""""""
Given a list of strings composed of English letters, calculate a total score based on the length parity of each word:
- If a word has an even length, add the count of its vowels (a, e, i, o, u, case-insensitive) to the score.
- If a word has an odd length, add the count of its consonants (any letter that is not a vowel) to the score.

Return the total accumulated score.

Examples:
word_parity_score([""Hi"", ""World""]) == 5 # ""Hi"" (len 2->vowels: 1), ""World"" (len 5->consonants: 4) -> 1+4=5
word_parity_score(["" "", ""is"", ""cool""]) == 4 # "" "" (len 6->vowels: 1), ""is"" (len 2->vowels: 1), ""cool"" (len 4->vowels: 2) -> 1+1+2=4
word_parity_score([""Code"", ""Tests""]) == 6 # ""Code"" (len 4->vowels: 2), ""Tests"" (len 5->consonants: 4) -> 2+4=6
word_parity_score([]) == 0
""""""
","def word_parity_score(words: list) -> int:
    vowels = set('aeiouAEIOU')
    score = 0
    for word in words:
        if len(word) % 2 == 0:
            score += sum(1 for c in word if c in vowels)
        else:
            score += sum(1 for c in word if c.isalpha() and c not in vowels)
    return score",0.0004681,26.52597656,"def word_parity_score(words: list) -> int:
    total = 0
    for word in words:
        v_count = 0
        c_count = 0
        for char in word.lower():
            if char.isalpha():
                if char in 'aeiou':
                    v_count += 1
                else:
                    c_count += 1
        if len(word) % 2 == 0:
            total += v_count
        else:
            total += c_count
    return total",0.0004827,26.52597656,"def word_parity_score(words: list) -> int:
    vowels = set('aeiouAEIOU')
    total = 0
    for word in words:
        v = sum(1 for c in word if c in vowels)
        letters = sum(1 for c in word if c.isalpha())
        if len(word) % 2 == 0:
            total += v
        else:
            total += (letters - v)
    return total",0.0004908,26.52597656,"['a', 'b', 'c']"
55,"
def weave_sorted(numbers: list) -> list:
""""""
Given a list of integers, sort them in ascending order and return a new list
created by alternatingly taking the smallest and then the largest remaining elements.
The order should be: smallest, largest, second smallest, second largest, and so on.

Examples:
weave_sorted([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
weave_sorted([10, 20]) == [10, 20]
weave_sorted([5, 5, 1, 9]) == [1, 9, 5, 5]
weave_sorted([]) == []
""""""
pass
","def weave_sorted(numbers: list) -> list:
    if not numbers:
        return []
    sorted_nums = sorted(numbers)
    result = []
    left, right = 0, len(sorted_nums) - 1
    take_left = True
    while left <= right:
        if take_left:
            result.append(sorted_nums[left])
            left += 1
        else:
            result.append(sorted_nums[right])
            right -= 1
        take_left = not take_left
    return result",0.0004582,26.43535156,"def weave_sorted(numbers: list) -> list:
    n = len(numbers)
    nums = sorted(numbers)
    res = [None] * n
    mid = (n + 1) // 2
    res[::2] = nums[:mid]
    res[1::2] = nums[mid:][::-1]
    return res",0.0004292,26.43535156,"def weave_sorted(numbers: list) -> list:
    data = list(numbers)
    result = []
    take_small = True
    while data:
        if take_small:
            mn = min(data)
            result.append(mn)
            data.remove(mn)
        else:
            mx = max(data)
            result.append(mx)
            data.remove(mx)
        take_small = not take_small
    return result",0.0004286,26.43535156,"['c', 'b', 'a']"
56,"
def toggle_case_by_index(text: str) -> str:
""""""
Given a string `text` containing words separated by single spaces, return a new string
where the case of the characters is modified based on the word's position (0-indexed).

Apply the following rules:
1. For words at even indices (0, 2, ...): Convert all vowels to uppercase and all consonants to lowercase.
2. For words at odd indices (1, 3, ...): Convert all vowels to lowercase and all consonants to uppercase.
3. Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case-insensitive).
4. The result should join the processed words with single spaces.

Examples:
>>> toggle_case_by_index(""Hello World"")
'hEllO WoRLD'

>>> toggle_case_by_index("" is very fun"")
' Is vEry fUn'

>>> toggle_case_by_index(""a b c d"")
'A B c D'
""""""
","def toggle_case_by_index(text: str) -> str:
    vowels = set('aeiouAEIOU')
    words = text.split(' ')
    result = []
    for idx, word in enumerate(words):
        new_word = []
        for c in word:
            if c.isalpha():
                if idx % 2 == 0:
                    new_word.append(c.upper() if c in vowels else c.lower())
                else:
                    new_word.append(c.lower() if c in vowels else c.upper())
            else:
                new_word.append(c)
        result.append(''.join(new_word))
    return ' '.join(result)",0.0004253,26.00605469,"def toggle_case_by_index(text: str) -> str:
    words = text.split(' ')
    vowels = ""aeiou""
    for i in range(len(words)):
        chars = []
        is_even = (i % 2 == 0)
        for char in words[i]:
            if char.isalpha():
                is_v = char.lower() in vowels
                if is_v == is_even:
                    chars.append(char.upper())
                else:
                    chars.append(char.lower())
            else:
                chars.append(char)
        words[i] = """".join(chars)
    return "" "".join(words)",0.000428,26.00605469,"def toggle_case_by_index(text: str) -> str:
    vowels = {'a','e','i','o','u'}
    words = text.split(' ')
    result = []
    for i, w in enumerate(words):
        if i % 2 == 0:
            transformed = ''.join((ch.upper() if ch.lower() in vowels else (ch.lower() if ch.isalpha() else ch)) for ch in w)
        else:
            transformed = ''.join((ch.lower() if ch.lower() in vowels else (ch.upper() if ch.isalpha() else ch)) for ch in w)
        result.append(transformed)
    return ' '.join(result)",0.0004425,26.00605469,"['a', 'b', 'c']"
57,"
def sum_isolated_elements(numbers: list) -> int:
""""""
Given a list of integers, calculate the sum of all elements that are not equal
to any of their immediate neighbors.

For the first element, it must differ from the second.
For the last element, it must differ from the second to last.
For internal elements, they must differ from both the left and right neighbors.
A list with a single element is considered isolated.

Examples:
sum_isolated_elements([1, 2, 3, 4]) == 10
sum_isolated_elements([1, 1, 2, 3]) == 5
sum_isolated_elements([1, 2, 2, 3]) == 4
sum_isolated_elements([1, 2, 1, 2]) == 6
sum_isolated_elements([5]) == 5
""""""
pass
","def sum_isolated_elements(numbers: list) -> int:
    if not numbers:
        return 0
    if len(numbers) == 1:
        return numbers[0]
    total = 0
    for i, n in enumerate(numbers):
        if i == 0:
            if n != numbers[1]:
                total += n
        elif i == len(numbers) - 1:
            if n != numbers[-2]:
                total += n
        else:
            if n != numbers[i-1] and n != numbers[i+1]:
                total += n
    return total",0.000443,26.67753906,"def sum_isolated_elements(numbers: list) -> int:
    prev_vals = [None] + numbers[:-1]
    next_vals = numbers[1:] + [None]
    total = 0
    for p, c, n in zip(prev_vals, numbers, next_vals):
        if c != p and c != n:
            total += c
    return total",0.0004531,26.67753906,"def sum_isolated_elements(numbers: list) -> int:
       from itertools import groupby
    total = 0
    for _, grp in groupby(numbers):
        grp_list = list(grp)
        if len(grp_list) == 1:
            total += grp_list[0]
    return total",0,0,"['a', 'b', 'c']"
58,"
from typing import List

def max_positive_window(nums: List[int], k: int) -> int:
""""""
Find the maximum sum of a contiguous subarray of length k where all elements
in the subarray are strictly positive. If no such subarray exists or if k
is larger than the list length, return -1.

max_positive_window([1, 2, -1, 4, 5], 2) == 9
max_positive_window([1, 2, 3], 4) == -1
max_positive_window([-1, -2, -3], 1) == -1
max_positive_window([10, 20, 30], 2) == 50
""""""
pass
","from typing import List

def max_positive_window(nums: List[int], k: int) -> int:
    if k > len(nums) or k <= 0:
        return -1
    max_sum = -1
    for i in range(len(nums) - k + 1):
        window = nums[i:i+k]
        if all(x > 0 for x in window):
            max_sum = max(max_sum, sum(window))
    return max_sum",0.0006246,27.21621094,"from typing import List

def max_positive_window(nums: List[int], k: int) -> int:
    if k < 1 or k > len(nums):
        return -1
    
    max_sum = -1
    current_sum = 0
    current_len = 0
    
    for i, val in enumerate(nums):
        if val > 0:
            current_sum += val
            current_len += 1
        else:
            current_sum = 0
            current_len = 0
        
        if current_len > k:
            current_sum -= nums[i - k]
            current_len = k
            
        if current_len == k:
            if max_sum == -1 or current_sum > max_sum:
                max_sum = current_sum
    return max_sum",0.0004844,27.21621094,"def max_positive_window(nums, k):
    if k <= 0 or k > len(nums):
        return -1
    n = len(nums)
    pref = [0] * (n + 1)
    nonpos = [0] * (n + 1)
    for i in range(n):
        v = nums[i]
        pref[i + 1] = pref[i] + v
        nonpos[i + 1] = nonpos[i] + (1 if v <= 0 else 0)
    max_sum = -1
    for i in range(n - k + 1):
        if nonpos[i + k] - nonpos[i] == 0:
            s = pref[i + k] - pref[i]
            if s > max_sum:
                max_sum = s
    return max_sum",0.0005092,27.21621094,"['b', 'c', 'a']"
59,"
def interleave_and_tail_reverse(a: list, b: list) -> list:
""""""
Interleave elements from two lists 'a' and 'b' starting with 'a'.
If one list is longer than the other, reverse the remaining elements
of the longer list and append them to the end.

Examples:
interleave_and_tail_reverse([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3]
interleave_and_tail_reverse([1, 2], [3, 4, 5, 6]) == [1, 3, 2, 4, 6, 5]
interleave_and_tail_reverse([1, 2], [3, 4]) == [1, 3, 2, 4]
interleave_and_tail_reverse([], [1, 2, 3]) == [3, 2, 1]
""""""
","def interleave_and_tail_reverse(a: list, b: list) -> list:
    result = []
    min_len = min(len(a), len(b))
    for i in range(min_len):
        result.append(a[i])
        result.append(b[i])
    if len(a) > min_len:
        result.extend(a[min_len:][::-1])
    elif len(b) > min_len:
        result.extend(b[min_len:][::-1])
    return result",0.0005193,27.24960938,"def interleave_and_tail_reverse(a: list, b: list) -> list:
    result = []
    n, m = len(a), len(b)
    i = 0
    while i < n and i < m:
        result.append(a[i])
        result.append(b[i])
        i += 1
    remaining = a if i < n else b
    for j in range(len(remaining) - 1, i - 1, -1):
        result.append(remaining[j])
    return result",0.0005664,27.24960938,"def interleave_and_tail_reverse(a: list, b: list) -> list:
    inter = [x for pair in zip(a, b) for x in pair]
    if len(a) > len(b):
        inter.extend(a[len(b):][::-1])
    elif len(b) > len(a):
        inter.extend(b[len(a):][::-1])
    return inter",0.0005825,27.24960938,"['a', 'b', 'c']"
60,"
def shift_vowels_cyclically(s):
""""""
Given a string `s`, shift all vowels cyclically to the right by one position
relative to the sequence of vowels, while keeping non-vowel characters in
their original indices. Vowels are defined as 'a', 'e', 'i', 'o', 'u'
(case-insensitive).

Examples:
shift_vowels_cyclically(""apple"") == ""eppla""
shift_vowels_cyclically(""hello world"") == ""holle world""
shift_vowels_cyclically("" "") == "" ""
shift_vowels_cyclically(""AEIOU"") == ""UAEIO""
""""""
","def shift_vowels_cyclically(s):
    vowels = 'aeiouAEIOU'
    vowel_chars = [c for c in s if c in vowels]
    if len(vowel_chars) <= 1:
        return s
    shifted = [vowel_chars[-1]] + vowel_chars[:-1]
    result = []
    vi = 0
    for c in s:
        if c in vowels:
            result.append(shifted[vi])
            vi += 1
        else:
            result.append(c)
    return ''.join(result)",0.000479,25.99648438,"def shift_vowels_cyclically(s):
    vowels = ""aeiouAEIOU""
    v_chars = [c for c in s if c in vowels]
    if not v_chars:
        return s
    carry = v_chars[-1]
    res = []
    for char in s:
        if char in vowels:
            res.append(carry)
            carry = char
        else:
            res.append(char)
    return """".join(res)",0.0003939,25.99648438,"def shift_vowels_cyclically(s):
    import re
    vchars = [c for c in s if c in 'aeiouAEIOU']
    if not vchars:
        return s
    rotated = [vchars[-1]] + vchars[:-1]
    cnt = [0]
    def repl(match):
        i = cnt[0]
        cnt[0] += 1
        return rotated[i]
    return re.sub(r'[aeiouAEIOU]', repl, s)
",0.0008163,25.99648438,"['b', 'a', 'c']"
61,"
from typing import List

def match_index_parity(numbers: List[int]) -> List[int]:
""""""
Return a new list containing only the elements from the input list `numbers`
where the parity (evenness/oddness) of the element matches the parity of its index.

>>> match_index_parity([2, 1, 4, 3])
[2, 1, 4, 3]
>>> match_index_parity([1, 2, 3, 4])
[]
>>> match_index_parity([0, 2, 4, 6])
[0, 4]
>>> match_index_parity([10, 3, 5, 2])
[10, 3]
""""""
","from typing import List

def match_index_parity(numbers: List[int]) -> List[int]:
    return [n for i, n in enumerate(numbers) if i % 2 == n % 2]",0.0004315,26.42890625,"from typing import List

def match_index_parity(numbers: List[int]) -> List[int]:
    result = []
    index_is_even = True
    for val in numbers:
        num_is_even = val % 2 == 0
        if num_is_even == index_is_even:
            result.append(val)
        index_is_even = not index_is_even
    return result",0.0005026,26.42890625,"def match_index_parity(numbers: List[int]) -> List[int]:
    res = []
    for i, n in enumerate(numbers):
        if ((i ^ n) & 1) == 0:
            res.append(n)
    return res",0,0,"['a', 'b', 'c']"
62,"
def filter_divisible_by_digit_sum(numbers: list[int]) -> list[int]:
""""""
Filter the input list of positive integers to include only numbers that are
divisible by the sum of their own digits.

The resulting list should be sorted primarily by the sum of the digits in
ascending order. If two numbers have the same digit sum, sort them by their
original value in descending order.

examples:
filter_divisible_by_digit_sum([12, 13, 20, 45, 10])
# Returns [10, 20, 12, 45]
# Explanation:
# 10 (sum 1, 10%1==0), 20 (sum 2, 20%2==0), 12 (sum 3, 12%3==0), 45 (sum 9, 45%9==0). 13 is excluded.
# Sorted by sum: 10(1), 20(2), 12(3), 45(9).

filter_divisible_by_digit_sum([21, 12, 111])
# Returns [111, 21, 12]
# Explanation:
# 21 (sum 3, divisible), 12 (sum 3, divisible), 111 (sum 3, divisible).
# All have sum 3. Tie-break by value descending: 111, 21, 12.

filter_divisible_by_digit_sum([7, 23, 100])
# Returns [100, 7]
""""""
","def filter_divisible_by_digit_sum(numbers: list[int]) -> list[int]:
    def digit_sum(n):
        return sum(int(d) for d in str(n))
    filtered = [(n, digit_sum(n)) for n in numbers if n % digit_sum(n) == 0]
    filtered.sort(key=lambda x: (x[1], -x[0]))
    return [n for n, _ in filtered]",0.0018813,92.99492188,"def filter_divisible_by_digit_sum(numbers: list[int]) -> list[int]:
    groups = {}
    for val in numbers:
        d_sum = 0
        for digit in str(val):
            d_sum += int(digit)
        if val % d_sum == 0:
            if d_sum not in groups:
                groups[d_sum] = []
            groups[d_sum].append(val)
    result = []
    for s in sorted(groups):
        batch = groups[s]
        batch.sort(reverse=True)
        result.extend(batch)
    return result",0.0006008,26.56679688,"def filter_divisible_by_digit_sum(numbers: list[int]) -> list[int]:
    def digit_sum(n: int) -> int:
        s = 0
        x = n
        while x:
            s += x % 10
            x //= 10
        return s

    candidates: list[tuple[int, int]] = []
    for n in numbers:
        s = digit_sum(n)
        if s > 0 and n % s == 0:
            candidates.append((n, s))

    candidates.sort(key=lambda t: (t[1], -t[0]))
    return [n for n, _ in candidates]",0.0004809,26.56679688,"['c', 'b', 'a']"
63,"
from typing import List

def filter_alternating(words: List[str]) -> List[str]:
""""""
Given a list of strings, return a new list containing only the strings where the
characters strictly alternate between vowels ('a', 'e', 'i', 'o', 'u') and
consonants. The alternation can start with either type.
Checks are case-insensitive, but original casing must be preserved.
Single character strings and empty strings are considered valid.

filter_alternating([""banana"", ""apple"", ""Ace""]) == [""banana"", ""Ace""]
filter_alternating([""Cat"", ""Dog"", ""Egg""]) == [""Cat"", ""Dog""]
filter_alternating([""aa"", ""bb"", ""a"", ""b""]) == [""a"", ""b""]
filter_alternating([]) == []
""""""
pass
","from typing import List

def filter_alternating(words: List[str]) -> List[str]:
    vowels = set('aeiouAEIOU')
    def is_alternating(word):
        if len(word) <= 1:
            return True
        for i in range(len(word) - 1):
            c1_vowel = word[i] in vowels
            c2_vowel = word[i+1] in vowels
            if c1_vowel == c2_vowel:
                return False
        return True
    return [w for w in words if is_alternating(w)]",0.0005907,27.20898438,"from typing import List

def filter_alternating(words: List[str]) -> List[str]:
    vowels = set('aeiouAEIOU')
    result = []
    for word in words:
        evens = word[::2]
        odds = word[1::2]
        evens_v = all(c in vowels for c in evens)
        evens_c = all(c not in vowels for c in evens)
        odds_v = all(c in vowels for c in odds)
        odds_c = all(c not in vowels for c in odds)
        if (evens_v and odds_c) or (evens_c and odds_v):
            result.append(word)
    return result",0.0007555,27.20898438,"def filter_alternating(words: List[str]) -> List[str]:
    import re
    pat_v = re.compile(r'^(?:[aeiouAEIOU](?:[^aeiouAEIOU][aeiouAEIOU])*)$')
    pat_c = re.compile(r'^(?:[^aeiouAEIOU](?:[aeiouAEIOU][^aeiouAEIOU])*)$')
    res = []
    for w in words:
        if w == """":
            res.append(w)
        elif pat_v.match(w) or pat_c.match(w):
            res.append(w)
    return res",0,0,"['a', 'b', 'c']"
64,"
def find_dominant_prefix(numbers: list) -> int:
""""""
Given a list of numbers, return the first index 'i' (where 0 <= i < len(numbers) - 1)
such that the average of the sequence up to and including 'i' is strictly
greater than the average of the remaining elements following 'i'.

Return -1 if the list contains fewer than 2 elements or if no such index exists.

Examples:
find_dominant_prefix([5, 1, 1, 1]) == 0 # Avg([5])=5.0 > Avg([1,1,1])=1.0
find_dominant_prefix([1, 2, 3, 4]) == -1 # No split satisfies the condition.
find_dominant_prefix([3, 3, 10, 2]) == 2 # Avg([3,3,10])=5.33... > Avg([2])=2.0
find_dominant_prefix([1.0, 0.5]) == 0 # Avg([1.0])=1.0 > Avg([0.5])=0.5
""""""
","def find_dominant_prefix(numbers: list) -> int:
    if len(numbers) < 2:
        return -1
    total = sum(numbers)
    prefix_sum = 0
    for i in range(len(numbers) - 1):
        prefix_sum += numbers[i]
        suffix_sum = total - prefix_sum
        prefix_avg = prefix_sum / (i + 1)
        suffix_avg = suffix_sum / (len(numbers) - i - 1)
        if prefix_avg > suffix_avg:
            return i
    return -1",0.0004588,26.45449219,"def find_dominant_prefix(numbers: list) -> int:
    if len(numbers) < 2:
        return -1
    avg_all = sum(numbers) / len(numbers)
    current_total = 0
    for i in range(len(numbers) - 1):
        current_total += numbers[i]
        if current_total / (i + 1) > avg_all:
            return i
    return -1",0.0004625,26.44980469,"def find_dominant_prefix(numbers: list) -> int:
    """"""
    Given a list of numbers, return the first index i such that the average of the
    prefix up to i is strictly greater than the average of the remaining elements.
    """"""
    n = len(numbers)
    if n < 2:
        return -1
    total = sum(numbers)
    prefix = 0
    for i in range(n - 1):
        prefix += numbers[i]
        if prefix * n > total * (i + 1):
            return i
    return -1",0.000553,26.44980469,"['a', 'b', 'c']"
65,"
def flip_even_count_chars(s: str) -> str:
""""""
Given a string s, return a new string where every character that appears
an even number of times in the original string has its case swapped
(lower to upper, upper to lower). Characters appearing an odd number
of times remain unchanged.

Note: Frequency counting is case-sensitive (e.g., 'a' and 'A' are distinct).

Examples:
flip_even_count_chars(""aaBBc"") == ""AAbbc""
flip_even_count_chars(""Abc"") == ""Abc""
flip_even_count_chars(""zzZZN"") == ""ZZzzN""
""""""
","def flip_even_count_chars(s: str) -> str:
    from collections import Counter
    counts = Counter(s)
    return ''.join(c.swapcase() if counts[c] % 2 == 0 else c for c in s)",0.0008014,25.98964844,"def flip_even_count_chars(s: str) -> str:
    swaps = """".join(c for c in set(s) if s.count(c) % 2 == 0)
    return s.translate(str.maketrans(swaps, swaps.swapcase()))",0.0005472,25.98964844,"def flip_even_count_chars(s: str) -> str:
    parity = {}
    for ch in s:
        parity[ch] = 1 - parity.get(ch, 0)
    result = []
    for ch in s:
        if parity[ch] == 0:
            result.append(ch.swapcase())
        else:
            result.append(ch)
    return ''.join(result)
",0.0008884,25.98964844,"['b', 'a', 'c']"
66,"
def cyclic_encode_consecutive(s: str) -> str:
""""""
Given a string `s` consisting of lowercase alphabets, split the string into
groups of consecutive identical characters. Process each group as follows:

- If the group length is odd, replace every character in that group with the
next character in the alphabet (circularly, so 'z' becomes 'a').
- If the group length is even, leave the characters in that group unchanged.

Return the final joined string.

Examples:
cyclic_encode_consecutive(""aaabbb"") == ""bbbccc""
cyclic_encode_consecutive(""xxyyyz"") == ""xxzzza""
cyclic_encode_consecutive(""aabb"") == ""aabb""
cyclic_encode_consecutive(""zz"") == ""zz""
""""""
","def cyclic_encode_consecutive(s: str) -> str:
    if not s:
        return """"
    result = []
    i = 0
    while i < len(s):
        char = s[i]
        count = 1
        while i + count < len(s) and s[i + count] == char:
            count += 1
        if count % 2 == 1:
            next_char = chr((ord(char) - ord('a') + 1) % 26 + ord('a'))
            result.append(next_char * count)
        else:
            result.append(char * count)
        i += count
    return ''.join(result)",0.0006747,25.99121094,"def cyclic_encode_consecutive(s: str) -> str:
    if not s:
        return """"
    parts = []
    group_char = s[0]
    size = 0
    for char in s + ""*"":
        if char == group_char:
            size += 1
        else:
            if size % 2:
                new_char = chr((ord(group_char) - 97 + 1) % 26 + 97)
                parts.append(new_char * size)
            else:
                parts.append(group_char * size)
            group_char = char
            size = 1
    return """".join(parts)",0.0006598,25.99121094,"def cyclic_encode_consecutive(s: str) -> str:
    if not s:
        return """"
    from itertools import groupby
    out = []
    for ch, grp in groupby(s):
        cnt = sum(1 for _ in grp)
        if cnt % 2:
            nxt = chr((ord(ch) - ord('a') + 1) % 26 + ord('a'))
            out.append(nxt * cnt)
        else:
            out.append(ch * cnt)
    return ''.join(out)",0.0007127,25.99121094,"['b', 'a', 'c']"
67,"
from typing import List

def vowel_switch_process(items: List[str]) -> List[str]:
""""""
Given a list of strings, filter and transform them based on specific rules.
1. Discard any string that does not contain at least one vowel (a, e, i, o, u), case-insensitive.
2. For the remaining strings:
- If the string length is even, swap the first half with the second half.
- If the string length is odd, reverse the string.

Return the list of processed strings in their original relative order.

Examples:
vowel_switch_process([""apple"", ""sky"", ""tree""]) == [""elppa"", ""eetr""]
vowel_switch_process([""Banana"", ""rhythm"", ""code""]) == [""anaBan"", ""deco""]
vowel_switch_process([""odd"", ""even""]) == [""ddo"", ""enev""]
vowel_switch_process([""fly"", ""try""]) == []
""""""
pass
","from typing import List

def vowel_switch_process(items: List[str]) -> List[str]:
    vowels = set('aeiouAEIOU')
    result = []
    for s in items:
        if not any(c in vowels for c in s):
            continue
        if len(s) % 2 == 0:
            half = len(s) // 2
            result.append(s[half:] + s[:half])
        else:
            result.append(s[::-1])
    return result",0.0009147,26.60273438,"from typing import List

def vowel_switch_process(items: List[str]) -> List[str]:
    vowels = {'a', 'e', 'i', 'o', 'u'}
    final_list = []
    for word in items:
        if not (vowels & set(word.lower())):
            continue
        n = len(word)
        if n % 2 == 1:
            final_list.append("""".join(reversed(word)))
        else:
            pivot = n // 2
            final_list.append(word[pivot:] + word[:pivot])
    return final_list",0.000924,26.60273438,"def vowel_switch_process(items: List[str]) -> List[str]:
    import re
    res = []
    for w in items:
        if not re.search(r'[aeiouAEIOU]', w):
            continue
        n = len(w)
        if n % 2 == 0:
            mid = n // 2
            res.append(w[mid:] + w[:mid])
        else:
            res.append(w[::-1])
    return res",0,0,"['a', 'b', 'c']"
68,"
def interleave_and_sum_tail(l1: list, l2: list) -> list:
""""""
Interleave elements from two integer lists l1 and l2, alternating between them starting with l1.
When the shorter list is exhausted, sum all remaining elements of the longer list and append
this sum as the final element of the result. If both lists are of equal length, just interleave
them without appending a sum.

Examples:
interleave_and_sum_tail([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3]
interleave_and_sum_tail([1, 2], [3, 4, 5, 6]) == [1, 3, 2, 4, 11]
interleave_and_sum_tail([10, 20], [1, 2]) == [10, 1, 20, 2]
interleave_and_sum_tail([], [5, 10, 2]) == [17]
""""""
pass
","def interleave_and_sum_tail(l1: list, l2: list) -> list:
    result = []
    min_len = min(len(l1), len(l2))
    for i in range(min_len):
        result.append(l1[i])
        result.append(l2[i])
    if len(l1) > min_len:
        result.append(sum(l1[min_len:]))
    elif len(l2) > min_len:
        result.append(sum(l2[min_len:]))
    return result",0.0008782,26.79121094,"def interleave_and_sum_tail(l1: list, l2: list) -> list:
    result = []
    for x, y in zip(l1, l2):
        result.extend([x, y])
    tail = l1[len(l2):] + l2[len(l1):]
    if tail:
        result.append(sum(tail))
    return result",0.0017415,26.79121094,"def interleave_and_sum_tail(l1: list, l2: list) -> list:
    n1, n2 = len(l1), len(l2)
    suff1 = [0] * (n1 + 1)
    for i in range(n1 - 1, -1, -1):
        suff1[i] = suff1[i + 1] + l1[i]
    suff2 = [0] * (n2 + 1)
    for j in range(n2 - 1, -1, -1):
        suff2[j] = suff2[j + 1] + l2[j]
    def rec(i, j):
        if i == n1 and j == n2:
            return []
        if i == n1:
            return [suff2[j]]
        if j == n2:
            return [suff1[i]]
        return [l1[i], l2[j]] + rec(i + 1, j + 1)
    return rec(0, 0)",0.0010305,26.79121094,"['a', 'c', 'b']"
69,"
def cyclic_mixed_parity_diff(numbers: list[int]) -> int:
""""""
Given a list of integers, calculate the sum of absolute differences between adjacent elements
(considering the list as circular), but only sum the difference if the pair consists of
one even and one odd number.

The last element is considered adjacent to the first element.
If the list has fewer than 2 elements, return 0.

>>> cyclic_mixed_parity_diff([1, 2, 4, 6])
6
>>> cyclic_mixed_parity_diff([10, 5])
10
>>> cyclic_mixed_parity_diff([2, 4, 6])
0
>>> cyclic_mixed_parity_diff([1, 2, 3])
2
""""""
","def cyclic_mixed_parity_diff(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    for i in range(len(numbers)):
        a = numbers[i]
        b = numbers[(i + 1) % len(numbers)]
        if a % 2 != b % 2:
            total += abs(a - b)
    return total",0.0008782,26.48398438,"def cyclic_mixed_parity_diff(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    prev = numbers[-1]
    for curr in numbers:
        if (prev + curr) % 2 == 1:
            total += abs(prev - curr)
        prev = curr
    return total",0.0008731,26.48398438,"def cyclic_mixed_parity_diff(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    adj = zip(numbers, numbers[1:] + numbers[:1])
    return sum(abs(a - b) for a, b in adj if (a ^ b) & 1)",0.0008047,26.48398438,"['c', 'b', 'a']"
70,"
from typing import List

def is_valid_sequence(words: List[str]) -> bool:
""""""
Determine if a sequence of words is valid based on specific adjacency rules.
A sequence is considered valid if for every consecutive pair of words (words[i], words[i+1]),
EITHER the last character of words[i] matches the first character of words[i+1],
OR the two words have the same length.

If the list is empty or contains only one word, it is considered valid.
All words in the list are guaranteed to be non-empty strings.

Examples:
is_valid_sequence([""apple"", ""eagle"", ""event""]) == True
is_valid_sequence([""cat"", ""dog"", ""bird""]) == False
is_valid_sequence([""code"", ""editor"", ""read""]) == True
is_valid_sequence([""ball"", ""call"", ""lead""]) == True
""""""
if len(words) < 2:
return True

for i in range(len(words) - 1):
curr_word = words[i]
next_word = words[i+1]

match_char = curr_word[-1] == next_word[0]
match_len = len(curr_word) == len(next_word)

if not (match_char or match_len):
return False

return True
","from typing import List

def is_valid_sequence(words: List[str]) -> bool:
    if len(words) < 2:
        return True
    for i in range(len(words) - 1):
        curr_word = words[i]
        next_word = words[i+1]
        match_char = curr_word[-1] == next_word[0]
        match_len = len(curr_word) == len(next_word)
        if not (match_char or match_len):
            return False
    return True",0.000753,26.47382813,"from typing import List

def is_valid_sequence(words: List[str]) -> bool:
    for left, right in zip(words, words[1:]):
        if left[-1] != right[0] and len(left) != len(right):
            return False
    return True",0.0005216,26.47382813,"def is_valid_sequence(words):
    if len(words) < 2:
        return True
    i = 0
    while i < len(words) - 1:
        a = words[i]
        b = words[i+1]
        if not (a[-1] == b[0] or len(a) == len(b)):
            return False
        i += 1
    return True",0.0004341,26.47382813,"['c', 'b', 'a']"
71,"
def shift_by_digits(s: str) -> str:
""""""
Calculate the sum of all numerical digits found in the input string s.
- If the sum is greater than 0, return the string s circularly shifted to the right by that sum.
- If the sum is 0 or no digits are present, return the reversed string s.

>>> shift_by_digits(""abc12"")
'c12ab'
>>> shift_by_digits(""hello"")
'olleh'
>>> shift_by_digits(""a1b2c"")
'b2ca1'
>>> shift_by_digits(""no7digits0here"")
'ereno7digits0h'
""""""
","def shift_by_digits(s: str) -> str:
    digit_sum = sum(int(c) for c in s if c.isdigit())
    if digit_sum == 0:
        return s[::-1]
    shift = digit_sum % len(s) if s else 0
    return s[-shift:] + s[:-shift] if s else s",0.000386,26,"def shift_by_digits(s: str) -> str:
    if not s:
        return s
    total = 0
    for c in s:
        if '0' <= c <= '9':
            total += int(c)
    if total == 0:
        res = """"
        for char in s:
            res = char + res
        return res
    n = len(s)
    shift = total % n
    chars = []
    for i in range(n):
        chars.append(s[i - shift])
    return """".join(chars)",0.0003706,26,"from collections import deque

def shift_by_digits(s: str) -> str:
    if not s:
        return s
    total = 0
    for ch in s:
        if ch.isdigit():
            total += ord(ch) - 48
    if total == 0:
        return s[::-1]
    d = deque(s)
    d.rotate(total % len(s))
    return ''.join(d)
",0.000456,26,"['b', 'a', 'c']"
72,"
from typing import List

def count_shared_digit_pairs(nums: List[int]) -> int:
""""""
Given a list of integers, count the number of adjacent pairs (nums[i], nums[i+1])
that share at least one common digit.

Negative numbers should be treated as positive (ignore the '-' sign).

Examples:
count_shared_digit_pairs([12, 23, 34, 45]) == 3
count_shared_digit_pairs([10, 20, 30]) == 2
count_shared_digit_pairs([-15, 57, 77]) == 2 # (15, 57) share '5', (57, 77) share '7'
count_shared_digit_pairs([1, 2, 3]) == 0
""""""
pass
","from typing import List

def count_shared_digit_pairs(nums: List[int]) -> int:
    count = 0
    for i in range(len(nums) - 1):
        digits1 = set(str(abs(nums[i])))
        digits2 = set(str(abs(nums[i+1])))
        if digits1 & digits2:
            count += 1
    return count",0.0005822,26.68632813,"from typing import List

def count_shared_digit_pairs(nums: List[int]) -> int:
    count = 0
    for n1, n2 in zip(nums, nums[1:]):
        s1, s2 = str(abs(n1)), str(abs(n2))
        found = False
        for digit in ""0123456789"":
            if digit in s1 and digit in s2:
                found = True
                break
        if found:
            count += 1
    return count",0.0005325,26.68632813,"def count_shared_digit_pairs(nums: List[int]) -> int:
    if len(nums) < 2:
        return 0
    masks = []
    for n in nums:
        x = abs(n)
        m = 0
        if x == 0:
            m |= 1
        while x:
            d = x % 10
            m |= 1 << d
            x //= 10
        masks.append(m)
    count = 0
    for i in range(len(masks) - 1):
        if masks[i] & masks[i + 1]:
            count += 1
    return count",0,0,"['b', 'a', 'c']"
73,"
def transform_words(sentence: str) -> str:
""""""
Given a sentence string where words are separated by spaces, apply the following
transformations to each word based on its length and return the new sentence:

- If the word length is even, swap the first and last characters.
- If the word length is odd, reverse the entire word.

Note: Treat punctuation as part of the word. Words are case-sensitive.

Examples:
transform_words(""Hello World"") == ""olleH dlorW""
transform_words(""data structures"") == ""aatd serutcurts""
transform_words(""odd even"") == ""ddo nvee""
transform_words(""a ab abc abcd"") == ""a ba cba dbca""
""""""
","def transform_words(sentence: str) -> str:
    words = sentence.split(' ')
    result = []
    for word in words:
        if len(word) % 2 == 0:
            result.append(word[-1] + word[1:-1] + word[0] if len(word) > 1 else word)
        else:
            result.append(word[::-1])
    return ' '.join(result)",0.0003873,26.01464844,"def transform_words(sentence: str) -> str:
    words = sentence.split(' ')
    new_words = []
    for w in words:
        if len(w) % 2 == 1:
            new_words.append("""".join(reversed(w)))
        elif len(w) > 1:
            chars = list(w)
            chars[0], chars[-1] = chars[-1], chars[0]
            new_words.append("""".join(chars))
        else:
            new_words.append(w)
    return "" "".join(new_words)",0.0004385,26.01464844,"def transform_words(sentence: str) -> str:
    def proc(w: str) -> str:
        n = len(w)
        if n % 2 == 0:
            if n <= 1:
                return w
            chars = []
            for i, ch in enumerate(w):
                if i == 0:
                    chars.append(w[-1])
                elif i == n - 1:
                    chars.append(w[0])
                else:
                    chars.append(ch)
            return ''.join(chars)
        else:
            return ''.join(reversed(w))

    return ' '.join(map(proc, sentence.split(' ')))",0.000397,26.01464844,"['a', 'c', 'b']"
74,"
from typing import List

def running_diff_max_min(numbers: List[int]) -> List[int]:
""""""
Given a list of integers, return a new list where the element at index i
is the difference between the maximum and minimum values in the sub-list
from index 0 to i (inclusive).

The input list can contain positive and negative integers.
If the input list is empty, return an empty list.

Examples:
running_diff_max_min([1, 2, 3, 4]) == [0, 1, 2, 3]
running_diff_max_min([10, 5, 20, 3]) == [0, 5, 15, 17]
running_diff_max_min([-5, -1, -10]) == [0, 4, 9]
""""""
","from typing import List

def running_diff_max_min(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    result = []
    current_max = numbers[0]
    current_min = numbers[0]
    for n in numbers:
        current_max = max(current_max, n)
        current_min = min(current_min, n)
        result.append(current_max - current_min)
    return result",0.0005033,26.35351563,"from typing import List
from itertools import accumulate

def running_diff_max_min(numbers: List[int]) -> List[int]:
    high = accumulate(numbers, max)
    low = accumulate(numbers, min)
    return [h - l for h, l in zip(high, low)]",0.0012176,26.35351563,"def running_diff_max_min(numbers):
    result = []
    for i in range(len(numbers)):
        sub = numbers[:i+1]
        result.append(max(sub) - min(sub))
    return result",0.0007723,26.35351563,"['a', 'c', 'b']"
75,"
from typing import List

def count_local_peaks(numbers: List[int]) -> int:
""""""
Count the number of elements in the list that are strictly greater than their
immediate neighbors. For the first and last elements, they only need to be
greater than their single neighbor.

Return 0 if the list contains fewer than 2 elements.

>>> count_local_peaks([1, 3, 2, 3, 1])
2
>>> count_local_peaks([5, 1, 5])
2
>>> count_local_peaks([1, 2, 3, 4, 5])
1
>>> count_local_peaks([1])
0
""""""
","from typing import List

def count_local_peaks(numbers: List[int]) -> int:
    if len(numbers) < 2:
        return 0
    count = 0
    for i in range(len(numbers)):
        if i == 0:
            if numbers[i] > numbers[i+1]:
                count += 1
        elif i == len(numbers) - 1:
            if numbers[i] > numbers[i-1]:
                count += 1
        else:
            if numbers[i] > numbers[i-1] and numbers[i] > numbers[i+1]:
                count += 1
    return count",0.0004803,26.43378906,"from typing import List

def count_local_peaks(numbers: List[int]) -> int:
    if len(numbers) < 2:
        return 0
    
    extended = [float('-inf')] + numbers + [float('-inf')]
    total_peaks = 0
    
    for i in range(1, len(extended) - 1):
        if extended[i] > extended[i - 1] and extended[i] > extended[i + 1]:
            total_peaks += 1
            
    return total_peaks",0.0006335,26.43378906,"def count_local_peaks(numbers):
    n = len(numbers)
    if n < 2:
        return 0
    diffs = [numbers[i+1] - numbers[i] for i in range(n-1)]
    count = 0
    if diffs[0] < 0:
        count += 1
    if diffs[-1] > 0:
        count += 1
    for i in range(1, n-1):
        if diffs[i-1] > 0 and diffs[i] < 0:
            count += 1
    return count",0.0005752,26.43378906,"['a', 'c', 'b']"
76,"
def circular_parity_sum(arr: list[int]) -> int:
""""""
Given a list of integers, return the sum of all elements that have the same parity
(both even or both odd) as the element immediately preceding them.
The list is treated as circular, meaning the first element's preceding neighbor
is the last element of the list.

If the list is empty, return 0.

Examples:
circular_parity_sum([1, 3, 2, 4]) == 7
circular_parity_sum([2, 4, 6, 8]) == 20
circular_parity_sum([1, 2, 3]) == 0
circular_parity_sum([5]) == 5
""""""
","def circular_parity_sum(arr: list[int]) -> int:
    if not arr:
        return 0
    if len(arr) == 1:
        return arr[0]
    total = 0
    for i in range(len(arr)):
        prev = arr[(i - 1) % len(arr)]
        if arr[i] % 2 == prev % 2:
            total += arr[i]
    return total",0.0004147,26.32070313,"def circular_parity_sum(arr: list[int]) -> int:
    if not arr:
        return 0
    total = 0
    last_parity = arr[-1] % 2
    for x in arr:
        parity = x % 2
        if parity == last_parity:
            total += x
        last_parity = parity
    return total",0.0004365,26.32070313,"def circular_parity_sum(arr: list[int]) -> int:
    if not arr:
        return 0
    rotated = arr[-1:] + arr[:-1]
    total = 0
    for prev, curr in zip(rotated, arr):
        if (prev & 1) == (curr & 1):
            total += curr
    return total
",0.0004161,26.32070313,"['a', 'c', 'b']"
77,"
def select_words(s: str, n: int):
""""""
Given a string s consisting of words separated by spaces, return a list of words
that satisfy the following two conditions:
1. The length of the word is exactly n.
2. The number of consonants in the word is strictly greater than the number of vowels.

Vowels are 'a', 'e', 'i', 'o', 'u' (case insensitive).
Consonants are all other alphabetic characters.
The output list should retain the order of words from the input.

Examples:
select_words(""Mary had a little lamb"", 4) ==> [""Mary"", ""lamb""]
select_words(""Good work"", 4) ==> [""work""]
select_words(""Hello world"", 5) ==> [""Hello"", ""world""]
select_words(""aeiou"", 5) ==> []
""""""
","def select_words(s: str, n: int):
    vowels = set('aeiouAEIOU')
    result = []
    for word in s.split():
        if len(word) == n:
            consonants = sum(1 for c in word if c.isalpha() and c not in vowels)
            word_vowels = sum(1 for c in word if c in vowels)
            if consonants > word_vowels:
                result.append(word)
    return result",0.0005847,26.09121094,"def select_words(s: str, n: int):
    result = []
    for word in s.split():
        if len(word) == n:
            alphas = """".join(c.lower() for c in word if c.isalpha())
            consonants = alphas
            for v in ""aeiou"":
                consonants = consonants.replace(v, """")
            
            if len(consonants) > len(alphas) - len(consonants):
                result.append(word)
    return result",0.0006516,26.09121094,"def select_words(s: str, n: int):
    import re
    res = []
    for word in s.split():
        if len(word) == n:
            letters = re.sub('[^A-Za-z]', '', word)
            if not letters:
                continue
            vowels_in_letters = sum(1 for ch in letters if ch in 'aeiouAEIOU')
            consonants = len(letters) - vowels_in_letters
            if consonants > vowels_in_letters:
                res.append(word)
    return res",0.0012358,26.09121094,"['a', 'b', 'c']"
78,"
def filter_above_others(nums):
""""""
Given a list of integers `nums`, return a new list containing only the elements
that are strictly greater than the average of the remaining elements (the average
of the list excluding that specific element).

If the list contains fewer than 2 elements, return an empty list.
The result should maintain the original order of the input list.

Examples:
filter_above_others([1, 2, 3]) == [3]
filter_above_others([5, 0, 10, 2]) == [5, 10]
filter_above_others([10, 10, 10]) == []
filter_above_others([100]) == []
""""""
","def filter_above_others(nums):
    if len(nums) < 2:
        return []
    total = sum(nums)
    result = []
    for i, n in enumerate(nums):
        others_avg = (total - n) / (len(nums) - 1)
        if n > others_avg:
            result.append(n)
    return result",0.0008345,26.45546875,"def filter_above_others(nums):
    if len(nums) <= 1:
        return []
    limit = sum(nums) / len(nums)
    return list(filter(lambda val: val > limit, nums))",0.0004728,26.45546875,"def filter_above_others(nums):
    n = len(nums)
    if n < 2:
        return []
    total = sum(nums)
    return [x for x in nums if x * n > total]",0.000408,26.45546875,"['c', 'b', 'a']"
79,"
def conditional_parity_sum(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, return a new list where each element at index i (except the last) is
replaced by the sum of numbers[i] and numbers[i+1] if they have different parity (one odd, one even).
If they have the same parity, the element remains numbers[i]. The last element is always preserved unchanged.

Examples:
conditional_parity_sum([1, 2, 3, 4]) == [3, 5, 7, 4]
conditional_parity_sum([2, 4, 6]) == [2, 4, 6]
conditional_parity_sum([10, 21, 3]) == [31, 21, 3]
conditional_parity_sum([5]) == [5]
conditional_parity_sum([]) == []
""""""
pass
","def conditional_parity_sum(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    for i in range(len(numbers) - 1):
        if numbers[i] % 2 != numbers[i+1] % 2:
            result.append(numbers[i] + numbers[i+1])
        else:
            result.append(numbers[i])
    result.append(numbers[-1])
    return result",0.00042,26.32050781,"def conditional_parity_sum(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    res = [a + b if (a + b) % 2 == 1 else a for a, b in zip(numbers, numbers[1:])]
    return res + [numbers[-1]]",0.0007697,26.32050781,"def conditional_parity_sum(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    i = 0
    res = []
    n = len(numbers)
    while i < n - 1:
        a = numbers[i]
        b = numbers[i+1]
        if (a ^ b) & 1:
            res.append(a + b)
        else:
            res.append(a)
        i += 1
    res.append(numbers[-1])
    return res",0.00045,26.32050781,"['a', 'c', 'b']"
80,"
def stabilize_valleys(numbers: list) -> list:
""""""
Given a list of integers, repeatedly remove all elements that are strictly
smaller than both their immediate left and right neighbors (valleys) until
the list stabilizes and no such elements remain.

Note: The first and last elements of the list are never considered valleys.

Examples:
stabilize_valleys([5, 3, 5, 2, 5]) == [5, 5, 5]
stabilize_valleys([10, 5, 8, 4, 9]) == [10, 9]
stabilize_valleys([1, 2, 3]) == [1, 2, 3]
stabilize_valleys([8, 1, 8, 1, 8]) == [8, 8, 8]
""""""
","def stabilize_valleys(numbers: list) -> list:
    while True:
        new_list = []
        removed = False
        for i, n in enumerate(numbers):
            if i == 0 or i == len(numbers) - 1:
                new_list.append(n)
            elif n < numbers[i-1] and n < numbers[i+1]:
                removed = True
            else:
                new_list.append(n)
        numbers = new_list
        if not removed:
            break
    return numbers",0.0005707,26.67792969,"def stabilize_valleys(numbers: list) -> list:
    while len(numbers) > 2:
        valleys = [x > y < z for x, y, z in zip(numbers, numbers[1:], numbers[2:])]
        if not any(valleys):
            break
        mask = [True] + [not v for v in valleys] + [True]
        numbers = [n for n, keep in zip(numbers, mask) if keep]
    return numbers",0.000592,26.67792969,"def stabilize_valleys(numbers: list) -> list:
    res = []
    for x in numbers:
        if len(res) < 2:
            res.append(x)
        else:
            while len(res) >= 2 and res[-1] < res[-2] and res[-1] < x:
                res.pop()
            res.append(x)
    return res",0.0004616,26.67792969,"['c', 'a', 'b']"
81,"
def dynamic_shift(strings: list) -> list:
""""""
Given a list of strings containing only lowercase alphabets, return a new list where each
string is transformed.

The transformation logic:
For each string, shift every character forward in the alphabet by a number equal to the
length of that string. The shift is cyclic (wrapping around from 'z' to 'a').

>>> dynamic_shift(['ab', 'xyz'])
['cd', 'abc']

>>> dynamic_shift(['hello', 'a'])
['mjqqt', 'b']

>>> dynamic_shift(['zzz'])
['ccc']

>>> dynamic_shift([])
[]
""""""
","def dynamic_shift(strings: list) -> list:
    result = []
    for s in strings:
        shift = len(s)
        new_s = ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a')) for c in s)
        result.append(new_s)
    return result",0.0005604,26.390625,"def dynamic_shift(strings: list) -> list:
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    result = []
    for word in strings:
        shift = len(word) % 26
        shifted_alphabet = alphabet[shift:] + alphabet[:shift]
        table = str.maketrans(alphabet, shifted_alphabet)
        result.append(word.translate(table))
    return result",0.000464,26.390625,"def dynamic_shift(strings: list) -> list:
    result = []
    for s in strings:
        L = len(s)
        shifted = []
        for ch in s:
            c = ch
            for _ in range(L):
                if c == 'z':
                    c = 'a'
                else:
                    c = chr(ord(c) + 1)
            shifted.append(c)
        result.append(''.join(shifted))
    return result",0.000464,26.390625,"['b', 'c', 'a']"
82,"
def chunk_transform(lst: list, k: int) -> list:
""""""
Split the input list into chunks of size k and apply a transformation to each chunk
based on its sum.

For each chunk:
- If the sum of the elements in the chunk is even, reverse the chunk.
- If the sum of the elements in the chunk is odd, sort the chunk in ascending order.

The final result is the concatenation of these transformed chunks.
The last chunk may contain fewer than k elements.

>>> chunk_transform([4, 2, 3, 5, 1], 2)
[2, 4, 5, 3, 1]

>>> chunk_transform([10, 11, 13], 2)
[10, 11, 13]

>>> chunk_transform([1, 1, 1], 3)
[1, 1, 1]
""""""
","def chunk_transform(lst: list, k: int) -> list:
    result = []
    for i in range(0, len(lst), k):
        chunk = lst[i:i+k]
        if sum(chunk) % 2 == 0:
            result.extend(chunk[::-1])
        else:
            result.extend(sorted(chunk))
    return result",0.0004938,26.92363281,"def chunk_transform(lst: list, k: int) -> list:
    if k < 1:
        return lst[:]
    output = []
    idx = 0
    while idx < len(lst):
        chunk = lst[idx : idx + k]
        if sum(chunk) % 2:
            chunk.sort()
        else:
            chunk.reverse()
        output += chunk
        idx += k
    return output",0.0004715,26.92363281,"def chunk_transform(lst: list, k: int) -> list:
    if k < 1:
        return lst[:]
    from itertools import chain
    chunk_gen = (lst[i:i+k] for i in range(0, len(lst), k))
    transformed = (chunk[::-1] if sum(chunk) % 2 == 0 else sorted(chunk) for chunk in chunk_gen)
    return list(chain.from_iterable(transformed))",0.0004715,26.92363281,"['b', 'a', 'c']"
83,"
def sum_unique_odd_digits(s: str) -> int:
""""""
Given a string s, return the sum of all odd digits (1, 3, 5, 7, 9)
that appear exactly once in the string. Non-digit characters are ignored.

>>> sum_unique_odd_digits(""a1b3c1"")
3
>>> sum_unique_odd_digits(""135"")
9
>>> sum_unique_odd_digits(""11335"")
5
>>> sum_unique_odd_digits(""2468"")
0
""""""
","def sum_unique_odd_digits(s: str) -> int:
    from collections import Counter
    digits = [c for c in s if c.isdigit()]
    counts = Counter(digits)
    return sum(int(d) for d in counts if counts[d] == 1 and int(d) % 2 == 1)",0.0004551,26.00429688,"def sum_unique_odd_digits(s: str) -> int:
    seen_once = set()
    seen_multiple = set()
    for char in s:
        if char in ""13579"":
            if char in seen_multiple:
                continue
            if char in seen_once:
                seen_once.remove(char)
                seen_multiple.add(char)
            else:
                seen_once.add(char)
    return sum(int(digit) for digit in seen_once)",0.0004205,26.00429688,"def sum_unique_odd_digits(s: str) -> int:
    counts = [0] * 10
    for ch in s:
        if '0' <= ch <= '9':
            counts[ord(ch) - ord('0')] += 1
    total = 0
    for d in (1, 3, 5, 7, 9):
        if counts[d] == 1:
            total += d
    return total",0.0004205,26.00429688,"['b', 'a', 'c']"
84,"
def cyclic_stretch(text: str, shifts: list[int]) -> str:
""""""
Given a string `text` and a list of non-negative integers `shifts`, generate a new string
where the character at index i in `text` is repeated `shifts[i % len(shifts)]` times.

If `text` or `shifts` is empty, return an empty string.

Examples:
cyclic_stretch(""abc"", [2]) == ""aabbcc""
cyclic_stretch(""code"", [1, 2]) == ""coodde""
cyclic_stretch(""xy"", [1, 3, 2]) == ""xyyy""
cyclic_stretch(""AB"", [0, 5]) == ""BBBBB""
""""""
","def cyclic_stretch(text: str, shifts: list[int]) -> str:
    if not text or not shifts:
        return """"
    result = []
    for i, c in enumerate(text):
        result.append(c * shifts[i % len(shifts)])
    return ''.join(result)",0.0007183,26.50097656,"def cyclic_stretch(text: str, shifts: list[int]) -> str:
    if not text or not shifts:
        return """"
    res = """"
    j = 0
    for char in text:
        res += char * shifts[j]
        j += 1
        if j == len(shifts):
            j = 0
    return res",0.0004891,26.50097656,"def cyclic_stretch(text: str, shifts: list[int]) -> str:
    if not text or not shifts:
        return """"
    from itertools import cycle
    s = cycle(shifts)
    return ''.join(ch * next(s) for ch in text)
",0.0004891,26.50097656,"['b', 'c', 'a']"
85,"
from typing import List

def batch_reverse(lst: List[int], n: int) -> List[int]:
""""""
Given a list of integers `lst` and a positive integer `n`, split the list into batches of size `n`.
Reverse the elements within every batch that is at an even index (0, 2, 4, ...).
Batches at odd indices (1, 3, 5, ...) should remain unchanged.
Return the reassembled list.

If the list length is not divisible by `n`, the last batch will contain the remaining elements
and is treated like any other batch based on its index.

Examples:
batch_reverse([1, 2, 3, 4, 5, 6], 2) == [2, 1, 3, 4, 6, 5]
batch_reverse([1, 2, 3, 4, 5], 3) == [3, 2, 1, 4, 5]
batch_reverse([10, 20, 30], 5) == [30, 20, 10]
batch_reverse([], 3) == []
""""""
","from typing import List

def batch_reverse(lst: List[int], n: int) -> List[int]:
    result = []
    batches = [lst[i:i+n] for i in range(0, len(lst), n)]
    for idx, batch in enumerate(batches):
        if idx % 2 == 0:
            result.extend(batch[::-1])
        else:
            result.extend(batch)
    return result",0.0920659,27.14648438,"from typing import List

def batch_reverse(lst: List[int], n: int) -> List[int]:
    res = list(lst)
    for i in range(0, len(res), 2 * n):
        res[i : i + n] = res[i : i + n][::-1]
    return res",0.0005065,27.14648438,"def batch_reverse(lst, n):
    if n <= 0 or not lst:
        return list(lst)
    L = len(lst)
    res = [0] * L
    for i in range(L):
        b = i // n
        start = b * n
        end = start + n
        if end > L:
            end = L
        m = end - start
        offset = i - start
        if b % 2 == 0:
            j = start + (m - 1 - offset)
        else:
            j = start + offset
        res[i] = lst[j]
    return res",0.0005065,27.14648438,"['b', 'c', 'a']"
86,"
from typing import List

def closest_vowel_distances(word: str) -> List[int]:
""""""
For a given string `word` consisting of lowercase English letters, generate a list
where each element represents the absolute index distance from the character at that
position to the nearest vowel ('a', 'e', 'i', 'o', 'u') in the string.

If a character is a vowel, its distance is 0.
If the string contains no vowels, return a list of -1s corresponding to each character.

Examples:
closest_vowel_distances(""apple"") == [0, 1, 2, 1, 0]
closest_vowel_distances(""bcd"") == [-1, -1, -1]
closest_vowel_distances(""banana"") == [1, 0, 1, 0, 1, 0]
closest_vowel_distances(""xyza"") == [3, 2, 1, 0]
""""""
","from typing import List

def closest_vowel_distances(word: str) -> List[int]:
    vowels = set('aeiou')
    vowel_positions = [i for i, c in enumerate(word) if c in vowels]
    if not vowel_positions:
        return [-1] * len(word)
    result = []
    for i in range(len(word)):
        min_dist = min(abs(i - pos) for pos in vowel_positions)
        result.append(min_dist)
    return result",0.0005357,26.00175781,"from typing import List

def closest_vowel_distances(word: str) -> List[int]:
    vowels = ""aeiou""
    if not any(c in vowels for c in word):
        return [-1] * len(word)
    
    n = len(word)
    result = []
    for i in range(n):
        for d in range(n):
            if (i - d >= 0 and word[i - d] in vowels) or (i + d < n and word[i + d] in vowels):
                result.append(d)
                break
    return result",0.0004073,26.00175781,"def closest_vowel_distances(word: str) -> List[int]:
    vowels = set('aeiou')
    n = len(word)
    if n == 0:
        return []
    if not any(c in vowels for c in word):
        return [-1] * n
    left = [0] * n
    last = -10**9
    for i, c in enumerate(word):
        if c in vowels:
            last = i
            left[i] = 0
        else:
            left[i] = i - last if last != -10**9 else n
    right = [0] * n
    nxt = 10**9
    for i in range(n - 1, -1, -1):
        c = word[i]
        if c in vowels:
            nxt = i
            right[i] = 0
        else:
            dist_r = nxt - i if nxt != 10**9 else n
            right[i] = dist_r
    return [min(left[i], right[i]) for i in range(n)]
",0.0004073,26.00175781,"['b', 'a', 'c']"
87,"
def max_even_subsegment(nums: list, k: int) -> int:
""""""
Given a list of integers 'nums' and an integer 'k', return the maximum sum of
any contiguous subsegment of length 'k' where all elements are even numbers.
If no such subsegment exists or if the list is shorter than 'k', return 0.

max_even_subsegment([2, 4, 6, 8], 2) == 14
max_even_subsegment([2, 4, 1, 8, 10], 2) == 18
max_even_subsegment([2, 1, 3, 5], 2) == 0
max_even_subsegment([4, 6], 3) == 0
""""""
pass
","def max_even_subsegment(nums: list, k: int) -> int:
    if k > len(nums):
        return 0
    max_sum = 0
    for i in range(len(nums) - k + 1):
        window = nums[i:i+k]
        if all(x % 2 == 0 for x in window):
            max_sum = max(max_sum, sum(window))
    return max_sum",0.0007027,27.29101563,"def max_even_subsegment(nums: list, k: int) -> int:
    if k <= 0:
        return 0
    even_islands = []
    current_island = []
    for x in nums:
        if x % 2 == 0:
            current_island.append(x)
        else:
            if len(current_island) >= k:
                even_islands.append(current_island)
            current_island = []
    if len(current_island) >= k:
        even_islands.append(current_island)
    all_sums = []
    for island in even_islands:
        current_sum = sum(island[:k])
        all_sums.append(current_sum)
        for i in range(k, len(island)):
            current_sum += island[i] - island[i-k]
            all_sums.append(current_sum)
    return max(all_sums) if all_sums else 0",0.0006672,27.29101563,"def max_even_subsegment(nums: list, k: int) -> int:
    n = len(nums)
    if k <= 0 or k > n:
        return 0
    window_sum = sum(nums[:k])
    even_count = sum(1 for x in nums[:k] if x % 2 == 0)
    best = window_sum if even_count == k else 0
    for i in range(1, n - k + 1):
        out = nums[i - 1]
        in_val = nums[i + k - 1]
        window_sum += in_val - out
        if out % 2 == 0:
            even_count -= 1
        if in_val % 2 == 0:
            even_count += 1
        if even_count == k and window_sum > best:
            best = window_sum
    return best",0.0006672,27.29101563,"['b', 'c', 'a']"
88,"
def conditional_transform(text: str, target: str) -> str:
""""""
Transform the string 'text' based on the frequency of the 'target' character within it:
1. If 'target' appears more than 2 times in 'text', return the entire string reversed.
2. If 'target' appears exactly 1 or 2 times, return the string with all instances of 'target' removed.
3. If 'target' does not appear in 'text', return the string unchanged.

The operation is case-sensitive. The 'target' is guaranteed to be a non-empty string of length 1.

>>> conditional_transform(""banana"", ""a"")
'ananab'
>>> conditional_transform(""calculator"", ""c"")
'alulator'
>>> conditional_transform(""robot"", ""z"")
'robot'
>>> conditional_transform(""assessment"", ""s"")
'tnemssessa'
""""""
","def conditional_transform(text: str, target: str) -> str:
    count = text.count(target)
    if count > 2:
        return text[::-1]
    elif count >= 1:
        return text.replace(target, """")
    return text",0.0004268,26.11191406,"def conditional_transform(text: str, target: str) -> str:
    parts = text.split(target)
    n = len(parts) - 1
    if n >= 3:
        return """".join(reversed(text))
    if n >= 1:
        return """".join(parts)
    return text",0.0004037,26.11191406,"def conditional_transform(text: str, target: str) -> str:
    count = 0
    for ch in text:
        if ch == target:
            count += 1
    if count > 2:
        return text[::-1]
    if count == 0:
        return text
    result = []
    for ch in text:
        if ch != target:
            result.append(ch)
    return ''.join(result)",0.0004037,26.11191406,"['c', 'b', 'a']"
89,"
def index_based_shift(text: str) -> str:
""""""
Given a string 'text', return a new string where every alphabetic character
is shifted forward in the alphabet by an amount equal to its index (0-indexed).

The shift is cyclic (wrapping around from 'z' to 'a' or 'Z' to 'A').
Non-alphabetic characters remain unchanged.

Examples:
index_based_shift(""abc"") == ""ace""
index_based_shift(""Hello"") == ""Hfnos""
index_based_shift(""World!"") == ""WqZnk!""
index_based_shift(""xyz"") == ""xzc""
""""""
","def index_based_shift(text: str) -> str:
    result = []
    for i, c in enumerate(text):
        if c.isalpha():
            base = ord('A') if c.isupper() else ord('a')
            shifted = chr((ord(c) - base + i) % 26 + base)
            result.append(shifted)
        else:
            result.append(c)
    return ''.join(result)",0.000359,25.99941406,"def index_based_shift(text: str) -> str:
    lower_alphabet = ""abcdefghijklmnopqrstuvwxyz""
    upper_alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    shifted_result = """"
    for i in range(len(text)):
        char = text[i]
        if char in lower_alphabet:
            old_pos = lower_alphabet.index(char)
            shifted_result += lower_alphabet[(old_pos + i) % 26]
        elif char in upper_alphabet:
            old_pos = upper_alphabet.index(char)
            shifted_result += upper_alphabet[(old_pos + i) % 26]
        else:
            shifted_result += char
    return shifted_result",0.000368,25.99941406,"def index_based_shift(text: str) -> str:
    lower = ""abcdefghijklmnopqrstuvwxyz""
    upper = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    maps = []
    for shift in range(26):
        low_map = {}
        up_map = {}
        for idx, ch in enumerate(lower):
            low_map[ch] = lower[(idx + shift) % 26]
        for idx, ch in enumerate(upper):
            up_map[ch] = upper[(idx + shift) % 26]
        maps.append((low_map, up_map))
    res = []
    for i, ch in enumerate(text):
        if ch.islower():
            res.append(maps[i % 26][0][ch])
        elif ch.isupper():
            res.append(maps[i % 26][1][ch])
        else:
            res.append(ch)
    return ''.join(res)",0.000368,25.99941406,"['a', 'b', 'c']"
90,"
def count_chain_pairs(words):
""""""
Given a list of non-empty strings, return the count of pairs (i, j) such that
i < j and the last character of words[i] is identical to the first character of words[j].
The comparison is case-sensitive.

Examples:
count_chain_pairs([""apple"", ""egg"", ""goat""]) == 2
count_chain_pairs([""cat"", ""dog"", ""tiger""]) == 1
count_chain_pairs([""a"", ""a"", ""a""]) == 3
count_chain_pairs([""abc"", ""def"", ""ghi""]) == 0
""""""
pass
","def count_chain_pairs(words):
    count = 0
    for i in range(len(words)):
        for j in range(i + 1, len(words)):
            if words[i][-1] == words[j][0]:
                count += 1
    return count",0.0004389,26.54140625,"def count_chain_pairs(words):
    count = 0
    starts = {}
    for word in words[::-1]:
        last_char = word[-1]
        if last_char in starts:
            count += starts[last_char]
        first_char = word[0]
        starts[first_char] = starts.get(first_char, 0) + 1
    return count",0.0004235,26.54140625,"def count_chain_pairs(words):
    last_count = {}
    total = 0
    for w in words:
        total += last_count.get(w[0], 0)
        last_count[w[-1]] = last_count.get(w[-1], 0) + 1
    return total",0.0004235,26.54140625,"['c', 'b', 'a']"
91,"
from typing import List

def group_by_parity_sum(numbers: List[int]) -> List[int]:
""""""
Given a list of integers, partition the list into contiguous groups where each group
consists of numbers that share the same parity (either all even or all odd).
Return a new list containing the sum of elements for each of these groups in order.

If the input list is empty, return an empty list.

Examples:
group_by_parity_sum([1, 3, 2, 4]) == [4, 6] # [1, 3] are odd, [2, 4] are even
group_by_parity_sum([1, 2, 3, 4]) == [1, 2, 3, 4] # Alternating parity creates groups of size 1
group_by_parity_sum([2, 4, 6, 8]) == [20] # All are even
group_by_parity_sum([1, 3, 5, 2, 4, 1]) == [9, 6, 1] # [1, 3, 5], [2, 4], [1]
""""""
pass
","from typing import List

def group_by_parity_sum(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0004757,26.88242188,"from typing import List

def group_by_parity_sum(numbers: List[int]) -> List[int]:
    res = []
    i = 0
    while i < len(numbers):
        start = i
        p = numbers[i] % 2
        while i < len(numbers) and numbers[i] % 2 == p:
            i += 1
        res.append(sum(numbers[start:i]))
    return res",0.000472,26.88242188,"def group_by_parity_sum(numbers: List[int]) -> List[int]:
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers, key=lambda x: x % 2)]",0.000472,26.88242188,"['b', 'a', 'c']"
92,"
from typing import List

def filter_by_prefix_limit(numbers: List[int], limit: int) -> List[int]:
""""""
Given a list of integers and an integer limit, return a new list containing
only the elements that appear within the first 'limit' occurrences of that
specific value in the original list, preserving the original order.

>>> filter_by_prefix_limit([1, 2, 3, 1, 2, 1], 2)
[1, 2, 3, 1, 2]
>>> filter_by_prefix_limit([5, 5, 5, 5], 1)
[5]
>>> filter_by_prefix_limit([10, 20, 30], 5)
[10, 20, 30]
""""""
pass
","from typing import List

def filter_by_prefix_limit(numbers: List[int], limit: int) -> List[int]:
    from collections import defaultdict
    counts = defaultdict(int)
    result = []
    for n in numbers:
        if counts[n] < limit:
            result.append(n)
            counts[n] += 1
    return result",0.000576,26.88847656,"from typing import List

def filter_by_prefix_limit(numbers: List[int], limit: int) -> List[int]:
    filtered = []
    for i, num in enumerate(numbers):
        if numbers[:i].count(num) < limit:
            filtered.append(num)
    return filtered",0.0007397,26.88847656,"def filter_by_prefix_limit(numbers: List[int], limit: int) -> List[int]:
    index_map = {}
    if limit <= 0:
        return []
    for idx, val in enumerate(numbers):
        lst = index_map.get(val)
        if lst is None:
            index_map[val] = [idx]
        elif len(lst) < limit:
            lst.append(idx)
    idxs = []
    for lst in index_map.values():
        idxs.extend(lst)
    idxs.sort()
    return [numbers[i] for i in idxs]",0.0007397,26.88847656,"['a', 'b', 'c']"
93,"
def bridge_words(text: str) -> str:
""""""
Given a string `text`, return a new string where every whitespace sequence
between two words is replaced by the string representation of the sum of
the lengths of the two adjacent words.

- Words are defined as sequences of non-space characters.
- Leading and trailing spaces should be ignored.
- If there is only one word, return it as is.

Examples:
bridge_words(""Hello World"") == ""Hello10World""
bridge_words("" is great "") == "" 8is7great""
bridge_words(""a bb ccc"") == ""a3bb5ccc""
bridge_words("""") == """"
""""""
","def bridge_words(text: str) -> str:
    words = text.split()
    if len(words) <= 1:
        return text.strip()
    result = [words[0]]
    for i in range(1, len(words)):
        bridge = len(words[i-1]) + len(words[i])
        result.append(str(bridge))
        result.append(words[i])
    return ''.join(result)",0,0,"def bridge_words(text: str) -> str:
    w = text.split()
    n = len(w)
    if n < 2:
        return """".join(w)
    
    res = [None] * (2 * n - 1)
    res[::2] = w
    res[1::2] = [str(len(w[i]) + len(w[i+1])) for i in range(n - 1)]
    
    return """".join(res)",0,0,"def bridge_words(text: str) -> str:
    n = len(text)
    i = 0
    while i < n and text[i].isspace():
        i += 1
    if i >= n:
        return """"
    j = i
    while j < n and not text[j].isspace():
        j += 1
    first = text[i:j]
    res = [first]
    prev_len = len(first)
    i = j
    while True:
        while i < n and text[i].isspace():
            i += 1
        if i >= n:
            break
        j = i
        while j < n and not text[j].isspace():
            j += 1
        w = text[i:j]
        res.append(str(prev_len + len(w)))
        res.append(w)
        prev_len = len(w)
        i = j
    return ''.join(res)",0,0,"['a', 'b', 'c']"
94,"
def interleave_batches(lst1: list, lst2: list, batch_size: int) -> list:
""""""
Given two lists and a positive integer batch_size, interleave elements by taking
batches of batch_size from each list alternatingly, starting with lst1.
If one list is exhausted, append the remaining elements of the other list.

>>> interleave_batches([1, 2, 3, 4, 5], [6, 7], 2)
[1, 2, 6, 7, 3, 4, 5]
>>> interleave_batches([1, 2], [3, 4, 5, 6], 1)
[1, 3, 2, 4, 5, 6]
>>> interleave_batches([], [1, 2, 3], 2)
[1, 2, 3]
>>> interleave_batches([10, 20], [30, 40], 5)
[10, 20, 30, 40]
""""""
","def interleave_batches(lst1: list, lst2: list, batch_size: int) -> list:
    result = []
    i1, i2 = 0, 0
    turn = 1
    while i1 < len(lst1) or i2 < len(lst2):
        if turn == 1:
            result.extend(lst1[i1:i1+batch_size])
            i1 += batch_size
            turn = 2
        else:
            result.extend(lst2[i2:i2+batch_size])
            i2 += batch_size
            turn = 1
        if i1 >= len(lst1) and i2 < len(lst2):
            result.extend(lst2[i2:])
            break
        if i2 >= len(lst2) and i1 < len(lst1):
            result.extend(lst1[i1:])
            break
    return result",0.0005914,27.51679688,"def interleave_batches(lst1: list, lst2: list, batch_size: int) -> list:
    result = []
    a, b = lst1, lst2
    while a:
        result.extend(a[:batch_size])
        a = a[batch_size:]
        a, b = b, a
    return result + b",0.0005569,27.51679688,"def interleave_batches(lst1: list, lst2: list, batch_size: int) -> list:
    chunks1 = [lst1[i:i+batch_size] for i in range(0, len(lst1), batch_size)]
    chunks2 = [lst2[i:i+batch_size] for i in range(0, len(lst2), batch_size)]
    result = []
    max_len = max(len(chunks1), len(chunks2))
    for k in range(max_len):
        if k < len(chunks1):
            result.extend(chunks1[k])
        if k < len(chunks2):
            result.extend(chunks2[k])
    return result",0.0005569,27.51679688,"['b', 'c', 'a']"
95,"
def weave_and_reverse(s1: str, s2: str) -> str:
""""""
Create a new string by interleaving characters from s1 and s2, starting with s1.
If the strings are of unequal length, the remaining substring of the longer
string must be reversed before being appended to the end.

Examples:
weave_and_reverse(""cat"", ""dog"") == ""cdaotg""
weave_and_reverse(""apple"", ""12"") == ""a1p2elp""
weave_and_reverse(""a"", ""bcde"") == ""abedc""
weave_and_reverse("""", ""hello"") == ""olleh""
""""""
pass
","def weave_and_reverse(s1: str, s2: str) -> str:
    result = []
    min_len = min(len(s1), len(s2))
    for i in range(min_len):
        result.append(s1[i])
        result.append(s2[i])
    if len(s1) > min_len:
        result.append(s1[min_len:][::-1])
    elif len(s2) > min_len:
        result.append(s2[min_len:][::-1])
    return ''.join(result)",0.0003891,26.12109375,"def weave_and_reverse(s1: str, s2: str) -> str:
    ans = """"
    while s1 and s2:
        ans += s1[0] + s2[0]
        s1 = s1[1:]
        s2 = s2[1:]
    return ans + (s1 + s2)[::-1]",0.0003658,26.12109375,"def weave_and_reverse(s1: str, s2: str) -> str:
    min_len = min(len(s1), len(s2))
    inter = ''.join(s1[i] + s2[i] for i in range(min_len))
    if len(s1) > min_len:
        return inter + s1[min_len:][::-1]
    elif len(s2) > min_len:
        return inter + s2[min_len:][::-1]
    else:
        return inter",0.0003658,26.12109375,"['b', 'a', 'c']"
96,"
def categorize_sort(items: list) -> dict:
""""""
Given a list of strings, return a dictionary with keys 'alpha' and 'numeric'.
- 'alpha' contains strings consisting only of letters, sorted alphabetically.
- 'numeric' contains strings consisting only of digits, sorted by their integer value.
Strings that are mixed or contain symbols should be ignored.

>>> categorize_sort(['apple', '10', '2', 'banana', 'a1'])
{'alpha': ['apple', 'banana'], 'numeric': ['2', '10']}
>>> categorize_sort(['100', '05', 'cat', 'ZEBRA'])
{'alpha': ['ZEBRA', 'cat'], 'numeric': ['05', '100']}
>>> categorize_sort(['mixed123', '..', ''])
{'alpha': [], 'numeric': []}
""""""
","def categorize_sort(items: list) -> dict:
    alpha = []
    numeric = []
    for item in items:
        if item and item.isalpha():
            alpha.append(item)
        elif item and item.isdigit():
            numeric.append(item)
    return {'alpha': sorted(alpha), 'numeric': sorted(numeric, key=int)}",0.0005178,26.85136719,"def categorize_sort(items: list) -> dict:
    alpha = list(filter(str.isalpha, items))
    numeric = list(filter(str.isdigit, items))
    alpha.sort()
    numeric.sort(key=int)
    return {'alpha': alpha, 'numeric': numeric}",0.0005129,26.85136719,"def categorize_sort(items: list) -> dict:
    alpha = []
    numeric = []
    for s in items:
        if s is None or len(s) == 0:
            continue
        if all(('A' <= c <= 'Z') or ('a' <= c <= 'z') for c in s):
            alpha.append(s)
        elif all('0' <= c <= '9' for c in s):
            numeric.append(s)
    alpha.sort()
    numeric.sort(key=lambda x: int(x))
    return {'alpha': alpha, 'numeric': numeric}",0.0005129,26.85136719,"['b', 'a', 'c']"
97,"
def conditional_prefix_sum(numbers: list, k: int) -> list:
""""""
Return a list where each element is the running sum of the input 'numbers'.
However, if the current running sum is a multiple of 'k', reset the running
accumulator to 0 for the calculation of the next element. The current running
sum is included in the output before the reset. k will always be > 0.

conditional_prefix_sum([1, 2, 3, 4], 3) == [1, 3, 3, 4]
conditional_prefix_sum([2, 4, 9, 1], 2) == [2, 4, 9, 10]
conditional_prefix_sum([5, 5, 5], 5) == [5, 5, 5]
conditional_prefix_sum([], 10) == []
""""""
","def conditional_prefix_sum(numbers: list, k: int) -> list:
    result = []
    acc = 0
    for n in numbers:
        acc += n
        result.append(acc)
        if acc % k == 0:
            acc = 0
    return result",0.0004596,26.90292969,"def conditional_prefix_sum(numbers: list, k: int) -> list:
    result = []
    for x in numbers:
        if result and result[-1] % k != 0:
            result.append(x + result[-1])
        else:
            result.append(x)
    return result",0.0004582,26.90292969,"def conditional_prefix_sum(numbers: list, k: int) -> list:
    def rec(i, acc):
        if i == len(numbers):
            return []
        acc += numbers[i]
        next_acc = 0 if acc % k == 0 else acc
        return [acc] + rec(i + 1, next_acc)
    return rec(0, 0)",0.0004582,26.90292969,"['b', 'a', 'c']"
98,"
from typing import List

def select_special_numbers(numbers: List[int]) -> List[int]:
""""""
From a given list of integers, filter and return a sorted list of numbers that satisfy
all of the following conditions:
1. The number is positive.
2. The number is even.
3. The sum of its digits is an odd integer.

Args:
numbers: A list of integers.

Returns:
A list of integers sorted in ascending order.

Examples:
select_special_numbers([12, 23, 34, 45, 56]) == [12, 34, 56]
select_special_numbers([-12, 2, 4, 10, 20]) == [10]
select_special_numbers([8, 18, 28, 38]) == [18, 38]
""""""
","from typing import List

def select_special_numbers(numbers: List[int]) -> List[int]:
    result = []
    for n in numbers:
        if n > 0 and n % 2 == 0:
            digit_sum = sum(int(d) for d in str(n))
            if digit_sum % 2 == 1:
                result.append(n)
    return sorted(result)",0.0010175,26.8046875,"from typing import List

def select_special_numbers(numbers: List[int]) -> List[int]:
    special = []
    for val in numbers:
        if val % 2 == 0 and val > 0:
            total = 0
            temp = val
            while temp:
                total += temp % 10
                temp //= 10
            if total % 2:
                special.append(val)
    special.sort()
    return special",0.0005529,26.8046875,"from typing import List

def select_special_numbers(numbers: List[int]) -> List[int]:
    def parity_of_digit_sum(n: int) -> int:
        if n == 0:
            return 0
        return ((n % 10) & 1) ^ parity_of_digit_sum(n // 10)
    result = []
    for n in numbers:
        if n > 0 and n % 2 == 0 and parity_of_digit_sum(n) == 1:
            result.append(n)
    return sorted(result)
",0.0005529,26.8046875,"['b', 'c', 'a']"
99,"
def sum_increasing_groups(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, partition the list into contiguous groups where each group
is strictly increasing. Return a list containing the sum of the numbers in each group.

>>> sum_increasing_groups([1, 2, 3, 1, 2, 5])
[6, 8]
>>> sum_increasing_groups([5, 4, 3, 2, 1])
[5, 4, 3, 2, 1]
>>> sum_increasing_groups([10, 20, 20, 30])
[30, 20, 30]
>>> sum_increasing_groups([])
[]
""""""
","def sum_increasing_groups(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    for i in range(1, len(numbers)):
        if numbers[i] > numbers[i-1]:
            current_sum += numbers[i]
        else:
            result.append(current_sum)
            current_sum = numbers[i]
    result.append(current_sum)
    return result",0.0004838,26.91757813,"def sum_increasing_groups(numbers: list[int]) -> list[int]:
    res = []
    i = 0
    n = len(numbers)
    while i < n:
        start = i
        i += 1
        while i < n and numbers[i] > numbers[i - 1]:
            i += 1
        res.append(sum(numbers[start:i]))
    return res",0.0004693,26.91757813,"def sum_increasing_groups(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    n = len(numbers)
    starts = [0]
    for i in range(1, n):
        if numbers[i] <= numbers[i-1]:
            starts.append(i)
    res = []
    for idx, s in enumerate(starts):
        end = starts[idx+1] if idx+1 < len(starts) else n
        res.append(sum(numbers[s:end]))
    return res",0.0004693,26.91757813,"['b', 'a', 'c']"
100,"
from typing import List

def sort_by_digit_sum(strings: List[str]) -> List[str]:
""""""
Filter the input list to keep only strings that contain at least one digit.
Sort the remaining strings in ascending order based on the sum of the digits
contained within each string. If two strings have the same digit sum,
sort them alphabetically.

>>> sort_by_digit_sum([""abc"", ""a1b2"", ""10"", ""5""])
['10', 'a1b2', '5']
>>> sort_by_digit_sum([""xy"", ""22"", ""13"", ""4""])
['13', '22', '4']
>>> sort_by_digit_sum([""no_digits"", ""1a"", ""b0""])
['b0', '1a']
>>> sort_by_digit_sum([])
[]
""""""
","from typing import List

def sort_by_digit_sum(strings: List[str]) -> List[str]:
    filtered = [s for s in strings if any(c.isdigit() for c in s)]
    def digit_sum(s):
        return sum(int(c) for c in s if c.isdigit())
    return sorted(filtered, key=lambda s: (digit_sum(s), s))",0.0005371,26.61035156,"from typing import List

def sort_by_digit_sum(strings: List[str]) -> List[str]:
    scored = []
    for text in strings:
        total = 0
        has_digit = False
        for char in text:
            if char.isdigit():
                total += int(char)
                has_digit = True
        if has_digit:
            scored.append((total, text))
    scored.sort()
    return [item[1] for item in scored]",0.0004773,26.61035156,"def sort_by_digit_sum(strings: List[str]) -> List[str]:
    import re
    digit_finder = re.compile(r""\d"")
    def digit_sum(s: str) -> int:
        total = 0
        for ch in s:
            if '0' <= ch <= '9':
                total += ord(ch) - 48
        return total
    filtered = [s for s in strings if digit_finder.search(s)]
    return sorted(filtered, key=lambda s: (digit_sum(s), s))",0.0004773,26.61035156,"['b', 'a', 'c']"
101,"
from typing import List, Dict

def group_words_by_frequency(words: List[str]) -> Dict[int, List[str]]:
""""""
Given a list of words, count the occurrences of each word and group the words by their frequency.
Return a dictionary where the keys are the frequency counts (integers) and the values are
lists of unique words that appear that many times, sorted alphabetically.

Examples:
group_words_by_frequency([""apple"", ""banana"", ""apple"", ""orange""]) == {1: [""banana"", ""orange""], 2: [""apple""]}
group_words_by_frequency([""a"", ""b"", ""c"", ""a"", ""b""]) == {1: [""c""], 2: [""a"", ""b""]}
group_words_by_frequency([]) == {}
group_words_by_frequency([""same"", ""same"", ""same""]) == {3: [""same""]}
""""""
","from typing import List, Dict

def group_words_by_frequency(words: List[str]) -> Dict[int, List[str]]:
    from collections import Counter
    counts = Counter(words)
    result = {}
    for word, freq in counts.items():
        if freq not in result:
            result[freq] = []
        result[freq].append(word)
    for freq in result:
        result[freq].sort()
    return result",0.0005828,27.35332031,"from typing import List, Dict

def group_words_by_frequency(words: List[str]) -> Dict[int, List[str]]:
    unique_words = sorted(set(words))
    word_to_freq = {word: words.count(word) for word in unique_words}
    freq_list = sorted(set(word_to_freq.values()))
    return {f: [w for w in unique_words if word_to_freq[w] == f] for f in freq_list}",0.0005725,27.35332031,"def group_words_by_frequency(words):
    if not words:
        return {}
    sorted_words = sorted(words)
    freq_map = {}
    i = 0
    n = len(sorted_words)
    while i < n:
        w = sorted_words[i]
        count = 1
        i += 1
        while i < n and sorted_words[i] == w:
            count += 1
            i += 1
        freq_map.setdefault(count, []).append(w)
    return freq_map",0.0005725,27.35332031,"['c', 'b', 'a']"
102,"
def get_special_string_sum(strings: list[str]) -> int:
""""""
You are given a list of strings. Calculate the sum of the lengths of
strings that satisfy two conditions:
1. The string starts with a vowel ('a', 'e', 'i', 'o', 'u'), case-insensitive.
2. The string contains at least one numeric digit ('0'-'9').

Return 0 if no string matches these conditions.

Examples:
get_special_string_sum([""Apple1"", ""banana"", ""azure"", ""E8""]) == 8
get_special_string_sum([""1st"", ""order"", ""unit""]) == 0
get_special_string_sum([""a1"", ""e2"", ""i3"", ""o4"", ""u5""]) == 10
get_special_string_sum([]) == 0
""""""
pass
","def get_special_string_sum(strings: list[str]) -> int:
    vowels = set('aeiouAEIOU')
    total = 0
    for s in strings:
        if s and s[0] in vowels and any(c.isdigit() for c in s):
            total += len(s)
    return total",0.0004984,26.71425781,"def get_special_string_sum(strings: list[str]) -> int:
    matches = []
    vowels = ('a', 'e', 'i', 'o', 'u')
    for word in strings:
        if word.lower().startswith(vowels):
            for char in word:
                if char.isdigit():
                    matches.append(len(word))
                    break
    return sum(matches)",0.0005199,26.71425781,"def get_special_string_sum(strings: list[str]) -> int:
    import re
    pat = re.compile(r'^[aeiouAEIOU].*\d')
    return sum(len(s) for s in strings if pat.match(s))
",0.0005199,26.71425781,"['a', 'b', 'c']"
103,"
def sum_unique_divisibles(numbers: list, k: int) -> int:
""""""
Given a list of integers and an integer k, return the sum of all elements
in the list that satisfy two conditions:
1. The element appears exactly once in the list.
2. The element is divisible by k.

If no elements satisfy these conditions, return 0.

Examples:
sum_unique_divisibles([4, 4, 8, 12], 4) == 20
sum_unique_divisibles([1, 2, 3, 5], 2) == 2
sum_unique_divisibles([6, 6, 6], 3) == 0
sum_unique_divisibles([1, 3, 5], 2) == 0
""""""
pass
","def sum_unique_divisibles(numbers: list, k: int) -> int:
    from collections import Counter
    counts = Counter(numbers)
    return sum(n for n in numbers if counts[n] == 1 and n % k == 0)",0.001185,27.18632813,"def sum_unique_divisibles(numbers: list, k: int) -> int:
    once = set()
    multiple = set()
    for x in numbers:
        if x in multiple:
            continue
        if x in once:
            once.remove(x)
            multiple.add(x)
        else:
            once.add(x)
    total = 0
    for x in once:
        if x % k == 0:
            total += x
    return total",0.0005683,27.18632813,"def sum_unique_divisibles(numbers: list, k: int) -> int:
    total = 0
    if k == 0:
        return 0
    for x in numbers:
        if numbers.count(x) == 1 and x % k == 0:
            total += x
    return total",0.0005683,27.18632813,"['b', 'c', 'a']"
104,"
def priority_shuffle(numbers: list[int]) -> list[int]:
""""""
Separate the input list into two groups: even numbers and odd numbers.
Interleave these two groups to form a new list, starting with the group that has the larger sum.
If the sums are equal, start with the even group.

The interleaving process takes one element from the starting group, then one from the other,
repeating until one group is exhausted. Any remaining elements from the longer group are
appended to the end. The relative order of elements within the even and odd groups must
be preserved.

Examples:
priority_shuffle([1, 2, 3, 4]) -> [2, 1, 4, 3]
# Evens: [2, 4] (sum 6), Odds: [1, 3] (sum 4). Evens start.

priority_shuffle([10, 2, 3]) -> [10, 3, 2]
# Evens: [10, 2] (sum 12), Odds: [3] (sum 3). Evens start.

priority_shuffle([5, 7, 2]) -> [5, 2, 7]
# Evens: [2] (sum 2), Odds: [5, 7] (sum 12). Odds start.
""""""
pass
","def priority_shuffle(numbers: list[int]) -> list[int]:
    evens = [n for n in numbers if n % 2 == 0]
    odds = [n for n in numbers if n % 2 == 1]
    even_sum = sum(evens)
    odd_sum = sum(odds)
    if odd_sum > even_sum:
        first, second = odds, evens
    else:
        first, second = evens, odds
    result = []
    for i in range(max(len(first), len(second))):
        if i < len(first):
            result.append(first[i])
        if i < len(second):
            result.append(second[i])
    return result",0.0004416,26.42070313,"def priority_shuffle(numbers: list[int]) -> list[int]:
    evens = [n for n in numbers if n % 2 == 0]
    odds = [n for n in numbers if n % 2 != 0]

    if sum(evens) >= sum(odds):
        p_iter, s_iter = iter(evens), iter(odds)
    else:
        p_iter, s_iter = iter(odds), iter(evens)

    res = []
    for x in p_iter:
        res.append(x)
        try:
            res.append(next(s_iter))
        except StopIteration:
            res.extend(p_iter)
            break
    res.extend(s_iter)
    return res",0.0004626,26.42070313,"def priority_shuffle(numbers: list[int]) -> list[int]:
    from collections import deque
    evens = deque(n for n in numbers if n % 2 == 0)
    odds = deque(n for n in numbers if n % 2 != 0)
    sum_e = sum(evens)
    sum_o = sum(odds)
    if sum_e >= sum_o:
        first, second = evens, odds
    else:
        first, second = odds, evens
    res = []
    while first and second:
        res.append(first.popleft())
        res.append(second.popleft())
    if first:
        res.extend(list(first))
    if second:
        res.extend(list(second))
    return res",0.0004626,26.42070313,"['a', 'b', 'c']"
105,"
def dominant_char_span(s: str) -> str:
""""""
Given a string s, identify the character with the highest frequency.
If multiple characters share the highest frequency, pick the one that is alphabetically first.
Return the substring of s that spans from the first occurrence to the last occurrence
of that character (inclusive). Return an empty string if s is empty.

>>> dominant_char_span(""banana"")
'anana'
>>> dominant_char_span(""azaz"")
'aza'
>>> dominant_char_span(""hello"")
'll'
>>> dominant_char_span("""")
''
""""""
","def dominant_char_span(s: str) -> str:
    if not s:
        return """"
    from collections import Counter
    counts = Counter(s)
    max_freq = max(counts.values())
    candidates = [c for c in counts if counts[c] == max_freq]
    dominant = min(candidates)
    first = s.index(dominant)
    last = s.rindex(dominant)
    return s[first:last+1]",0.0005094,25.99316406,"def dominant_char_span(s: str) -> str:
    if not s:
        return """"
    idx_map = {}
    for i, char in enumerate(s):
        if char not in idx_map:
            idx_map[char] = []
        idx_map[char].append(i)
    best = min(idx_map, key=lambda c: (-len(idx_map[c]), c))
    indices = idx_map[best]
    return s[indices[0]:indices[-1]+1]",0.0004673,25.99316406,"def dominant_char_span(s: str) -> str:
    if not s:
        return """"
    freq = [0] * 256
    nonascii = {}
    for ch in s:
        o = ord(ch)
        if o < 256:
            freq[o] += 1
        else:
            nonascii[ch] = nonascii.get(ch, 0) + 1
    candidates = []
    for code in range(256):
        f = freq[code]
        if f:
            candidates.append((chr(code), f))
    for ch, f in nonascii.items():
        candidates.append((ch, f))
    max_freq = max(f for _, f in candidates)
    dominant = min(ch for ch, f in candidates if f == max_freq)
    first = s.find(dominant)
    last = s.rfind(dominant)
    return s[first:last+1]",0.0004673,25.99316406,"['b', 'a', 'c']"
106,"
def max_prefix_score(text: str) -> int:
""""""
Given a string `text`, calculate the score for every non-empty prefix of the string.
The score of a prefix is calculated as the count of uppercase letters minus the count of lowercase letters.
Return the maximum score found among all non-empty prefixes.
If the input string is empty, return 0.

Non-alphabetic characters do not affect the count but are part of the prefix structure.

max_prefix_score(""AbCd"") == 1
max_prefix_score(""hello"") == -1
max_prefix_score(""KeY"") == 1
max_prefix_score(""UPPER"") == 5
""""""
pass
","def max_prefix_score(text: str) -> int:
    if not text:
        return 0
    max_score = float('-inf')
    score = 0
    for c in text:
        if c.isupper():
            score += 1
        elif c.islower():
            score -= 1
        max_score = max(max_score, score)
    return max_score",0.0003761,25.99316406,"from itertools import accumulate

def max_prefix_score(text: str) -> int:
    if not text:
        return 0
    
    scores = accumulate(c.isupper() - c.islower() for c in text)
    return max(scores)",0.0003475,25.99316406,"def max_prefix_score(text: str) -> int:
    if not text:
        return 0
    deltas = []
    for ch in text:
        if 'A' <= ch <= 'Z':
            deltas.append(1)
        elif 'a' <= ch <= 'z':
            deltas.append(-1)
        else:
            deltas.append(0)

    def solve(l: int, r: int):
        if l + 1 == r:
            total = deltas[l]
            return total, deltas[l]
        m = (l + r) // 2
        total_left, max_left = solve(l, m)
        total_right, max_right = solve(m, r)
        total = total_left + total_right
        max_pref = max(max_left, total_left + max_right)
        return total, max_pref

    _, ans = solve(0, len(deltas))
    return ans",0.0003475,25.99316406,"['b', 'c', 'a']"
107,"
def sum_valleys(numbers: list[int]) -> int:
""""""
Return the sum of all 'valley' elements in the list.
A 'valley' is defined as an element that is strictly smaller than both its
immediate left and right neighbors.

The first and last elements of the list are excluded from consideration
as they do not have two neighbors. Returns 0 if no valleys exist.

Examples:
sum_valleys([1, 5, 2, 8, 3]) == 2
sum_valleys([10, 2, 10, 1, 10]) == 3
sum_valleys([5, 5, 5, 5]) == 0
sum_valleys([1, 2, 3, 4]) == 0
""""""
","def sum_valleys(numbers: list[int]) -> int:
    total = 0
    for i in range(1, len(numbers) - 1):
        if numbers[i] < numbers[i-1] and numbers[i] < numbers[i+1]:
            total += numbers[i]
    return total",0.0004595,26.8171875,"def sum_valleys(numbers: list[int]) -> int:
    result = 0
    for a, b, c in zip(numbers, numbers[1:], numbers[2:]):
        if b < a and b < c:
            result += b
    return result",0.0004648,26.8171875,"def sum_valleys(numbers: list[int]) -> int:
    if len(numbers) < 3:
        return 0
    diffs = [numbers[i+1] - numbers[i] for i in range(len(numbers) - 1)]
    total = 0
    for i in range(1, len(diffs)):
        if diffs[i-1] < 0 and diffs[i] > 0:
            total += numbers[i]
    return total",0.0004648,26.8171875,"['a', 'b', 'c']"
108,"
def interleave_and_tail(l1: list, l2: list) -> list:
""""""
Interleave elements from two lists `l1` and `l2` sequentially into a new list.
If one list is longer than the other, the remaining elements of the longer list
should be appended to the end of the new list in reverse order.

>>> interleave_and_tail([1, 2, 3], ['a', 'b', 'c'])
[1, 'a', 2, 'b', 3, 'c']
>>> interleave_and_tail([1, 2, 3, 4, 5], ['a', 'b'])
[1, 'a', 2, 'b', 5, 4, 3]
>>> interleave_and_tail([], [10, 20, 30])
[30, 20, 10]
""""""
pass
","def interleave_and_tail(l1: list, l2: list) -> list:
    result = []
    min_len = min(len(l1), len(l2))
    for i in range(min_len):
        result.append(l1[i])
        result.append(l2[i])
    if len(l1) > min_len:
        result.extend(l1[min_len:][::-1])
    elif len(l2) > min_len:
        result.extend(l2[min_len:][::-1])
    return result",0.000666,26.81660156,"def interleave_and_tail(l1: list, l2: list) -> list:
    combined = []
    idx = 0
    while idx < len(l1) and idx < len(l2):
        combined.append(l1[idx])
        combined.append(l2[idx])
        idx += 1
    leftover = l1[idx:] if idx < len(l1) else l2[idx:]
    while leftover:
        combined.append(leftover.pop())
    return combined",0.0005309,26.81660156,"def interleave_and_tail(l1: list, l2: list) -> list:
    min_len = min(len(l1), len(l2))
    result = [item for i in range(min_len) for item in (l1[i], l2[i])]
    if len(l1) > min_len:
        result.extend(l1[min_len:][::-1])
    elif len(l2) > min_len:
        result.extend(l2[min_len:][::-1])
    return result",0.0005309,26.81660156,"['b', 'c', 'a']"
109,"
def interleave_letters(s1: str, s2: str) -> str:
""""""
Given two strings s1 and s2, create a new string by interleaving their non-digit characters.
Start with the first non-digit character of s1, then the first non-digit of s2,
then the second of s1, and so on.

If one string runs out of non-digit characters before the other,
append the remaining non-digit characters of the longer one to the end.

Examples:
interleave_letters(""a1b"", ""c2d"") == ""acbd""
interleave_letters(""123"", ""abc"") == ""abc""
interleave_letters(""x"", ""y1z"") == ""xyz""
interleave_letters(""a&b"", ""1"") == ""a&b""
""""""
# Filter out digits from both strings
f1 = [c for c in s1 if not c.isdigit()]
f2 = [c for c in s2 if not c.isdigit()]

result = []
min_len = min(len(f1), len(f2))

# Interleave the common length
for i in range(min_len):
result.append(f1[i])
result.append(f2[i])

# Append the remainder
result.extend(f1[min_len:])
result.extend(f2[min_len:])

return """".join(result)
","def interleave_letters(s1: str, s2: str) -> str:
    f1 = [c for c in s1 if not c.isdigit()]
    f2 = [c for c in s2 if not c.isdigit()]
    result = []
    min_len = min(len(f1), len(f2))
    for i in range(min_len):
        result.append(f1[i])
        result.append(f2[i])
    result.extend(f1[min_len:])
    result.extend(f2[min_len:])
    return ''.join(result)",0.0004511,26.12832031,"def interleave_letters(s1: str, s2: str) -> str:
    c1 = [c for c in s1 if not c.isdigit()]
    c2 = [c for c in s2 if not c.isdigit()]
    L1, L2 = len(c1), len(c2)
    res = []
    for i in range(max(L1, L2)):
        if i < L1:
            res.append(c1[i])
        if i < L2:
            res.append(c2[i])
    return """".join(res)",0.0004509,26.12832031,"def interleave_letters(s1: str, s2: str) -> str:
    def non_digits(s):
        for ch in s:
            if not ch.isdigit():
                yield ch
    it1 = non_digits(s1)
    it2 = non_digits(s2)
    res = []
    ended1 = False
    ended2 = False
    while not (ended1 and ended2):
        if not ended1:
            try:
                c1 = next(it1)
            except StopIteration:
                ended1 = True
                c1 = None
        else:
            c1 = None
        if not ended2:
            try:
                c2 = next(it2)
            except StopIteration:
                ended2 = True
                c2 = None
        else:
            c2 = None
        if c1 is None and c2 is None:
            break
        if c1 is not None:
            res.append(c1)
        if c2 is not None:
            res.append(c2)
    return ''.join(res)
",0.0004509,26.12832031,"['b', 'a', 'c']"
110,"
def sort_evens_conditionally(nums):
""""""
Given a list of integers, return a list containing only the even numbers from the input.
The order of the returned even numbers depends on the composition of the original list:
- If the count of even numbers is strictly less than the count of odd numbers in the original list,
sort the evens in ascending order.
- Otherwise (if evens are equal to or more numerous than odds), sort the evens in descending order.

Examples:
sort_evens_conditionally([1, 2, 3, 4]) -> [4, 2]
sort_evens_conditionally([1, 3, 5, 2]) -> [2]
sort_evens_conditionally([10, 20, 30]) -> [30, 20, 10]
sort_evens_conditionally([]) -> []
""""""
","def sort_evens_conditionally(nums):
    evens = [n for n in nums if n % 2 == 0]
    odds = [n for n in nums if n % 2 == 1]
    if len(evens) < len(odds):
        return sorted(evens)
    return sorted(evens, reverse=True)",0.0004503,26.46953125,"def sort_evens_conditionally(nums):
    evens_list = []
    odds_total = 0
    for x in nums:
        if x % 2 == 0:
            evens_list.append(x)
        else:
            odds_total += 1
    evens_list.sort(reverse=len(evens_list) >= odds_total)
    return evens_list",0.0004669,26.46953125,"def sort_evens_conditionally(nums):
    evens = [n for n in nums if n % 2 == 0]
    odds_count = len(nums) - len(evens)
    reverse = len(evens) >= odds_count
    key = (lambda x: -x) if reverse else (lambda x: x)
    return sorted(evens, key=key)
",0.0004669,26.46953125,"['c', 'a', 'b']"
111,"
def cyclic_index_shift(text: str) -> str:
""""""
Encrypt a string by shifting every alphabet character by its index (0-based) in the string.
The shift is cyclic (wrapping around 'z' to 'a') and preserves the case of the original character.
Non-alphabetical characters remain unchanged.

Examples:
cyclic_index_shift(""abc"") == ""ace""
cyclic_index_shift(""Hello"") == ""Hfnos""
cyclic_index_shift(""xyz"") == ""xzb""
cyclic_index_shift(""a 1 z"") == ""a 1 d""
""""""
","def cyclic_index_shift(text: str) -> str:
    result = []
    for i, c in enumerate(text):
        if c.isalpha():
            base = ord('A') if c.isupper() else ord('a')
            shifted = chr((ord(c) - base + i) % 26 + base)
            result.append(shifted)
        else:
            result.append(c)
    return ''.join(result)",0.0003556,26.00058594,"def cyclic_index_shift(text: str) -> str:
    lower_alphabet = ""abcdefghijklmnopqrstuvwxyz""
    upper_alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    result = """"
    for i in range(len(text)):
        char = text[i]
        if char in lower_alphabet:
            pos = lower_alphabet.index(char)
            result += lower_alphabet[(pos + i) % 26]
        elif char in upper_alphabet:
            pos = upper_alphabet.index(char)
            result += upper_alphabet[(pos + i) % 26]
        else:
            result += char
    return result",0.0003917,26.00058594,"def cyclic_index_shift(text: str) -> str:
    res = []
    for i, ch in enumerate(text):
        code = ord(ch)
        if 97 <= code <= 122:
            base = 97
            new = base + ((code - base) + i) % 26
            res.append(chr(new))
        elif 65 <= code <= 90:
            base = 65
            new = base + ((code - base) + i) % 26
            res.append(chr(new))
        else:
            res.append(ch)
    return ''.join(res)",0.0003917,26.00058594,"['a', 'c', 'b']"
112,"
def check_shifted_sort(nums: list[int]) -> bool:
""""""
Determine if the given list of unique integers is a circular shift of a strictly increasing sorted list.

A circular shift involves moving a prefix of the sorted list to the end (e.g., [1, 2, 3] -> [2, 3, 1]),
maintaining the relative order of elements. The function should return True if the list represents
such a shift (or is already sorted), and False otherwise.

Constraints:
- All elements in the input list are unique.

>>> check_shifted_sort([1, 2, 3, 4, 5])
True
>>> check_shifted_sort([3, 4, 5, 1, 2])
True
>>> check_shifted_sort([1, 3, 2])
False
>>> check_shifted_sort([2, 1, 5])
False
""""""
","def check_shifted_sort(nums: list[int]) -> bool:
    if not nums:
        return True
    n = len(nums)
    sorted_nums = sorted(nums)
    for i in range(n):
        if sorted_nums[i:] + sorted_nums[:i] == nums:
            return True
    return False",0.0004567,26.56015625,"def check_shifted_sort(nums: list[int]) -> bool:
    if not nums:
        return True
    pivot = nums.index(min(nums))
    restored = nums[pivot:] + nums[:pivot]
    for i in range(len(restored) - 1):
        if restored[i] > restored[i + 1]:
            return False
    return True",0.0004314,26.56015625,"def check_shifted_sort(nums: list[int]) -> bool:
    if not nums:
        return True
    breaks = 0
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            breaks += 1
            if breaks > 1:
                return False
    if breaks == 0:
        return True
    return nums[0] > nums[-1]",0.0004314,26.56015625,"['b', 'c', 'a']"
113,"
def select_spaced_elements(numbers: list, min_distance: int) -> list:
""""""
Given a sorted list of integers and a minimum distance, return a list starting
with the first element of the input, and then selecting subsequent elements such
that each selected element is at least `min_distance` greater than the
previously selected element.

The input list is guaranteed to be sorted in ascending order. If the input list
is empty, return an empty list.

select_spaced_elements([1, 2, 4, 8, 9], 3) == [1, 4, 8]
select_spaced_elements([1, 2, 3], 5) == [1]
select_spaced_elements([10, 20, 30], 5) == [10, 20, 30]
select_spaced_elements([], 2) == []
""""""
","def select_spaced_elements(numbers: list, min_distance: int) -> list:
    if not numbers:
        return []
    result = [numbers[0]]
    for n in numbers[1:]:
        if n >= result[-1] + min_distance:
            result.append(n)
    return result",0.0004585,26.89023438,"def select_spaced_elements(numbers: list, min_distance: int) -> list:
    if not numbers:
        return []
    result = []
    i = 0
    limit = len(numbers)
    while i < limit:
        current = numbers[i]
        result.append(current)
        i += 1
        while i < limit and numbers[i] < current + min_distance:
            i += 1
    return result",0.0004456,26.89023438,"def select_spaced_elements(numbers: list, min_distance: int) -> list:
    import bisect
    if not numbers:
        return []
    result = [numbers[0]]
    last = numbers[0]
    idx = 1
    target = last + min_distance
    while True:
        j = bisect.bisect_left(numbers, target, lo=idx)
        if j >= len(numbers):
            break
        result.append(numbers[j])
        last = numbers[j]
        idx = j + 1
        target = last + min_distance
    return result",0.0004456,26.89023438,"['b', 'c', 'a']"
114,"
def count_digit_substrings(s: str, k: int) -> int:
""""""
Given a string s and an integer k, return the number of contiguous substrings
of length k that contain at least one digit (0-9).

If k is less than 1 or greater than the length of s, return 0.

Examples:
count_digit_substrings(""ab12c"", 3) == 3
count_digit_substrings(""hello"", 2) == 0
count_digit_substrings(""a1b"", 2) == 2
count_digit_substrings(""123"", 5) == 0
""""""
","def count_digit_substrings(s: str, k: int) -> int:
    if k < 1 or k > len(s):
        return 0
    count = 0
    for i in range(len(s) - k + 1):
        if any(c.isdigit() for c in s[i:i+k]):
            count += 1
    return count",0.0004092,26.06953125,"def count_digit_substrings(s: str, k: int) -> int:
    if k < 1 or k > len(s):
        return 0
    total = len(s) - k + 1
    invalid = 0
    streak = 0
    for char in s:
        if char.isdigit():
            streak = 0
        else:
            streak += 1
            if streak >= k:
                invalid += 1
    return total - invalid",0.0020806,84.10722656,"def count_digit_substrings(s: str, k: int) -> int:
    if k < 1 or k > len(s):
        return 0
    total = len(s) - k + 1
    invalid = 0
    current = 0
    for ch in s:
        if ch.isdigit():
            if current > 0:
                if current >= k:
                    invalid += current - k + 1
                current = 0
        else:
            current += 1
    if current > 0 and current >= k:
        invalid += current - k + 1
    return total - invalid
",0.0020806,84.10722656,"['a', 'c', 'b']"
115,"
def rotate_vowels(text: str) -> str:
""""""
Given a string `text`, return a new string where all vowels are rotated to the right
by one position among the vowels' indices.

Vowels are defined as 'a', 'e', 'i', 'o', 'u' (case-insensitive).
Consonants, numbers, and other characters remain in their original positions.
If there are no vowels or only one vowel, the string remains unchanged.

Examples:
rotate_vowels(""apple"") == ""eppla""
rotate_vowels(""hello"") == ""holle""
rotate_vowels("" "") == "" ""
rotate_vowels(""aeiou"") == ""uaeio""
""""""
","def rotate_vowels(text: str) -> str:
    vowels = 'aeiouAEIOU'
    vowel_chars = [c for c in text if c in vowels]
    if len(vowel_chars) <= 1:
        return text
    rotated = [vowel_chars[-1]] + vowel_chars[:-1]
    result = []
    vi = 0
    for c in text:
        if c in vowels:
            result.append(rotated[vi])
            vi += 1
        else:
            result.append(c)
    return ''.join(result)",0.0005173,26.0046875,"def rotate_vowels(text: str) -> str:
    vowels = ""aeiouAEIOU""
    chars = list(text)
    last_vowel = None
    for i in range(len(chars) - 1, -1, -1):
        if chars[i] in vowels:
            last_vowel = chars[i]
            break
    if last_vowel is not None:
        for i in range(len(chars)):
            if chars[i] in vowels:
                chars[i], last_vowel = last_vowel, chars[i]
    return """".join(chars)",0.000416,26.0046875,"def rotate_vowels(text: str) -> str:
    vowels = set(""aeiouAEIOU"")
    indices = [i for i, ch in enumerate(text) if ch in vowels]
    if len(indices) <= 1:
        return text
    vowel_chars = [text[i] for i in indices]
    from collections import deque
    dq = deque(vowel_chars)
    dq.rotate(1)
    chars = list(text)
    for pos, ch in zip(indices, dq):
        chars[pos] = ch
    return ''.join(chars)",0.000416,26.0046875,"['c', 'b', 'a']"
116,"
def keep_strong_elements(numbers: list) -> list:
""""""
Given a list of integers, filter the list to retain only the ""strong"" elements.
An element is considered strong if it is strictly larger than the sum of its
adjacent neighbors.

Rules:
- For the first element (index 0), compare it only to the second element.
- For the last element, compare it only to the second-to-last element.
- For any internal element, compare it to the sum of its left and right neighbors.
- If the list has fewer than 2 elements, return the list as is.

Args:
numbers (list): A list of integers.

Returns:
list: A new list containing only the strong elements in their original order.

Examples:
keep_strong_elements([1, 5, 2]) == [5] # 5 > 1 + 2
keep_strong_elements([10, 2, 10]) == [10, 10] # 10 > 2, 2 < 20, 10 > 2
keep_strong_elements([1, 2, 3]) == [3] # 1 < 2, 2 < 4, 3 > 2
keep_strong_elements([5]) == [5]
""""""
pass
","def keep_strong_elements(numbers: list) -> list:
    if len(numbers) < 2:
        return numbers
    result = []
    for i, n in enumerate(numbers):
        if i == 0:
            if n > numbers[1]:
                result.append(n)
        elif i == len(numbers) - 1:
            if n > numbers[-2]:
                result.append(n)
        else:
            if n > numbers[i-1] + numbers[i+1]:
                result.append(n)
    return result",0.0004323,26.48925781,"def keep_strong_elements(numbers: list) -> list:
    if len(numbers) < 2:
        return numbers
    
    left_neighbors = [0] + numbers[:-1]
    right_neighbors = numbers[1:] + [0]
    
    return [n for n, l, r in zip(numbers, left_neighbors, right_neighbors) if n > l + r]",0.0004507,26.48925781,"def keep_strong_elements(numbers: list) -> list:
    if len(numbers) < 2:
        return numbers
    n = len(numbers)
    neighbor_sums = [0] * n
    for i in range(n):
        if i == 0:
            neighbor_sums[i] = numbers[1] if n > 1 else 0
        elif i == n - 1:
            neighbor_sums[i] = numbers[-2]
        else:
            neighbor_sums[i] = numbers[i - 1] + numbers[i + 1]
    result = []
    for i in range(n):
        if numbers[i] > neighbor_sums[i]:
            result.append(numbers[i])
    return result",0.0004507,26.48925781,"['a', 'c', 'b']"
117,"
def sort_by_digit_sum(numbers: list[int]) -> list[int]:
""""""
Takes a list of positive integers, filters out any numbers divisible by 3,
and returns the remaining numbers sorted primarily by the sum of their digits (ascending),
and secondarily by their numerical value (ascending).

Examples:
sort_by_digit_sum([10, 12, 23, 5, 9]) == [10, 5, 23]
# 12 and 9 are removed (divisible by 3).
# Remaining: 10 (sum 1), 23 (sum 5), 5 (sum 5).
# Sorted: 10 comes first. 5 and 23 tie on digit sum, so 5 comes before 23.

sort_by_digit_sum([3, 6, 9]) == []
sort_by_digit_sum([11, 20, 2]) == [2, 11, 20]
# All have digit sum 2. Sorted by value: 2, 11, 20.
""""""
pass
","def sort_by_digit_sum(numbers: list[int]) -> list[int]:
    def digit_sum(n):
        return sum(int(d) for d in str(n))
    filtered = [n for n in numbers if n % 3 != 0]
    return sorted(filtered, key=lambda n: (digit_sum(n), n))",0.0005494,26.76054688,"def sort_by_digit_sum(numbers: list[int]) -> list[int]:
    def get_digit_sum(n):
        s = 0
        while n:
            s += n % 10
            n //= 10
        return s

    filtered_list = list(filter(lambda x: x % 3 != 0, numbers))
    
    filtered_list.sort()
    filtered_list.sort(key=get_digit_sum)

    return filtered_list",0.000468,26.76054688,"def sort_by_digit_sum(numbers: list[int]) -> list[int]:
    filtered = [n for n in numbers if n % 3 != 0]
    buckets: dict[int, list[int]] = {}
    for n in filtered:
        s = 0
        m = n
        while m:
            s += m % 10
            m //= 10
        buckets.setdefault(s, []).append(n)
    result: list[int] = []
    for total in sorted(buckets.keys()):
        bucket = buckets[total]
        bucket.sort()
        result.extend(bucket)
    return result
",0.000468,26.76054688,"['b', 'c', 'a']"
118,"
def common_prefix_scores(strings: list[str]) -> list[int]:
""""""
Given a list of strings, return a list of integers where each integer represents
the length of the longest common prefix shared between the string at that index
and the very first string in the list.

The comparison is always strictly between the i-th string and the 0-th string.
If the list is empty, return an empty list.

Examples:
common_prefix_scores([""flow"", ""flower"", ""flag"", ""flame""]) == [4, 4, 2, 2]
common_prefix_scores([""apple"", ""apply"", ""ape"", ""banana""]) == [5, 4, 2, 0]
common_prefix_scores([""test"", ""testing"", ""team""]) == [4, 4, 2]
common_prefix_scores([""single""]) == [6]
""""""
pass
","def common_prefix_scores(strings: list[str]) -> list[int]:
    if not strings:
        return []
    first = strings[0]
    result = []
    for s in strings:
        common = 0
        for i in range(min(len(first), len(s))):
            if first[i] == s[i]:
                common += 1
            else:
                break
        result.append(common)
    return result",0.0004766,26.51621094,"def common_prefix_scores(strings: list[str]) -> list[int]:
    if not strings:
        return []
    
    base = strings[0]
    scores = []
    for s in strings:
        length = min(len(base), len(s))
        while length > 0 and s[:length] != base[:length]:
            length -= 1
        scores.append(length)
    return scores",0.0004587,26.51621094,"def common_prefix_scores(strings: list[str]) -> list[int]:
    if not strings:
        return []
    first = strings[0]
    import os
    return [len(os.path.commonprefix([first, s])) for s in strings]
",0.0004587,26.51621094,"['b', 'a', 'c']"
119,"
def count_divisible_adjacent_sums(numbers: list, k: int) -> int:
""""""
Given a list of integers and an integer k, count the number of adjacent
pairs of elements (numbers[i], numbers[i+1]) whose sum is divisible by k.

If the list has fewer than 2 elements, return 0.

Examples:
count_divisible_adjacent_sums([1, 2, 3, 4, 5], 3) -> 2 # (1+2)=3 and (4+5)=9 are divisible by 3
count_divisible_adjacent_sums([3, 3, 3], 3) -> 2 # (3+3)=6 and (3+3)=6
count_divisible_adjacent_sums([10, 20, 30], 7) -> 0
count_divisible_adjacent_sums([5], 5) -> 0
""""""
","def count_divisible_adjacent_sums(numbers: list, k: int) -> int:
    if len(numbers) < 2:
        return 0
    count = 0
    for i in range(len(numbers) - 1):
        if (numbers[i] + numbers[i+1]) % k == 0:
            count += 1
    return count",0.0004747,26.78300781,"def count_divisible_adjacent_sums(numbers: list, k: int) -> int:
    if len(numbers) < 2:
        return 0
        
    count = 0
    items = iter(numbers)
    last = next(items)
    
    for current in items:
        if (last + current) % k == 0:
            count += 1
        last = current
        
    return count",0.00045,26.78300781,"def count_divisible_adjacent_sums(numbers: list, k: int) -> int:
    return sum(1 for a, b in zip(numbers, numbers[1:]) if (a + b) % k == 0)
",0.0005037,26.78300781,"['b', 'a', 'c']"
120,"
def count_alphabet_pairs(s: str, target: int) -> int:
""""""
Given a string `s` consisting of lowercase English letters and an integer `target`,
return the count of adjacent character pairs in the string whose 1-based alphabet
values sum exactly to `target`.

The alphabet values are: a=1, b=2, ..., z=26.
Pairs are overlapping (e.g., in ""aba"", ""ab"" and ""ba"" are both checked).

>>> count_alphabet_pairs(""aba"", 3)
2
>>> count_alphabet_pairs(""az"", 27)
1
>>> count_alphabet_pairs(""hello"", 20)
1
>>> count_alphabet_pairs(""abc"", 100)
0
""""""
","def count_alphabet_pairs(s: str, target: int) -> int:
    count = 0
    for i in range(len(s) - 1):
        val1 = ord(s[i]) - ord('a') + 1
        val2 = ord(s[i+1]) - ord('a') + 1
        if val1 + val2 == target:
            count += 1
    return count",0.0004782,26.06914063,"def count_alphabet_pairs(s: str, target: int) -> int:
    scores = {c: i + 1 for i, c in enumerate(""abcdefghijklmnopqrstuvwxyz"")}
    count = 0
    for x, y in zip(s, s[1:]):
        if scores[x] + scores[y] == target:
            count += 1
    return count",0.0004089,26.06914063,"def count_alphabet_pairs(s: str, target: int) -> int:
    from itertools import tee
    nums = map(lambda c: ord(c) - 96, s)
    a, b = tee(nums)
    next(b, None)
    return sum(1 for x, y in zip(a, b) if x + y == target)
",0.0005707,26.06914063,"['b', 'a', 'c']"
121,"
def shift_vowels(s):
""""""
Given a string s, create a new string where every vowel (a, e, i, o, u, and their
uppercase variants) is replaced by the *next* vowel that appears in the string.
The last vowel in the string should be replaced by the first vowel found.
Non-vowel characters remain unchanged.

>>> shift_vowels(""apple"")
'eppla'

>>> shift_vowels(""Hello World"")
'Hollo Werld'

>>> shift_vowels(""xy z"")
'xy z'

>>> shift_vowels(""AaEi"")
'aEiA'
""""""
","def shift_vowels(s):
    vowels = 'aeiouAEIOU'
    vowel_chars = [c for c in s if c in vowels]
    if len(vowel_chars) <= 1:
        return s
    shifted = vowel_chars[1:] + [vowel_chars[0]]
    result = []
    vi = 0
    for c in s:
        if c in vowels:
            result.append(shifted[vi])
            vi += 1
        else:
            result.append(c)
    return ''.join(result)",0,0,"def shift_vowels(s):
    vowels = ""aeiouAEIOU""
    v_list = [c for c in s if c in vowels]
    if not v_list:
        return s
    
    result = []
    v_idx = 0
    for char in s:
        if char in vowels:
            v_idx += 1
            result.append(v_list[v_idx % len(v_list)])
        else:
            result.append(char)
    return """".join(result)",0,0,"def shift_vowels(s):
    vowels_set = set('aeiouAEIOU')
    positions = []
    vowels_seq = []
    for idx, ch in enumerate(s):
        if ch in vowels_set:
            positions.append(idx)
            vowels_seq.append(ch)
    if not vowels_seq or len(vowels_seq) == 1:
        return s
    next_vowels = vowels_seq[1:] + [vowels_seq[0]]
    repl = {pos: nv for pos, nv in zip(positions, next_vowels)}
    res_chars = []
    for i, ch in enumerate(s):
        res_chars.append(repl.get(i, ch))
    return ''.join(res_chars)",0,0,"['a', 'b', 'c']"
122,"
def encrypt_by_index(text: str) -> str:
""""""
Given a string `text`, return a new string where each alphabet character
is shifted forward in the alphabet by an amount equal to its index (0-indexed)
in the string.

The shift must be cyclic (e.g., 'z' shifted by 1 becomes 'a', 'Z' shifted by 1 becomes 'A').
Non-alphabet characters should remain unchanged, but they still count towards the index positions.
Case must be preserved.

>>> encrypt_by_index(""abc"")
'ace'
>>> encrypt_by_index(""Hello"")
'Hfnos'
>>> encrypt_by_index(""Z y"")
'Z a'
>>> encrypt_by_index(""123"")
'123'
""""""
pass
","def encrypt_by_index(text: str) -> str:
    result = []
    for i, c in enumerate(text):
        if c.isalpha():
            base = ord('A') if c.isupper() else ord('a')
            shifted = chr((ord(c) - base + i) % 26 + base)
            result.append(shifted)
        else:
            result.append(c)
    return ''.join(result)",0.0005025,25.99824219,"def encrypt_by_index(text: str) -> str:
    low = ""abcdefghijklmnopqrstuvwxyz""
    up = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    res = list(text)
    for i, char in enumerate(res):
        if char in low:
            res[i] = low[(low.index(char) + i) % 26]
        elif char in up:
            res[i] = up[(up.index(char) + i) % 26]
    return """".join(res)",0.0004483,25.99824219,"def encrypt_by_index(text: str) -> str:
    res = []
    for i in range(len(text)):
        c = text[i]
        code = ord(c)
        if 65 <= code <= 90:
            res.append(chr((code - 65 + i) % 26 + 65))
        elif 97 <= code <= 122:
            res.append(chr((code - 97 + i) % 26 + 97))
        else:
            res.append(c)
    return ''.join(res)
",0.000387,25.99824219,"['c', 'b', 'a']"
123,"
def total_adjacent_difference(text: str) -> int:
""""""
Given a string `text`, identify all substrings of contiguous digits and convert them into a
list of integers. Calculate the sum of the absolute differences between each consecutive pair
of numbers in this list.

If fewer than two numbers are found, return 0.

Examples:
total_adjacent_difference(""a10b5c20"") == 20
total_adjacent_difference(""100 200"") == 100
total_adjacent_difference(""1-2-3"") == 2
total_adjacent_difference(""xy10z"") == 0
""""""
","def total_adjacent_difference(text: str) -> int:
    import re
    numbers = [int(x) for x in re.findall(r'\d+', text)]
    if len(numbers) < 2:
        return 0
    return sum(abs(numbers[i] - numbers[i+1]) for i in range(len(numbers) - 1))",0.0006473,25.9984375,"def total_adjacent_difference(text: str) -> int:
    chars = []
    for c in text:
        if c.isdigit():
            chars.append(c)
        else:
            chars.append("" "")
    
    numbers = []
    for s in """".join(chars).split():
        numbers.append(int(s))
        
    if len(numbers) < 2:
        return 0
        
    total_diff = 0
    i = 0
    while i < len(numbers) - 1:
        diff = numbers[i+1] - numbers[i]
        total_diff += abs(diff)
        i += 1
        
    return total_diff",0.0003906,25.9984375,"def total_adjacent_difference(text: str) -> int:
    total = 0
    prev = None
    cur = 0
    in_num = False
    for ch in text:
        if '0' <= ch <= '9':
            d = ord(ch) - 48
            if not in_num:
                in_num = True
                cur = d
            else:
                cur = cur * 10 + d
        else:
            if in_num:
                if prev is not None:
                    total += abs(cur - prev)
                prev = cur
                in_num = False
                cur = 0
    if in_num:
        if prev is not None:
            total += abs(cur - prev)
    return total",0.0005449,25.9984375,"['b', 'c', 'a']"
124,"
def interleave_reverse_remainder(a: list, b: list) -> list:
""""""
Return a new list constructed by interleaving elements from list 'a' and list 'b' sequentially
(a[0], b[0], a[1], b[1], ...). If the lists are of unequal lengths, append the remaining
elements of the longer list to the result in reverse order.

Examples:
interleave_reverse_remainder([1, 2, 3], ['x', 'y', 'z']) == [1, 'x', 2, 'y', 3, 'z']
interleave_reverse_remainder([1, 2], [10, 20, 30, 40]) == [1, 10, 2, 20, 40, 30]
interleave_reverse_remainder([5, 6, 7, 8], [0]) == [5, 0, 8, 7, 6]
interleave_reverse_remainder([], [1, 2]) == [2, 1]
""""""
","def interleave_reverse_remainder(a: list, b: list) -> list:
    result = []
    min_len = min(len(a), len(b))
    for i in range(min_len):
        result.append(a[i])
        result.append(b[i])
    if len(a) > min_len:
        result.extend(a[min_len:][::-1])
    elif len(b) > min_len:
        result.extend(b[min_len:][::-1])
    return result",0.0010085,26.81933594,"def interleave_reverse_remainder(a: list, b: list) -> list:
    a_stack = a[::-1]
    b_stack = b[::-1]
    result = []
    while a_stack and b_stack:
        result.append(a_stack.pop())
        result.append(b_stack.pop())
    result.extend(a_stack)
    result.extend(b_stack)
    return result",0.0005258,26.81933594,"def interleave_reverse_remainder(a: list, b: list) -> list:
    res = []
    for x, y in zip(a, b):
        res.append(x)
        res.append(y)
    if len(a) > len(b):
        res.extend(reversed(a[len(b):]))
    elif len(b) > len(a):
        res.extend(reversed(b[len(a):]))
    return res",0.0006112,26.81933594,"['b', 'c', 'a']"
125,"
from typing import List

def nearest_vowel_distances(word: str) -> List[int]:
""""""
Given a string `word`, return a list of integers representing the minimum absolute distance
from each character's position to the nearest vowel in the string.

- Vowels are 'a', 'e', 'i', 'o', 'u' (case insensitive).
- If the character at index i is a vowel, the distance is 0.
- If the string contains no vowels, return an empty list.

Examples:
nearest_vowel_distances(""banana"") == [1, 0, 1, 0, 1, 0]
nearest_vowel_distances(""AbcE"") == [0, 1, 1, 0]
nearest_vowel_distances(""z"") == []
nearest_vowel_distances(""shoE"") == [2, 1, 0, 0]
""""""
","from typing import List

def nearest_vowel_distances(word: str) -> List[int]:
    vowels = set('aeiouAEIOU')
    vowel_positions = [i for i, c in enumerate(word) if c in vowels]
    if not vowel_positions:
        return []
    result = []
    for i in range(len(word)):
        min_dist = min(abs(i - pos) for pos in vowel_positions)
        result.append(min_dist)
    return result",0.0006396,25.99179688,"from typing import List

def nearest_vowel_distances(word: str) -> List[int]:
    vowels = 'aeiouAEIOU'
    v_idx = [i for i, char in enumerate(word) if char in vowels]
    if not v_idx:
        return []
    
    n = len(word)
    res = [-1] * n
    queue = []
    for i in v_idx:
        res[i] = 0
        queue.append(i)
        
    for curr in queue:
        for neighbor in (curr - 1, curr + 1):
            if 0 <= neighbor < n and res[neighbor] == -1:
                res[neighbor] = res[curr] + 1
                queue.append(neighbor)
                
    return res",0.000754,25.99179688,"def nearest_vowel_distances(word: str) -> list[int]:
    vowels = set('aeiouAEIOU')
    n = len(word)
    if all((c not in vowels) for c in word):
        return []
    dist = [10**9] * n
    last = -1
    for i, ch in enumerate(word):
        if ch in vowels:
            last = i
            dist[i] = 0
        else:
            if last != -1:
                dist[i] = i - last
    next_v = -1
    for i in range(n - 1, -1, -1):
        ch = word[i]
        if ch in vowels:
            next_v = i
            dist[i] = 0
        else:
            if next_v != -1:
                d = next_v - i
                if d < dist[i]:
                    dist[i] = d
    return dist",0.0005507,25.99179688,"['c', 'a', 'b']"
126,"
def flip_even_chunks(lst, k):
""""""
Given a list of integers and a positive integer k, split the list into chunks of size k.
Reverse every chunk that appears at an even index (0th, 2nd, 4th, ...).
Chunks at odd indices (1st, 3rd, ...) remain in their original order.
Return the flattened list after these operations.

If the list is empty, return an empty list.
If k is larger than the list length, the whole list is considered the 0th chunk.

Examples:
flip_even_chunks([1, 2, 3, 4, 5, 6], 2) == [2, 1, 3, 4, 6, 5]
flip_even_chunks([1, 2, 3, 4, 5], 3) == [3, 2, 1, 4, 5]
flip_even_chunks([10, 20, 30], 1) == [10, 20, 30]
flip_even_chunks([], 5) == []
""""""
","def flip_even_chunks(lst, k):
    if not lst:
        return []
    result = []
    chunks = [lst[i:i+k] for i in range(0, len(lst), k)]
    for idx, chunk in enumerate(chunks):
        if idx % 2 == 0:
            result.extend(chunk[::-1])
        else:
            result.extend(chunk)
    return result",0.0006834,26.90351563,"def flip_even_chunks(lst, k):
    res = []
    for i in range(0, len(lst), 2 * k):
        even_chunk = lst[i : i + k]
        res += even_chunk[::-1]
        odd_chunk = lst[i + k : i + 2 * k]
        res += odd_chunk
    return res",0.0006079,26.90351563,"def flip_even_chunks(lst, k):
    def helper(remaining, idx):
        if not remaining:
            return []
        chunk = remaining[:k]
        rest = remaining[k:]
        if idx % 2 == 0:
            return list(reversed(chunk)) + helper(rest, idx + 1)
        else:
            return chunk + helper(rest, idx + 1)
    return helper(lst, 0)",0.0008179,26.90351563,"['b', 'a', 'c']"
127,"
def sum_consecutive_parity(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, group consecutive elements that share the same parity
(both even or both odd) and return a new list where each group is replaced
by the sum of its elements.

>>> sum_consecutive_parity([1, 3, 2, 4, 6, 5])
[4, 12, 5]
>>> sum_consecutive_parity([1, 2, 3, 4])
[1, 2, 3, 4]
>>> sum_consecutive_parity([2, 4, 6, 8])
[20]
>>> sum_consecutive_parity([])
[]
""""""
","def sum_consecutive_parity(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0004509,26.77304688,"def sum_consecutive_parity(numbers: list[int]) -> list[int]:
    result = []
    i = 0
    while i < len(numbers):
        start = i
        parity = numbers[i] % 2
        while i < len(numbers) and numbers[i] % 2 == parity:
            i += 1
        result.append(sum(numbers[start:i]))
    return result",0.000455,26.77304688,"def sum_consecutive_parity(numbers: list[int]) -> list[int]:
    import itertools
    return [sum(group) for _, group in itertools.groupby(numbers, key=lambda x: x % 2)]",0.0004571,26.77304688,"['a', 'b', 'c']"
128,"
def cyclic_pattern_search(text: str, pattern: str) -> bool:
""""""
Check if any cyclic rotation of the `pattern` string exists as a substring within `text`.
A cyclic rotation is generated by moving the last character of the string to the front repeatedly.
The search is case-sensitive.

Examples:
cyclic_pattern_search(""whiteboard"", ""ardbo"") # True (""ardbo"" -> ""oardb"" -> ""board"", which is in ""whiteboard"")
cyclic_pattern_search(""programming"", ""gram"") # True (""gram"" is already in ""programming"")
cyclic_pattern_search(""hello world"", ""lorld"") # False
cyclic_pattern_search(""abc"", ""cab"") # True
""""""
","def cyclic_pattern_search(text: str, pattern: str) -> bool:
    if not pattern:
        return True
    for i in range(len(pattern)):
        rotation = pattern[i:] + pattern[:i]
        if rotation in text:
            return True
    return False",0.0003985,26.16289063,"def cyclic_pattern_search(text: str, pattern: str) -> bool:
    if not pattern:
        return True
    n, m = len(pattern), len(text)
    doubled_pattern = pattern + pattern
    for i in range(m - n + 1):
        substring = text[i:i + n]
        if substring in doubled_pattern:
            return True
    return False",0.0003886,26.16289063,"def cyclic_pattern_search(text: str, pattern: str) -> bool:
    if not pattern:
        return True
    n = len(pattern)
    m = len(text)
    if m < n:
        return False
    rotations = set()
    doubled = pattern + pattern
    for i in range(n):
        rotations.add(doubled[i:i+n])
    for i in range(m - n + 1):
        if text[i:i+n] in rotations:
            return True
    return False",0.0004138,26.16289063,"['b', 'a', 'c']"
129,"
def special_interleave(list1, list2):
""""""
Interleave elements from list1 and list2, taking one element from each in turn, starting with list1.
If one list is longer than the other, append the REVERSE of the remaining elements of the longer list
to the end of the interleaved result.

Examples:
special_interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3]
special_interleave([1, 2], [3, 4, 5, 6]) == [1, 3, 2, 4, 6, 5]
special_interleave([10, 20], []) == [20, 10]
""""""
","def special_interleave(list1, list2):
    result = []
    min_len = min(len(list1), len(list2))
    for i in range(min_len):
        result.append(list1[i])
        result.append(list2[i])
    if len(list1) > min_len:
        result.extend(list1[min_len:][::-1])
    elif len(list2) > min_len:
        result.extend(list2[min_len:][::-1])
    return result",0.0004669,26.78417969,"def special_interleave(list1, list2):
    result = []
    for x, y in zip(list1, list2):
        result.extend([x, y])
    remainder = list1[len(list2):] + list2[len(list1):]
    return result + remainder[::-1]",0.000469,26.78417969,"def special_interleave(list1, list2):
    it1 = iter(list1)
    it2 = iter(list2)
    res = []
    while True:
        try:
            x = next(it1)
        except StopIteration:
            break
        try:
            y = next(it2)
        except StopIteration:
            break
        res.append(x)
        res.append(y)
    min_len = min(len(list1), len(list2))
    if len(list1) > min_len:
        res.extend(list1[min_len:][::-1])
    elif len(list2) > min_len:
        res.extend(list2[min_len:][::-1])
    return res",0.0005592,26.78417969,"['a', 'b', 'c']"
130,"
def shuffle_evens(nums):
""""""
Given a list of integers, perform the following operations:
1. Filter the list to keep only the even numbers, maintaining their relative order.
2. Swap every pair of adjacent elements in the filtered list (index 0 with 1, 2 with 3, etc.).
3. If the filtered list has an odd length, the last element remains in its position.

Return the modified list.

>>> shuffle_evens([1, 2, 3, 4, 7, 8])
[4, 2, 8]
>>> shuffle_evens([2, 4, 6, 8])
[4, 2, 8, 6]
>>> shuffle_evens([1, 3, 5])
[]
>>> shuffle_evens([10, 20, 30])
[20, 10, 30]
""""""
","def shuffle_evens(nums):
    evens = [n for n in nums if n % 2 == 0]
    for i in range(0, len(evens) - 1, 2):
        evens[i], evens[i+1] = evens[i+1], evens[i]
    return evens",0.0007893,26.68710938,"def shuffle_evens(nums):
    evens = [n for n in nums if n % 2 == 0]
    res = []
    for first, second in zip(evens[1::2], evens[0::2]):
        res.extend([first, second])
    if len(evens) % 2:
        res.append(evens[-1])
    return res",0.0009251,26.68710938,"def shuffle_evens(nums):
    res = []
    pending = None
    for n in nums:
        if n % 2 == 0:
            if pending is None:
                pending = n
            else:
                res.append(n)
                res.append(pending)
                pending = None
    if pending is not None:
        res.append(pending)
    return res",0.0009616,26.68710938,"['a', 'b', 'c']"
131,"
def filter_existing_reverses(strings: list[str]) -> list[str]:
""""""
Given a list of strings, return a new list containing only the strings
for which their reversed counterpart is also present in the original list.
The result must preserve the original order of the input list.
Palindromes are included since their reverse (themselves) is in the list.

>>> filter_existing_reverses([""cat"", ""dog"", ""tac"", ""aba""])
['cat', 'tac', 'aba']
>>> filter_existing_reverses([""abc"", ""def""])
[]
>>> filter_existing_reverses([""level"", ""stats"", ""code""])
['level', 'stats']
>>> filter_existing_reverses([])
[]
""""""
","def filter_existing_reverses(strings: list[str]) -> list[str]:
    string_set = set(strings)
    return [s for s in strings if s[::-1] in string_set]",0.0009821,26.59648438,"def filter_existing_reverses(strings: list[str]) -> list[str]:
    mirrors = {item[::-1] for item in strings}
    return [item for item in strings if item in mirrors]",0.0004588,26.59648438,"def filter_existing_reverses(strings: list[str]) -> list[str]:
    result = []
    for s in strings:
        rev = s[::-1]
        found = False
        for t in strings:
            if t == rev:
                found = True
                break
        if found:
            result.append(s)
    return result
",0.0004596,26.59648438,"['b', 'c', 'a']"
132,"
def sum_consecutive_parity(nums):
""""""
Given a list of integers, sum consecutive elements that have the same parity (both even or both odd).
Return a new list containing these sums in their original order.

If the list is empty, return an empty list.

Examples:
sum_consecutive_parity([1, 3, 2, 4, 6, 5]) == [4, 12, 5]
sum_consecutive_parity([1, 2, 3, 4]) == [1, 2, 3, 4]
sum_consecutive_parity([10, 20, 30]) == [60]
sum_consecutive_parity([]) == []
""""""
","def sum_consecutive_parity(nums):
    if not nums:
        return []
    result = []
    current_sum = nums[0]
    current_parity = nums[0] % 2
    for n in nums[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0004605,26.77792969,"def sum_consecutive_parity(nums):
    result = []
    i = 0
    while i < len(nums):
        parity = nums[i] % 2
        total = 0
        while i < len(nums) and nums[i] % 2 == parity:
            total += nums[i]
            i += 1
        result.append(total)
    return result",0.0004425,26.77792969,"def sum_consecutive_parity(nums):
    from itertools import groupby
    return [sum(group) for _, group in groupby(nums, key=lambda x: x % 2)]",0.0004585,26.77792969,"['b', 'c', 'a']"
133,"
def reverse_even_chunks(s: str, k: int) -> str:
""""""
Given a string s and an integer k, split the string into substrings of length k.
Reverse the characters in every chunk located at an even index (0th, 2nd, 4th...).
Chunks at odd indices remain untouched. Return the joined string.
If k is greater than the length of s, treat it as a single chunk at index 0.

Examples:
reverse_even_chunks(""abcdefg"", 2) == ""bacdfeg""
reverse_even_chunks(""123456"", 3) == ""321456""
reverse_even_chunks(""Hello"", 1) == ""Hello""
reverse_even_chunks("" "", 10) == ""nohtyP""
""""""
pass
","def reverse_even_chunks(s: str, k: int) -> str:
    result = []
    chunks = [s[i:i+k] for i in range(0, len(s), k)]
    for idx, chunk in enumerate(chunks):
        if idx % 2 == 0:
            result.append(chunk[::-1])
        else:
            result.append(chunk)
    return ''.join(result)",0.0003943,26.06972656,"def reverse_even_chunks(s: str, k: int) -> str:
    if k <= 0:
        return s
    res = []
    for i in range(0, len(s), 2 * k):
        res.append(s[i:i+k][::-1])
        res.append(s[i+k:i+2*k])
    return """".join(res)",0.0003823,26.06972656,"def reverse_even_chunks(s: str, k: int) -> str:
    if k <= 0 or not s:
        return s
    lst = list(s)
    n = len(lst)
    for i in range(0, n, k):
        idx = i // k
        if idx % 2 == 0:
            start, end = i, min(i + k, n)
            l, r = start, end - 1
            while l < r:
                lst[l], lst[r] = lst[r], lst[l]
                l += 1
                r -= 1
    return ''.join(lst)",0.0003792,26.06972656,"['c', 'b', 'a']"
134,"
from typing import List

def smart_case_transform(words: List[str]) -> List[str]:
""""""
Given a list of strings, transform each string according to the following rules based on
the count of uppercase and lowercase letters (ignoring non-alphabetic characters):
1. If there are more lowercase letters than uppercase, convert the whole string to lowercase.
2. If there are more uppercase letters than lowercase, convert the whole string to uppercase.
3. If the counts are equal (or both zero), reverse the string preserving the original case.

Examples:
smart_case_transform([""madAM"", ""WORLD""]) == [""madam"", ""WORLD""]
smart_case_transform([""AbCd"", ""xyYZ""]) == [""dCbA"", ""ZYyx""]
smart_case_transform([""123"", """"]) == [""321"", """"]
""""""
pass
","from typing import List

def smart_case_transform(words: List[str]) -> List[str]:
    result = []
    for word in words:
        lower_count = sum(1 for c in word if c.islower())
        upper_count = sum(1 for c in word if c.isupper())
        if lower_count > upper_count:
            result.append(word.lower())
        elif upper_count > lower_count:
            result.append(word.upper())
        else:
            result.append(word[::-1])
    return result",0.0004573,26.65039063,"from typing import List

def smart_case_transform(words: List[str]) -> List[str]:
    def process_string(s):
        lowers = len(list(filter(str.islower, s)))
        uppers = len(list(filter(str.isupper, s)))
        if lowers > uppers:
            return s.lower()
        elif uppers > lowers:
            return s.upper()
        else:
            return s[::-1]

    return [process_string(word) for word in words]",0.0004818,26.65039063,"def smart_case_transform(words: List[str]) -> List[str]:
    result = []
    for s in words:
        lowers = 0
        uppers = 0
        for ch in s:
            if 'a' <= ch <= 'z':
                lowers += 1
            elif 'A' <= ch <= 'Z':
                uppers += 1
        if lowers > uppers:
            result.append(s.lower())
        elif uppers > lowers:
            result.append(s.upper())
        else:
            result.append(s[::-1])
    return result",0,0,"['a', 'b', 'c']"
135,"
def reverse_parity_subarrays(nums):
""""""
Given a list of integers, identify contiguous sub-segments of numbers that have the same parity
(all odd or all even). Reverse the elements within each of these sub-segments and return the
modified list.

Constraints:
- The input list can contain positive or negative integers.
- An empty list should return an empty list.

Examples:
reverse_parity_subarrays([1, 3, 5, 2, 4]) == [5, 3, 1, 4, 2]
reverse_parity_subarrays([10, 2, 3, 5, 7, 2]) == [2, 10, 7, 5, 3, 2]
reverse_parity_subarrays([1, 2, 3]) == [1, 2, 3]
reverse_parity_subarrays([]) == []
""""""
","def reverse_parity_subarrays(nums):
    if not nums:
        return []
    result = []
    i = 0
    while i < len(nums):
        parity = nums[i] % 2
        segment = [nums[i]]
        j = i + 1
        while j < len(nums) and nums[j] % 2 == parity:
            segment.append(nums[j])
            j += 1
        result.extend(segment[::-1])
        i = j
    return result",0.0005995,26.66855469,"from itertools import groupby

def reverse_parity_subarrays(nums):
    return [item for _, group in groupby(nums, lambda x: x % 2) for item in list(group)[::-1]]",0.0006696,26.66855469,"def reverse_parity_subarrays(nums):
    if not nums:
        return []
    result = []
    stack = []
    current_parity = nums[0] & 1
    stack.append(nums[0])
    for x in nums[1:]:
        if (x & 1) == current_parity:
            stack.append(x)
        else:
            while stack:
                result.append(stack.pop())
            current_parity = x & 1
            stack.append(x)
    while stack:
        result.append(stack.pop())
    return result",0.0004925,26.66855469,"['c', 'a', 'b']"
136,"
def prioritize_divisors(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, return a new list where elements are reordered and sorted based on the following priority rules:
1. Numbers divisible by 3 come first, sorted in ascending order.
2. Numbers not divisible by 3 but divisible by 2 come next, sorted in ascending order.
3. All remaining numbers come last, sorted in ascending order.

>>> prioritize_divisors([1, 2, 3, 4, 5, 6])
[3, 6, 2, 4, 1, 5]
>>> prioritize_divisors([10, 15, 7, 9, 4])
[9, 15, 4, 10, 7]
>>> prioritize_divisors([5, 7, 11])
[5, 7, 11]
""""""
","def prioritize_divisors(numbers: list[int]) -> list[int]:
    div3 = sorted([n for n in numbers if n % 3 == 0])
    div2_not3 = sorted([n for n in numbers if n % 3 != 0 and n % 2 == 0])
    rest = sorted([n for n in numbers if n % 3 != 0 and n % 2 != 0])
    return div3 + div2_not3 + rest",0.0006796,26.68925781,"def prioritize_divisors(numbers: list[int]) -> list[int]:
    def sort_key(n):
        if n % 3 == 0:
            return (0, n)
        elif n % 2 == 0:
            return (1, n)
        return (2, n)
    
    return sorted(numbers, key=sort_key)",0.0005245,26.68925781,"def prioritize_divisors(numbers: list[int]) -> list[int]:
    def category(n: int) -> int:
        if n % 3 == 0:
            return 0
        if n % 2 == 0:
            return 1
        return 2
    from functools import cmp_to_key
    def cmp(a: int, b: int) -> int:
        ca = category(a)
        cb = category(b)
        if ca != cb:
            return ca - cb
        return a - b
    return sorted(numbers, key=cmp_to_key(cmp))",0.0004862,26.68925781,"['c', 'b', 'a']"
137,"
def filter_decreasing(numbers: list) -> list:
""""""
Given a list of integers, return a new list containing only the elements that are
strictly smaller than all elements that appear before them in the input list.
The first element of the input (if it exists) is always included.

Constraints:
- The input list can contain positive or negative integers.
- If the list is empty, return an empty list.

>>> filter_decreasing([5, 3, 4, 1, 2])
[5, 3, 1]
>>> filter_decreasing([1, 2, 3])
[1]
>>> filter_decreasing([10, 10, 5])
[10, 5]
>>> filter_decreasing([-2, -5, -3])
[-2, -5]
>>> filter_decreasing([])
[]
""""""
","def filter_decreasing(numbers: list) -> list:
    if not numbers:
        return []
    result = [numbers[0]]
    current_min = numbers[0]
    for n in numbers[1:]:
        if n < current_min:
            result.append(n)
            current_min = n
    return result",0.0004402,26.67480469,"def filter_decreasing(numbers: list) -> list:
    result = []
    for i, x in enumerate(numbers):
        if i == 0 or x < result[-1]:
            result.append(x)
    return result",0.0004368,26.67480469,"def filter_decreasing(numbers: list) -> list:
    if not numbers:
        return []
    result = []
    for i, x in enumerate(numbers):
        if i == 0 or x < min(numbers[:i]):
            result.append(x)
    return result",0.0004529,26.67480469,"['b', 'a', 'c']"
138,"
def sum_sign_flip_diffs(numbers: list[int]) -> int:
""""""
Given a list of integers, calculate the sum of absolute differences between
adjacent elements that have different signs.

For this task, 0 is considered positive. A sign change occurs between two
adjacent numbers if one is non-negative (>= 0) and the other is negative (< 0).

Return 0 if the list contains fewer than 2 elements.

Examples:
sum_sign_flip_diffs([1, -2, 3, 4]) == 8
sum_sign_flip_diffs([1, 2, -3, -4]) == 5
sum_sign_flip_diffs([-10, 20, 30]) == 30
sum_sign_flip_diffs([0, -1]) == 1
""""""
","def sum_sign_flip_diffs(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    for i in range(len(numbers) - 1):
        a, b = numbers[i], numbers[i+1]
        if (a >= 0) != (b >= 0):
            total += abs(a - b)
    return total",0.0004145,26.4515625,"def sum_sign_flip_diffs(numbers: list[int]) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    items = iter(numbers)
    a = next(items)
    for b in items:
        if (a >= 0) ^ (b >= 0):
            total += abs(b - a)
        a = b
    return total",0.0004067,26.4515625,"def sum_sign_flip_diffs(numbers: list[int]) -> int:
    return sum(abs(a - b) for a, b in zip(numbers, numbers[1:]) if (a >= 0) != (b >= 0))",0.0004333,26.4515625,"['b', 'a', 'c']"
139,"
def count_consonant_groups(text: str) -> int:
""""""
Given a string `text`, return the number of contiguous groups of consonants.
A consonant group is a sequence of one or more consecutive consonant characters.

- Vowels are defined as 'a', 'e', 'i', 'o', 'u' (both uppercase and lowercase).
- All other distinct letters are considered consonants (including 'y').
- Non-alphabetic characters (numbers, punctuation, spaces) act as separators and break the continuity of a group.

>>> count_consonant_groups(""Hello World"")
4 # Groups are: 'H', 'll', 'W', 'rld'
>>> count_consonant_groups(""strength"")
2 # Groups are: 'str', 'ngth'
>>> count_consonant_groups(""123..abc.."")
1 # Group is: 'bc' ('a' is a vowel)
>>> count_consonant_groups(""aeiou"")
0
""""""
","def count_consonant_groups(text: str) -> int:
    vowels = set('aeiouAEIOU')
    count = 0
    in_group = False
    for c in text:
        if c.isalpha() and c not in vowels:
            if not in_group:
                count += 1
                in_group = True
        else:
            in_group = False
    return count",0.0003473,26.00136719,"def count_consonant_groups(text: str) -> int:
    vowels = 'aeiouAEIOU'
    normalized = ''.join(c if c.isalpha() and c not in vowels else ' ' for c in text)
    return len(normalized.split())",0.0003606,26.00136719,"def count_consonant_groups(text: str) -> int:
    import re
    return len(re.findall(r'[bcdfghjklmnpqrstvwxyz]+', text, flags=re.IGNORECASE))",0.0020725,48.50722656,"['a', 'b', 'c']"
140,"
def reverse_even_chunks(lst):
""""""
Given a list of integers, reverse the order of elements within every contiguous
sub-segment of even numbers. Odd numbers remain in their original positions.

Args:
lst (list): A list of integers.

Returns:
list: The modified list with contiguous even chunks reversed.

Examples:
reverse_even_chunks([1, 2, 4, 6, 3, 8, 5]) == [1, 6, 4, 2, 3, 8, 5]
reverse_even_chunks([2, 8, 4]) == [4, 8, 2]
reverse_even_chunks([1, 3, 5]) == [1, 3, 5]
reverse_even_chunks([10, 20, 3, 40, 50, 60]) == [20, 10, 3, 60, 50, 40]
""""""
","def reverse_even_chunks(lst):
    if not lst:
        return []
    result = []
    i = 0
    while i < len(lst):
        if lst[i] % 2 == 0:
            segment = []
            while i < len(lst) and lst[i] % 2 == 0:
                segment.append(lst[i])
                i += 1
            result.extend(segment[::-1])
        else:
            result.append(lst[i])
            i += 1
    return result",0.0005839,26.87363281,"from itertools import groupby

def reverse_even_chunks(lst):
    result = []
    for is_even, group in groupby(lst, key=lambda x: x % 2 == 0):
        items = list(group)
        if is_even:
            result.extend(items[::-1])
        else:
            result.extend(items)
    return result",0.0006611,26.87363281,"def reverse_even_chunks(lst):
    if not lst:
        return []
    def helper(i):
        if i >= len(lst):
            return []
        if lst[i] % 2 == 0:
            j = i
            while j < len(lst) and lst[j] % 2 == 0:
                j += 1
            return lst[i:j][::-1] + helper(j)
        else:
            return [lst[i]] + helper(i + 1)
    return helper(0)",0.0006114,26.87363281,"['a', 'c', 'b']"
141,"
def flip_and_swap(sentence: str) -> str:
""""""
Given a sentence string consisting of words separated by a single space, apply the following
transformation to each word based on its length:
1. If the word's length is odd, reverse the word.
2. If the word's length is even, swap the first half of the word with the second half.

Return the transformed sentence. The input will contain only English letters and spaces.

Examples:
flip_and_swap(""Code Logic"") == ""deCo cigoL""
flip_and_swap(""Hello world"") == ""olleH dlrow""
flip_and_swap(""A ab abc abcd"") == ""A ba cba cdab""
flip_and_swap("" "") == ""honPyt""
""""""
","def flip_and_swap(sentence: str) -> str:
    words = sentence.split(' ')
    result = []
    for word in words:
        if len(word) % 2 == 1:
            result.append(word[::-1])
        else:
            half = len(word) // 2
            result.append(word[half:] + word[:half])
    return ' '.join(result)",0.0004415,26.01875,"def flip_and_swap(sentence: str) -> str:
    result = """"
    word = """"
    for char in sentence + "" "":
        if char == "" "":
            n = len(word)
            if n % 2 != 0:
                result += word[::-1]
            else:
                mid = n // 2
                result += word[mid:] + word[:mid]
            result += "" ""
            word = """"
        else:
            word += char
    return result[:-1]",0.0006976,26.01875,"def flip_and_swap(sentence: str) -> str:
    words = sentence.split(' ')
    result = []
    for word in words:
        n = len(word)
        if n % 2 == 1:
            result.append(word[::-1])
        else:
            half = n // 2
            rebuilt = []
            for i in range(half):
                rebuilt.append(word[i + half])
            for i in range(half):
                rebuilt.append(word[i])
            result.append(''.join(rebuilt))
    return ' '.join(result)
",0.0004353,26.01875,"['c', 'a', 'b']"
142,"
from typing import List

def vowel_reverse_concat(strings: List[str]) -> str:
""""""
Concatenates a list of strings into a single result string.
If an individual string starts with a vowel (a, e, i, o, u), regardless of case,
reverse that string before adding it to the result. Otherwise, add it unchanged.

>>> vowel_reverse_concat(['Apple', 'banana', 'orange'])
'elppAbananaegnaro'
>>> vowel_reverse_concat(['Code', 'is', 'Art'])
'CodesitrA'
>>> vowel_reverse_concat(['hello', 'world'])
'helloworld'
>>> vowel_reverse_concat([])
''
""""""
","from typing import List

def vowel_reverse_concat(strings: List[str]) -> str:
    vowels = set('aeiouAEIOU')
    result = []
    for s in strings:
        if s and s[0] in vowels:
            result.append(s[::-1])
        else:
            result.append(s)
    return ''.join(result)",0.0004775,26.80273438,"from typing import List

def vowel_reverse_concat(strings: List[str]) -> str:
    return """".join(word[::-1] if word.lower().startswith(('a', 'e', 'i', 'o', 'u')) else word for word in strings)",0.0004839,26.80273438,"def vowel_reverse_concat(strings: List[str]) -> str:
    from functools import reduce
    vowels = set('aeiouAEIOU')
    return reduce(lambda acc, s: acc + (s[::-1] if s and s[0] in vowels else s), strings, """")",0,0,"['a', 'b', 'c']"
143,"
from typing import List

def local_max_smoothing(arr: List[int]) -> List[int]:
""""""
Create a new list where each element at index i is replaced by the maximum value
found among the element itself and its available immediate neighbors (index i-1 and i+1).

For the first element, consider itself and the next element.
For the last element, consider itself and the previous element.
If the list has 0 or 1 elements, return it unchanged.

>>> local_max_smoothing([1, 2, 3, 4])
[2, 3, 4, 4]
>>> local_max_smoothing([5, 1, 2, 8])
[5, 5, 8, 8]
>>> local_max_smoothing([10])
[10]
>>> local_max_smoothing([])
[]
""""""
","from typing import List

def local_max_smoothing(arr: List[int]) -> List[int]:
    if len(arr) <= 1:
        return arr
    result = []
    for i in range(len(arr)):
        if i == 0:
            result.append(max(arr[0], arr[1]))
        elif i == len(arr) - 1:
            result.append(max(arr[-2], arr[-1]))
        else:
            result.append(max(arr[i-1], arr[i], arr[i+1]))
    return result",0.0004089,26.3140625,"from typing import List

def local_max_smoothing(arr: List[int]) -> List[int]:
    if len(arr) <= 1:
        return arr[:]
    
    prev_vals = [arr[0]] + arr[:-1]
    next_vals = arr[1:] + [arr[-1]]
    
    return [max(p, c, n) for p, c, n in zip(prev_vals, arr, next_vals)]",0.0004332,26.3140625,"def local_max_smoothing(arr: List[int]) -> List[int]:
    if not arr:
        return []
    pad = [float('-inf')] + arr + [float('-inf')]
    return [max(pad[i:i+3]) for i in range(len(arr))]
",0,0,"['a', 'b', 'c']"
144,"
def transform_and_filter(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, process the list based on the following rules:
1. Discard any number that is divisible by 5.
2. For the remaining numbers:
- If the number is odd, multiply it by 2.
- If the number is even, divide it by 2 (integer division).
Return the new list with the transformed values maintaining the original relative order.

Examples:
transform_and_filter([1, 5, 4, 10]) == [2, 2]
transform_and_filter([3, 7, 25]) == [6, 14]
transform_and_filter([10, 20, 30]) == []
transform_and_filter([2, 6, 9]) == [1, 3, 18]
""""""
","def transform_and_filter(numbers: list[int]) -> list[int]:
    result = []
    for n in numbers:
        if n % 5 != 0:
            if n % 2 == 1:
                result.append(n * 2)
            else:
                result.append(n // 2)
    return result",0.0004282,26.45527344,"def transform_and_filter(numbers: list[int]) -> list[int]:
    return [val * 2 if val % 2 else val // 2 for val in numbers if val % 5]",0.0004072,26.45527344,"def transform_and_filter(numbers: list[int]) -> list[int]:
    filtered = filter(lambda n: n % 5 != 0, numbers)
    transformed = map(lambda n: n * 2 if n % 2 else n // 2, filtered)
    return list(transformed)
",0.0004262,26.45527344,"['b', 'c', 'a']"
145,"
def sum_bounded_by_parity(nums):
""""""
Given a list of integers, calculate the sum of elements that lie strictly between
the index of the first even number and the index of the last odd number.

If there are no even numbers, no odd numbers, or if the first even number
occurs after the last odd number, return 0. The boundary elements themselves
are not included in the sum.

Examples:
sum_bounded_by_parity([1, 2, 3, 4, 5]) == 7 # Sum of 3 and 4
sum_bounded_by_parity([2, 10, 5, 2]) == 10 # Sum of 10
sum_bounded_by_parity([1, 3, 5]) == 0 # No even numbers
sum_bounded_by_parity([2, 4, 6]) == 0 # No odd numbers
sum_bounded_by_parity([5, 4, 3, 2, 1]) == 3 # First even is 4, last odd is 1, sum of 3 and 2
""""""
first_even_idx = -1
last_odd_idx = -1

for i, x in enumerate(nums):
if x % 2 == 0:
first_even_idx = i
break

for i in range(len(nums) - 1, -1, -1):
if nums[i] % 2 != 0:
last_odd_idx = i
break

if first_even_idx == -1 or last_odd_idx == -1 or first_even_idx >= last_odd_idx:
return 0

return sum(nums[first_even_idx + 1 : last_odd_idx])
","def sum_bounded_by_parity(nums):
    first_even_idx = -1
    last_odd_idx = -1
    for i, x in enumerate(nums):
        if x % 2 == 0:
            first_even_idx = i
            break
    for i in range(len(nums) - 1, -1, -1):
        if nums[i] % 2 != 0:
            last_odd_idx = i
            break
    if first_even_idx == -1 or last_odd_idx == -1 or first_even_idx >= last_odd_idx:
        return 0
    return sum(nums[first_even_idx + 1 : last_odd_idx])",0.0004584,26.58085938,"def sum_bounded_by_parity(nums):
    even_indices = [i for i, x in enumerate(nums) if x % 2 == 0]
    odd_indices = [i for i, x in enumerate(nums) if x % 2 != 0]
    if not even_indices or not odd_indices:
        return 0
    start = even_indices[0]
    end = odd_indices[-1]
    if start >= end:
        return 0
    total = 0
    for i in range(start + 1, end):
        total += nums[i]
    return total",0.00045,26.58085938,"def sum_bounded_by_parity(nums):
    first_even_idx = -1
    last_odd_idx = -1
    for i, x in enumerate(nums):
        if first_even_idx == -1 and x % 2 == 0:
            first_even_idx = i
        if x % 2 != 0:
            last_odd_idx = i
    if first_even_idx == -1 or last_odd_idx == -1 or first_even_idx >= last_odd_idx:
        return 0
    return sum(nums[first_even_idx + 1:last_odd_idx])",0.0004325,26.58085938,"['c', 'b', 'a']"
146,"
def sum_consecutive_parity(numbers: list) -> int:
""""""
Given a list of integers, return the sum of all numbers that have the same parity
(odd or even) as the number located immediately before them in the list.
The first element is never added to the sum.

sum_consecutive_parity([1, 3, 2, 4, 6]) == 13
sum_consecutive_parity([8, 10, 12]) == 22
sum_consecutive_parity([1, 2, 3]) == 0
sum_consecutive_parity([5]) == 0
""""""
","def sum_consecutive_parity(numbers: list) -> int:
    if len(numbers) < 2:
        return 0
    total = 0
    for i in range(1, len(numbers)):
        if numbers[i] % 2 == numbers[i-1] % 2:
            total += numbers[i]
    return total",0.0004483,26.67382813,"def sum_consecutive_parity(numbers: list) -> int:
    total = 0
    for a, b in zip(numbers, numbers[1:]):
        if a % 2 == b % 2:
            total += b
    return total",0.000489,26.67382813,"def sum_consecutive_parity(numbers: list) -> int:
    total = 0
    i = 1
    n = len(numbers)
    while i < n:
        if (numbers[i] & 1) == (numbers[i - 1] & 1):
            total += numbers[i]
        i += 1
    return total",0.000467,26.67382813,"['a', 'c', 'b']"
147,"
def digit_sum_by_start(strings: list) -> dict:
""""""
Given a list of strings, return a dictionary where the keys are the starting
characters of the strings and the values are the sum of all individual digit
characters (0-9) found within those strings.

Rules:
- Only process strings that start with an alphabetic character (a-z, A-Z).
- Strings starting with numbers, symbols, or empty strings should be ignored.
- Group the sums by the starting character (case-sensitive).
- If a valid string contains no digits, its contribution to the sum is 0.

Examples:
digit_sum_by_start([""Apple12"", ""avocado"", ""A-5""])
# Returns {'A': 8, 'a': 0}
# Explanation: 'A': (1+2) + 5 = 8. 'a': 0 digits.

digit_sum_by_start([""12data"", ""data-base"", ""d3lta""])
# Returns {'d': 3}
# Explanation: ""12data"" starts with digit (ignored). ""data-base"" (0). ""d3lta"" (3).

digit_sum_by_start([])
# Returns {}
""""""
pass
","def digit_sum_by_start(strings: list) -> dict:
    result = {}
    for s in strings:
        if not s or not s[0].isalpha():
            continue
        start = s[0]
        digit_sum = sum(int(c) for c in s if c.isdigit())
        result[start] = result.get(start, 0) + digit_sum
    return result",0.0005539,26.61914063,"def digit_sum_by_start(strings: list) -> dict:
    results = {}
    for text in strings:
        if text[:1].isalpha():
            leader = text[0]
            if leader not in results:
                results[leader] = 0
            for char in text:
                if char in ""0123456789"":
                    results[leader] += int(char)
    return results",0.0004992,26.61914063,"def digit_sum_by_start(strings: list) -> dict:
    from collections import defaultdict
    sums = defaultdict(int)
    for s in strings:
        if not s or not s[0].isalpha():
            continue
        total = 0
        for ch in s:
            o = ord(ch)
            if 48 <= o <= 57:
                total += o - 48
        sums[s[0]] += total
    return dict(sums)
",0.0005482,26.61914063,"['b', 'c', 'a']"
148,"
from typing import List

def reorder_by_divisibility(numbers: List[int]) -> List[int]:
""""""
Return a reordered list of the input integers based on the following priority:
1. Numbers divisible by 3 (sorted ascending).
2. Numbers divisible by 2 but not 3 (sorted ascending).
3. All other numbers (sorted ascending).

Duplicates should be preserved and sorted within their respective groups.

Examples:
reorder_by_divisibility([1, 2, 3, 4, 5, 6, 9]) == [3, 6, 9, 2, 4, 1, 5]
reorder_by_divisibility([10, 20, 7, 5]) == [10, 20, 5, 7]
reorder_by_divisibility([5, 7, 11]) == [5, 7, 11]
reorder_by_divisibility([]) == []
""""""
","from typing import List

def reorder_by_divisibility(numbers: List[int]) -> List[int]:
    div3 = sorted([n for n in numbers if n % 3 == 0])
    div2_not3 = sorted([n for n in numbers if n % 3 != 0 and n % 2 == 0])
    rest = sorted([n for n in numbers if n % 3 != 0 and n % 2 != 0])
    return div3 + div2_not3 + rest",0.0005255,26.95234375,"from typing import List

def reorder_by_divisibility(numbers: List[int]) -> List[int]:
    three, two, rest = [], [], []
    for n in sorted(numbers):
        if n % 3 == 0:
            three.append(n)
        elif n % 2 == 0:
            two.append(n)
        else:
            rest.append(n)
    return three + two + rest",0.0005217,26.95234375,"def reorder_by_divisibility(numbers: 'List[int]') -> 'List[int]':
    return sorted(numbers, key=lambda n: (0 if n % 3 == 0 else 1 if n % 2 == 0 else 2, n))",0.0008199,26.95234375,"['b', 'a', 'c']"
149,"
from typing import List

def max_ascii_spread(strings: List[str]) -> str:
""""""
Given a list of non-empty strings, return the string which has the maximum difference
between the ASCII code of its largest character and the ASCII code of its smallest character.

If there are multiple strings with the same maximum difference, return the one that appears
first in the list.

>>> max_ascii_spread(['az', 'za', 'mm'])
'az'
>>> max_ascii_spread(['abc', 'cba'])
'abc'
>>> max_ascii_spread(['apple', 'pear'])
'pear'
>>> max_ascii_spread(['a', 'bb', 'ccc'])
'a'
""""""
","from typing import List

def max_ascii_spread(strings: List[str]) -> str:
    best = strings[0]
    best_spread = max(ord(c) for c in best) - min(ord(c) for c in best)
    for s in strings[1:]:
        spread = max(ord(c) for c in s) - min(ord(c) for c in s)
        if spread > best_spread:
            best_spread = spread
            best = s
    return best",0.0007939,26.69179688,"from typing import List

def max_ascii_spread(strings: List[str]) -> str:
    scores = []
    for s in strings:
        codes = [ord(c) for c in s]
        codes.sort()
        scores.append(codes[-1] - codes[0])
    
    target = max(scores)
    return strings[scores.index(target)]",0.0007322,26.69179688,"def max_ascii_spread(strings):
    return max(strings, key=lambda s: max(map(ord, s)) - min(map(ord, s)))",0.00048,26.69179688,"['c', 'b', 'a']"
150,"
from typing import List

def alternate_min_max(numbers: List[int]) -> List[int]:
""""""
Return a new list constructed by alternating the smallest and largest elements
from the input list of integers. Start with the absolute minimum, then the
absolute maximum, then the next minimum, and so on, until all elements are used.

The input list is not necessarily sorted.

Examples:
alternate_min_max([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
alternate_min_max([10, 20, 30, 40]) == [10, 40, 20, 30]
alternate_min_max([7]) == [7]
alternate_min_max([]) == []
""""""
","from typing import List

def alternate_min_max(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    sorted_nums = sorted(numbers)
    result = []
    left, right = 0, len(sorted_nums) - 1
    take_min = True
    while left <= right:
        if take_min:
            result.append(sorted_nums[left])
            left += 1
        else:
            result.append(sorted_nums[right])
            right -= 1
        take_min = not take_min
    return result",0.0005171,26.35605469,"from typing import List

def alternate_min_max(numbers: List[int]) -> List[int]:
    data = sorted(numbers)
    n = len(data)
    res = []
    for i in range(n):
        if i % 2 == 0:
            res.append(data[i // 2])
        else:
            res.append(data[n - 1 - i // 2])
    return res",0.0004202,26.35605469,"def alternate_min_max(numbers: List[int]) -> List[int]:
    from collections import Counter
    import heapq
    if not numbers:
        return []
    counts = Counter(numbers)
    min_heap = list(counts.keys())
    max_heap = [-k for k in counts.keys()]
    heapq.heapify(min_heap)
    heapq.heapify(max_heap)
    total = len(numbers)
    res = []
    take_min = True
    while total > 0:
        if take_min:
            while min_heap and counts[min_heap[0]] == 0:
                heapq.heappop(min_heap)
            if not min_heap:
                break
            v = heapq.heappop(min_heap)
            counts[v] -= 1
            total -= 1
            res.append(v)
            if counts[v] > 0:
                heapq.heappush(min_heap, v)
        else:
            while max_heap and counts[-max_heap[0]] == 0:
                heapq.heappop(max_heap)
            if not max_heap:
                break
            neg = heapq.heappop(max_heap)
            v = -neg
            counts[v] -= 1
            total -= 1
            res.append(v)
            if counts[v] > 0:
                heapq.heappush(max_heap, -v)
        take_min = not take_min
    return res
",0,0,"['b', 'a', 'c']"
151,"
def count_super_elements(lst: list) -> int:
""""""
Given a list of strings, return the count of strings at index i (where i > 0)
such that the string at lst[i] contains all unique characters present in lst[i-1].

The comparison is case-sensitive.

count_super_elements(['a', 'ab', 'abc']) == 2
count_super_elements(['abc', 'ab', 'b']) == 0
count_super_elements(['x', 'xy', 'xy', 'y']) == 2
count_super_elements([]) == 0
""""""
","def count_super_elements(lst: list) -> int:
    count = 0
    for i in range(1, len(lst)):
        prev_chars = set(lst[i-1])
        if prev_chars <= set(lst[i]):
            count += 1
    return count",0.0004736,26.53300781,"def count_super_elements(lst: list) -> int:
    count = 0
    for i in range(len(lst) - 1):
        if not (set(lst[i]) - set(lst[i + 1])):
            count += 1
    return count",0.0004618,26.53300781,"def count_super_elements(lst: list) -> int:
    count = 0
    for i in range(1, len(lst)):
        if all(ch in lst[i] for ch in lst[i - 1]):
            count += 1
    return count",0.0005027,26.53300781,"['b', 'a', 'c']"
152,"
def chain_score(words: list) -> int:
""""""
Given a list of strings, calculate a score based on the transition between consecutive words.
Start with a score of 0. Iterate through the list starting from the second word.
If the current word starts with the same character as the previous word ended with,
add the length of the current word to the score. Otherwise, subtract 1 from the score.

The comparison is case-sensitive. Return 0 if the list has fewer than 2 words.

Examples:
chain_score([""apple"", ""eat"", ""tea""]) == 6
chain_score([""cat"", ""dog"", ""god""]) == 2
chain_score([""a"", ""b"", ""c""]) == -2
""""""
pass
","def chain_score(words: list) -> int:
    if len(words) < 2:
        return 0
    score = 0
    for i in range(1, len(words)):
        if words[i-1][-1] == words[i][0]:
            score += len(words[i])
        else:
            score -= 1
    return score",0.0005091,26.54589844,"def chain_score(words: list) -> int:
    if len(words) < 2:
        return 0
    score = 0
    for w1, w2 in zip(words, words[1:]):
        if w1 and w2 and w2.startswith(w1[-1]):
            score += len(w2)
        else:
            score -= 1
    return score",0.0004664,26.54589844,"def chain_score(words: list) -> int:
    from functools import reduce
    if len(words) < 2:
        return 0
    def step(acc, curr):
        score, prev = acc
        if prev and curr and curr[0] == prev[-1]:
            return (score + len(curr), curr)
        else:
            return (score - 1, curr)
    score, _ = reduce(step, words[1:], (0, words[0]))
    return score
",0.0005156,26.54589844,"['b', 'a', 'c']"
153,"
def min_max_arrangement(lst):
""""""
Given a list of integers, return a new list where the elements are arranged
in a specific order: the first element is the minimum of the original list,
the second element is the maximum, the third is the second minimum,
the fourth is the second maximum, and so on.

If the list is empty, return an empty list.

Examples:
min_max_arrangement([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
min_max_arrangement([10, 20]) == [10, 20]
min_max_arrangement([5, 5, 1]) == [1, 5, 5]
""""""
","def min_max_arrangement(lst):
    if not lst:
        return []
    sorted_lst = sorted(lst)
    result = []
    left, right = 0, len(sorted_lst) - 1
    take_min = True
    while left <= right:
        if take_min:
            result.append(sorted_lst[left])
            left += 1
        else:
            result.append(sorted_lst[right])
            right -= 1
        take_min = not take_min
    return result",0.0004623,26.67617188,"def min_max_arrangement(lst):
    sorted_vals = sorted(lst)
    result = []
    for i in range(len(lst)):
        if i % 2 == 0:
            result.append(sorted_vals[i // 2])
        else:
            result.append(sorted_vals[-(i // 2 + 1)])
    return result",0.0005222,26.67617188,"def min_max_arrangement(lst):
    from collections import Counter
    import heapq
    if not lst:
        return []
    counts = Counter(lst)
    min_heap = list(counts.keys())
    max_heap = [-k for k in counts.keys()]
    heapq.heapify(min_heap)
    heapq.heapify(max_heap)
    res = []
    take_min = True
    while len(res) < len(lst):
        if take_min:
            while True:
                x = heapq.heappop(min_heap)
                if counts[x] > 0:
                    res.append(x)
                    counts[x] -= 1
                    if counts[x] > 0:
                        heapq.heappush(min_heap, x)
                        heapq.heappush(max_heap, -x)
                    take_min = False
                    break
        else:
            while True:
                x = -heapq.heappop(max_heap)
                if counts[x] > 0:
                    res.append(x)
                    counts[x] -= 1
                    if counts[x] > 0:
                        heapq.heappush(min_heap, x)
                        heapq.heappush(max_heap, -x)
                    take_min = True
                    break
    return res",0.0005522,26.67617188,"['a', 'b', 'c']"
154,"
def insert_parity_marks(text: str) -> str:
""""""
Given a string of digits, return a new string with characters inserted between adjacent digits based on their parity:
- Insert '*' between two consecutive even digits.
- Insert '-' between two consecutive odd digits.
- Insert nothing between digits of different parity.

Constraints: The input string will strictly contain only numeric characters (0-9).

Examples:
insert_parity_marks(""1357"") -> ""1-3-5-7""
insert_parity_marks(""2468"") -> ""2*4*6*8""
insert_parity_marks(""1234"") -> ""1234""
insert_parity_marks(""112233"") -> ""1-12*23-3""
""""""
","def insert_parity_marks(text: str) -> str:
    if len(text) <= 1:
        return text
    result = [text[0]]
    for i in range(1, len(text)):
        prev, curr = int(text[i-1]), int(text[i])
        if prev % 2 == 0 and curr % 2 == 0:
            result.append('*')
        elif prev % 2 == 1 and curr % 2 == 1:
            result.append('-')
        result.append(text[i])
    return ''.join(result)",0.0004827,25.98320313,"def insert_parity_marks(text: str) -> str:
    if not text:
        return """"
    
    def get_mark(a, b):
        p1, p2 = int(a) % 2, int(b) % 2
        if p1 == p2:
            return ""*"" if p1 == 0 else ""-""
        return """"
    
    parts = [a + get_mark(a, b) for a, b in zip(text, text[1:])]
    return """".join(parts) + text[-1]",0.0004121,25.98320313,"def insert_parity_marks(text: str) -> str:
    if not text:
        return """"
    n = len(text)
    par = [(ord(ch) - 48) & 1 for ch in text]
    marks = [('*' if par[i] == 0 and par[i+1] == 0 else ('-' if par[i] == 1 and par[i+1] == 1 else '')) for i in range(n - 1)]
    res = [text[0]]
    for i in range(n - 1):
        m = marks[i]
        if m:
            res.append(m)
        res.append(text[i+1])
    return ''.join(res)",0.0003718,25.98320313,"['c', 'b', 'a']"
155,"
def group_sum_parity(lst):
""""""
Given a list of integers, return a new list where consecutive elements
in the original list that share the same parity (both even or both odd)
are summed together.

examples:
group_sum_parity([1, 3, 2, 4, 6]) == [4, 12]
# Explanation: 1,3 are odd (sum 4). 2,4,6 are even (sum 12).

group_sum_parity([1, 2, 3, 4]) == [1, 2, 3, 4]
group_sum_parity([5, 5, 5]) == [15]
group_sum_parity([]) == []
""""""
","def group_sum_parity(lst):
    if not lst:
        return []
    result = []
    current_sum = lst[0]
    current_parity = lst[0] % 2
    for n in lst[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.000459,26.88730469,"def group_sum_parity(lst):
    res = []
    i = 0
    while i < len(lst):
        total = lst[i]
        p = total % 2
        i += 1
        while i < len(lst) and lst[i] % 2 == p:
            total += lst[i]
            i += 1
        res.append(total)
    return res",0.0004688,26.88730469,"def group_sum_parity(lst):
    from itertools import groupby
    return [sum(group) for _, group in groupby(lst, key=lambda x: x % 2)]",0.0004849,26.88730469,"['a', 'b', 'c']"
156,"
def array_balance_differences(numbers: list) -> list:
""""""
Given a list of integers, return a new list of the same length where the element at index i
represents the absolute difference between the sum of elements to the left of i
and the sum of elements to the right of i.

For the first element, the left sum is considered 0.
For the last element, the right sum is considered 0.

Examples:
array_balance_differences([1, 2, 3]) == [5, 2, 3]
array_balance_differences([10]) == [0]
array_balance_differences([1, 1, 1, 1]) == [3, 1, 1, 3]
array_balance_differences([-5, 5, -5, 5]) == [5, 5, 5, 5]
""""""
","def chunk_transform(s: str, k: int) -> str:
    result = []
    chunks = [s[i:i+k] for i in range(0, len(s), k)]
    for idx, chunk in enumerate(chunks):
        if idx % 2 == 0:
            result.append(chunk[::-1])
        else:
            if len(chunk) > 1:
                result.append(chunk[1:] + chunk[0])
            else:
                result.append(chunk)
    return ''.join(result)",0.0004356,26.44570313,"def chunk_transform(s: str, k: int) -> str:
    res = []
    idx = 0
    while idx < len(s):
        group = s[idx : idx + k]
        res.append(group[::-1])
        idx += k
        if idx < len(s):
            group = s[idx : idx + k]
            res.append(group[1:] + group[0])
            idx += k
    return """".join(res)
 ",0.0005381,26.44570313,"def chunk_transform(s: str, k: int) -> str:
    if k <= 0:
        return s
    res = []
    pos = 0
    idx = 0
    n = len(s)
    while pos < n:
        end = pos + k
        chunk = s[pos:end]
        if idx % 2 == 0:
            res.append(chunk[::-1])
        else:
            if len(chunk) > 1:
                res.append(chunk[1:] + chunk[0])
            else:
                res.append(chunk)
        pos = end
        idx += 1
    return ''.join(res)",0.0004475,26.44570313,"['a', 'c', 'b']"
157,"
def chunk_transform(s: str, k: int) -> str:
""""""
Split the string `s` into groups of length `k`.
Process each group based on its 0-based index in the sequence of groups:
- If the group index is even, reverse the group string.
- If the group index is odd, rotate the group string to the left by 1 position (shift first character to the end).

Join the processed groups back into a single string.
The last group may be shorter than `k` but is treated the same way.

Constraints:
- k > 0
- s contains printable ASCII characters.

Examples:
chunk_transform(""abcdefg"", 3)
# Groups: [""abc"", ""def"", ""g""]
# Index 0 (Even): ""abc"" -> Reverse -> ""cba""
# Index 1 (Odd): ""def"" -> Rotate Left -> ""efd""
# Index 2 (Even): ""g"" -> Reverse -> ""g""
# Result: ""cbaefdg""

chunk_transform(""HelloWorld"", 2)
# Groups: [""He"", ""ll"", ""oW"", ""or"", ""ld""]
# 0: ""He"" -> ""eH""
# 1: ""ll"" -> ""ll""
# 2: ""oW"" -> ""Wo""
# 3: ""or"" -> ""ro""
# 4: ""ld"" -> ""dl""
# Result: ""eHllWorodl""
""""""
","def calculate_parity_sum(n: int) -> int:
    total = 0
    for d in str(n):
        digit = int(d)
        if digit % 2 == 1:
            total += digit
        else:
            total -= digit
    return total",0.0004487,26.07304688,"def calculate_parity_sum(n: int) -> int:
    parity_sums = [0, 0]
    for digit_char in str(n):
        digit = int(digit_char)
        parity_sums[digit % 2] += digit
    return parity_sums[1] - parity_sums[0]",0,0,"def calculate_parity_sum(n: int) -> int:
    total = 0
    while n:
        d = n % 10
        if d % 2:
            total += d
        else:
            total -= d
        n //= 10
    return total",0.0004271,26.07304688,"['c', 'a', 'b']"
158,"
def calculate_parity_sum(n: int) -> int:
""""""
Given a non-negative integer n, calculate a sum based on its digits.
Iterate through the digits of n: if a digit is odd, add its value to the sum;
if a digit is even, subtract its value from the sum.
Return the final calculated sum.

>>> calculate_parity_sum(123)
2
>>> calculate_parity_sum(88)
-16
>>> calculate_parity_sum(501)
6
>>> calculate_parity_sum(0)
0
""""""
","def closest_adjacent_sum(nums: list[int]) -> int:
    if len(nums) < 2:
        return 0
    min_diff = float('inf')
    best_sum = 0
    for i in range(len(nums) - 1):
        diff = abs(nums[i] - nums[i+1])
        pair_sum = nums[i] + nums[i+1]
        if diff < min_diff or (diff == min_diff and pair_sum > best_sum):
            min_diff = diff
            best_sum = pair_sum
    return best_sum",0.0003782,25.98300781,"def closest_adjacent_sum(nums: list[int]) -> int:
    if len(nums) < 2:
        return 0
    a, b = min(zip(nums, nums[1:]), key=lambda p: (abs(p[0] - p[1]), -(p[0] + p[1])))
    return a + b",0.0003773,25.98300781,"def closest_adjacent_sum(nums: list[int]) -> int:
    n = len(nums)
    if n < 2:
        return 0
    min_diff = None
    for i in range(n - 1):
        a, b = nums[i], nums[i + 1]
        diff = a - b
        if diff < 0:
            diff = -diff
        if min_diff is None or diff < min_diff:
            min_diff = diff
    max_sum = None
    for i in range(n - 1):
        a, b = nums[i], nums[i + 1]
        diff = a - b
        if diff < 0:
            diff = -diff
        if diff == min_diff:
            s = a + b
            if max_sum is None or s > max_sum:
                max_sum = s
    return 0 if max_sum is None else max_sum",0.0003407,25.98300781,"['c', 'b', 'a']"
159,"
def closest_adjacent_sum(nums: list[int]) -> int:
""""""
Given a list of integers, find the pair of adjacent elements that has the smallest absolute difference.
Return the sum of this pair.

If there are multiple pairs with the same minimum difference, return the one among them with the largest sum.
If the list contains fewer than 2 elements, return 0.

>>> closest_adjacent_sum([10, 15, 20, 23])
43
>>> closest_adjacent_sum([5, 10, 15])
25
>>> closest_adjacent_sum([1, 100, 2, 3])
5
""""""
","def group_indices_by_parity(nums: list) -> dict:
    result = {'even': [], 'odd': []}
    for i, n in enumerate(nums):
        if n % 2 == 0:
            result['even'].append(i)
        else:
            result['odd'].append(i)
    return result",0.0004731,26.78457031,"def group_indices_by_parity(nums: list) -> dict:
    groups = [[], []]
    for i in range(len(nums)):
        groups[nums[i] % 2].append(i)
    return {""even"": groups[0], ""odd"": groups[1]}",0.0004556,26.78457031,"def group_indices_by_parity(nums: list) -> dict:
    pairs = [(n & 1, i) for i, n in enumerate(nums)]
    pairs.sort(key=lambda x: x[0])
    even = [idx for par, idx in pairs if par == 0]
    odd = [idx for par, idx in pairs if par == 1]
    return {'even': even, 'odd': odd}
",0.0005323,26.78457031,"['b', 'a', 'c']"
160,"
def group_indices_by_parity(nums: list) -> dict:
""""""
Given a list of integers, return a dictionary with exactly two keys: ""even"" and ""odd"".
The values should be lists containing the indices (0-indexed) of the even and odd
numbers from the input list, respectively.

The indices in the output lists must be sorted in ascending order.

group_indices_by_parity([1, 2, 3, 4]) == {'even': [1, 3], 'odd': [0, 2]}
group_indices_by_parity([10, 20, 30]) == {'even': [0, 1, 2], 'odd': []}
group_indices_by_parity([5, 15]) == {'even': [], 'odd': [0, 1]}
group_indices_by_parity([]) == {'even': [], 'odd': []}
""""""
","def toggle_case_alternating(text: str) -> str:
    result = []
    is_lower = True
    for c in text:
        if c.isalpha():
            result.append(c.lower() if is_lower else c.upper())
            is_lower = not is_lower
        else:
            result.append(c)
    return ''.join(result)",0.0005373,26.43515625,"def toggle_case_alternating(text: str) -> str:
    chars = list(text)
    count = 0
    for i, c in enumerate(chars):
        if c.isalpha():
            chars[i] = c.lower() if count % 2 == 0 else c.upper()
            count += 1
    return """".join(chars)",0.0008673,26.43515625,"def toggle_case_alternating(text: str) -> str:
    import re
    toggled = [True]
    def repl(m):
        ch = m.group(0)
        out = ch.lower() if toggled[0] else ch.upper()
        toggled[0] = not toggled[0]
        return out
    return re.sub(r'[^\W\d_]', repl, text)",0.0008361,26.43515625,"['a', 'c', 'b']"
161,"
def toggle_case_alternating(text: str) -> str:
""""""
Given a string `text`, return a new string where all alphabetic characters
alternate between lowercase and uppercase, starting with lowercase for the
first letter found. Non-alphabetic characters are preserved and do not
influence the alternating sequence index.

>>> toggle_case_alternating(""Hello World"")
'hElLo WoRlD'
>>> toggle_case_alternating(""123abc456"")
'123aBc456'
>>> toggle_case_alternating(""String-Logic"")
'sTrInG-lOgIc'
""""""
","def filter_and_digit_sum(numbers: list) -> list:
    result = []
    for n in numbers:
        if n % 2 == 0:
            digit_sq_sum = sum(int(d)**2 for d in str(n))
            result.append(digit_sq_sum)
    return result",0.0004507,26.00195313,"def filter_and_digit_sum(numbers: list) -> list:
    ans = []
    for val in numbers:
        if val % 2 != 0:
            continue
        sq_sum = 0
        while val > 0:
            digit = val % 10
            sq_sum += digit * digit
            val //= 10
        ans.append(sq_sum)
    return ans",0.000406,26.00195313,"def filter_and_digit_sum(numbers: list) -> list:
    def sod(n):
        if n == 0:
            return 0
        return (n % 10) ** 2 + sod(n // 10)
    res = []
    for n in numbers:
        if n % 2 == 0:
            res.append(sod(n))
    return res",0.0005683,26.00195313,"['b', 'a', 'c']"
162,"
def filter_and_digit_sum(numbers: list) -> list:
""""""
Given a list of positive integers, return a new list containing the sum of
the squares of the digits for every even number in the input list.
Odd numbers in the input should be ignored.

>>> filter_and_digit_sum([10, 21, 4, 13])
[1, 16]
>>> filter_and_digit_sum([12, 202, 33])
[5, 8]
>>> filter_and_digit_sum([1, 3, 5])
[]
""""""
","def find_sandwiched_chars(s: str) -> list[str]:
    result = []
    for i in range(1, len(s) - 1):
        if s[i-1] == s[i+1]:
            result.append(s[i])
    return result",0.0004794,26.49824219,"def find_sandwiched_chars(s: str) -> list[str]:
    chars = []
    for left, mid, right in zip(s, s[1:], s[2:]):
        if left == right:
            chars.append(mid)
    return chars",0.0004264,26.49824219,"def find_sandwiched_chars(s: str) -> list[str]:
    return [s[i] for i in range(1, len(s) - 1) if s[i-1] == s[i+1]]
",0.00044,26.49824219,"['b', 'c', 'a']"
163,"
def find_sandwiched_chars(s: str) -> list[str]:
""""""
Given a string s, find all characters that are immediately surrounded
by two identical characters. Return a list of these characters
in the order they appear in the string.

Constraints:
- Case sensitive (e.g., 'a' and 'A' are considered different).
- Overlapping patterns count (e.g., in ""aaaa"", the middle two 'a's are both sandwiched).

Examples:
find_sandwiched_chars(""xyx"") == ['y']
find_sandwiched_chars(""abacada"") == ['b', 'c', 'd']
find_sandwiched_chars(""aaaa"") == ['a', 'a']
find_sandwiched_chars(""abc"") == []
""""""
","def sum_consecutive_runs(numbers):
    if not numbers:
        return []
    result = []
    current_val = numbers[0]
    current_sum = current_val
    for n in numbers[1:]:
        if n == current_val:
            current_sum += n
        else:
            result.append(current_sum)
            current_val = n
            current_sum = n
    result.append(current_sum)
    return result",0.0004103,26.00292969,"def sum_consecutive_runs(numbers):
    res = []
    i = 0
    while i < len(numbers):
        start = i
        while i < len(numbers) and numbers[i] == numbers[start]:
            i += 1
        res.append(sum(numbers[start:i]))
    return res",0.0003702,26.00292969,"def sum_consecutive_runs(numbers):
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers)]",0.0003568,26.00292969,"['c', 'b', 'a']"
164,"
def sum_consecutive_runs(numbers):
""""""
Given a list of integers, return a new list where every sequence of
consecutive identical values is replaced by their sum.

The order of the groups must be preserved.

>>> sum_consecutive_runs([1, 1, 2, 1])
[2, 2, 1]
>>> sum_consecutive_runs([1, 2, 3, 3, 3])
[1, 2, 9]
>>> sum_consecutive_runs([])
[]
>>> sum_consecutive_runs([10, 10, 10, 10])
[40]
""""""
pass
","def digit_position_delta(num1: int, num2: int) -> int:
    s1, s2 = str(num1), str(num2)
    max_len = max(len(s1), len(s2))
    s1 = s1.zfill(max_len)
    s2 = s2.zfill(max_len)
    return sum(abs(int(a) - int(b)) for a, b in zip(s1, s2))",0.0004668,26.69257813,"def digit_position_delta(num1: int, num2: int) -> int:
    d1, d2 = list(str(num1)), list(str(num2))
    res = 0
    while d1 or d2:
        v1 = int(d1.pop()) if d1 else 0
        v2 = int(d2.pop()) if d2 else 0
        res += abs(v1 - v2)
    return res",0.0004809,26.69257813,"def digit_position_delta(num1: int, num2: int) -> int:
    total = 0
    while num1 > 0 or num2 > 0:
        total += abs((num1 % 10) - (num2 % 10))
        num1 //= 10
        num2 //= 10
    return total",0.0004694,26.69257813,"['a', 'c', 'b']"
165,"
def digit_position_delta(num1: int, num2: int) -> int:
""""""
Given two non-negative integers num1 and num2, calculate the sum of the absolute
differences between their digits when aligned from the right (least significant digit).
If the numbers differ in digit count, assume the shorter number has leading zeros.

Args:
num1: A non-negative integer.
num2: A non-negative integer.

Returns:
The sum of absolute differences of the aligned digits.

Examples:
digit_position_delta(123, 456) == 9 # |3-6| + |2-5| + |1-4| = 3 + 3 + 3 = 9
digit_position_delta(1, 10) == 2 # |1-0| + |0-1| = 1 + 1 = 2
digit_position_delta(105, 5) == 6 # |5-5| + |0-0| + |1-0| = 0 + 0 + 1 = 1
digit_position_delta(99, 0) == 18 # |9-0| + |9-0| = 18
""""""
","def sum_consecutive_evens(nums: list) -> list:
    if not nums:
        return []
    result = []
    i = 0
    while i < len(nums):
        if nums[i] % 2 == 0:
            even_sum = 0
            while i < len(nums) and nums[i] % 2 == 0:
                even_sum += nums[i]
                i += 1
            result.append(even_sum)
        else:
            result.append(nums[i])
            i += 1
    return result",0.0005741,26.0546875,"def sum_consecutive_evens(nums: list) -> list:
    result = []
    for i, num in enumerate(nums):
        if i > 0 and num % 2 == 0 and nums[i-1] % 2 == 0:
            result[-1] += num
        else:
            result.append(num)
    return result",0.0007461,26.0546875,"def sum_consecutive_evens(nums: list) -> list:
    from itertools import groupby
    result = []
    for parity, group in groupby(nums, key=lambda x: x % 2):
        block = list(group)
        if parity == 0:
            result.append(sum(block))
        else:
            result.extend(block)
    return result",0.0006419,26.0546875,"['a', 'c', 'b']"
166,"
def sum_consecutive_evens(nums: list) -> list:
""""""
Given a list of integers, return a new list where every sequence of consecutive
even numbers is replaced by their sum. Odd numbers remain unchanged and
serve as boundaries for the even sequences.

>>> sum_consecutive_evens([1, 2, 2, 3, 6, 4])
[1, 4, 3, 10]
>>> sum_consecutive_evens([2, 4, 6, 8])
[20]
>>> sum_consecutive_evens([1, 3, 5])
[1, 3, 5]
>>> sum_consecutive_evens([10, 1, 5, 2, 4, 1])
[10, 1, 5, 6, 1]
""""""
","def select_strong_elements(numbers: list[int]) -> list[int]:
    result = []
    right_sum = sum(numbers)
    for n in numbers:
        right_sum -= n
        if n > right_sum:
            result.append(n)
    return result",0.0012186,26.89824219,"def select_strong_elements(numbers: list[int]) -> list[int]:
    strong_elements = []
    for i in range(len(numbers)):
        if numbers[i] > sum(numbers[i + 1:]):
            strong_elements.append(numbers[i])
    return strong_elements",0.0006066,26.89824219,"def select_strong_elements(numbers: list[int]) -> list[int]:
    result_rev = []
    acc = 0
    for n in reversed(numbers):
        if n > acc:
            result_rev.append(n)
        acc += n
    return list(reversed(result_rev))",0.0005173,26.89824219,"['c', 'b', 'a']"
167,"
def select_strong_elements(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, return a new list containing only the elements that are
strictly greater than the sum of all elements to their right in the original list.
The last element is always compared against 0 (sum of an empty sequence).

>>> select_strong_elements([1, 2, 3, 4])
[4]
>>> select_strong_elements([10, 3, 2, 1])
[10, 3, 2, 1]
>>> select_strong_elements([5, 1, 6, 2])
[6, 2]
""""""
","def merge_common_keys(d1: dict, d2: dict) -> list:
    vowels = set('aeiouAEIOU')
    common = set(d1.keys()) & set(d2.keys())
    result = []
    for key in sorted(common):
        if key[-1] in vowels:
            result.append(d1[key] + d2[key])
        else:
            result.append(d2[key] + d1[key])
    return result",0.0004472,26.42890625,"def merge_common_keys(d1: dict, d2: dict) -> list:
    common_keys = [k for k in d1 if k in d2]
    common_keys.sort()
    vowels = ('a', 'e', 'i', 'o', 'u')
    return [d1[k] + d2[k] if k.lower().endswith(vowels) else d2[k] + d1[k] for k in common_keys]",0.000452,26.42890625,"def merge_common_keys(d1: dict, d2: dict) -> list:
    common = []
    for k in d1:
        if k in d2:
            common.append((k, d1[k], d2[k]))
    common.sort(key=lambda t: t[0])
    res = []
    for k, v1, v2 in common:
        last = k[-1].lower() if k else ''
        if last in 'aeiou':
            res.append(v1 + v2)
        else:
            res.append(v2 + v1)
    return res",0.0004524,26.42890625,"['a', 'b', 'c']"
168,"
def merge_common_keys(d1: dict, d2: dict) -> list:
""""""
Given two dictionaries d1 and d2 (mapping strings to strings), find keys present in both.
Return a list of combined values for these common keys, sorted by the alphabetical order
of the keys.

The combination rule is:
- If the key ends with a vowel (a, e, i, o, u, case-insensitive), result is d1[key] + d2[key].
- Otherwise (consonant or other char), result is d2[key] + d1[key].

>>> merge_common_keys({'a': 'Py', 'b': 'Go'}, {'a': 'thon', 'b': 'lang'})
[' ', 'langGo']

>>> merge_common_keys({'apple': 'sweet', 'pear': 'tart'}, {'apple': 'pie', 'banana': 'bread'})
['sweetpie']

>>> merge_common_keys({'xyz': '123'}, {'abc': '456'})
[]
""""""
","def sum_consecutive_products(nums):
    if len(nums) < 2:
        return 0
    total = 0
    for i in range(len(nums) - 1):
        if nums[i+1] == nums[i] + 1:
            total += nums[i] * nums[i+1]
    return total",0.0007051,27.9734375,"def sum_consecutive_products(nums):
    result = 0
    for x, y in zip(nums, nums[1:]):
        if y == x + 1:
            result += x * y
    return result",0.0006719,27.9734375,"def sum_consecutive_products(nums):
    if len(nums) < 2:
        return 0
    if nums[1] == nums[0] + 1:
        return nums[0] * nums[1] + sum_consecutive_products(nums[1:])
    else:
        return sum_consecutive_products(nums[1:])",0.0006703,27.9734375,"['c', 'b', 'a']"
169,"
def sum_consecutive_products(nums):
""""""
Given a list of integers, calculate the sum of products of all adjacent pairs that are numerically consecutive.
Specifically, iterate through the list and check every adjacent pair (nums[i], nums[i+1]).
If nums[i+1] equals nums[i] + 1, multiply them and add the result to the total sum.

If the list contains fewer than 2 elements, return 0.

>>> sum_consecutive_products([1, 2, 4, 5])
22
>>> sum_consecutive_products([1, 2, 3])
8
>>> sum_consecutive_products([5, 10, 11, 20])
110
>>> sum_consecutive_products([9, 8, 7])
0
""""""
","from typing import List

def sort_unique_char_words(words: List[str]) -> List[str]:
    unique = [w for w in words if len(set(w)) == len(w)]
    return sorted(unique, key=lambda w: (-len(w), w))",0.000431,26.33476563,"from typing import List

def sort_unique_char_words(words: List[str]) -> List[str]:
    result = []
    for word in words:
        seen = set()
        for c in word:
            if c in seen:
                break
            seen.add(c)
        else:
            result.append(word)
    result.sort()
    result.sort(key=len, reverse=True)
    return result",0.0004621,26.33476563,"from typing import List

def sort_unique_char_words(words: List[str]) -> List[str]:
    valid = []
    for w in words:
        mask = 0
        ok = True
        for ch in w:
            bit = 1 << (ord(ch) - 97)
            if mask & bit:
                ok = False
                break
            mask |= bit
        if ok:
            valid.append(w)
    valid.sort(key=lambda s: (-len(s), s))
    return valid",0.0004529,26.33476563,"['a', 'c', 'b']"
170,"
from typing import List

def sort_unique_char_words(words: List[str]) -> List[str]:
""""""
Given a list of strings, return a new list containing only the strings that consist
of unique characters (no character repeats within the string).

The resulting list must be sorted primarily by length in descending order.
If two strings have the same length, sort them alphabetically in ascending order.

Constraints:
- Input strings will consist of lowercase English letters.

>>> sort_unique_char_words([""apple"", ""banana"", ""cat"", ""dog""])
['cat', 'dog']

>>> sort_unique_char_words([""abc"", ""de"", ""fghi"", ""a""])
['fghi', 'abc', 'de', 'a']

>>> sort_unique_char_words([""racecar"", ""level"", ""hello""])
[]

>>> sort_unique_char_words([""xy"", ""yx"", ""z""])
['xy', 'yx', 'z']
""""""
","def max_difference_tracking(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_max = numbers[0]
    for n in numbers:
        current_max = max(current_max, n)
        result.append(current_max - n)
    return result",0.0007905,26.6203125,"from itertools import accumulate

def max_difference_tracking(numbers: list[int]) -> list[int]:
    running_maxes = accumulate(numbers, max)
    return [m - n for m, n in zip(running_maxes, numbers)]",0.0005833,26.6203125,"def max_difference_tracking(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result: list[int] = []
    for i in range(len(numbers)):
        current_max = max(numbers[:i+1])
        result.append(current_max - numbers[i])
    return result",0.0010159,26.6203125,"['b', 'a', 'c']"
171,"
def max_difference_tracking(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, generate a new list where the element at index 'i'
is the difference between the maximum value seen in the input list up to index 'i'
(inclusive) and the current element at index 'i'.

Examples:
max_difference_tracking([1, 2, 3, 4]) == [0, 0, 0, 0]
max_difference_tracking([5, 1, 3, 2]) == [0, 4, 2, 3]
max_difference_tracking([10, 2, 5, 12, 1]) == [0, 8, 5, 0, 11]
""""""
","def transform_values(nums):
    result = []
    for n in nums:
        digits = [int(d) for d in str(n)]
        if n % 2 == 0:
            result.append(sum(digits))
        else:
            product = 1
            for d in digits:
                product *= d
            result.append(product)
    return result",0.000474,26.74863281,"def transform_values(nums):
    import math
    def apply_rules(n):
        d = list(map(int, str(n)))
        if n % 2 == 0:
            return sum(d)
        return math.prod(d)
    return [apply_rules(x) for x in nums]",0.0004679,26.74863281,"def transform_values(nums):
    result = []
    for n in nums:
        if n % 2 == 0:
            s = 0
            x = n
            while x > 0:
                s += x % 10
                x //= 10
            result.append(s)
        else:
            p = 1
            x = n
            while x > 0:
                p *= x % 10
                x //= 10
            result.append(p)
    return result",0.000485,26.74863281,"['b', 'a', 'c']"
172,"
def transform_values(nums):
""""""
Given a list of non-negative integers, return a new list where each element is transformed
based on the following rules:
- If the number is even, replace it with the sum of its digits.
- If the number is odd, replace it with the product of its digits.

transform_values([12, 35, 8]) == [3, 15, 8]
transform_values([10, 20, 25]) == [1, 2, 10]
transform_values([0, 11, 99]) == [0, 1, 81]
""""""
","def prune_surrounded(s: str) -> str:
    if len(s) <= 2:
        return s
    result = [s[0]]
    for i in range(1, len(s) - 1):
        if not s[i].isdigit() and s[i-1].isdigit() and s[i+1].isdigit():
            continue
        result.append(s[i])
    result.append(s[-1])
    return ''.join(result)",0.0004761,26.45839844,"import re

def prune_surrounded(s: str) -> str:
    return re.sub(r'(?<=\d)\D(?=\d)', '', s)",0.0004815,26.45839844,"def prune_surrounded(s: str) -> str:
    n = len(s)
    if n <= 2:
        return s
    def is_digit(ch: str) -> bool:
        o = ord(ch)
        return 48 <= o <= 57
    res = []
    for i, ch in enumerate(s):
        if i == 0 or i == n - 1:
            res.append(ch)
        else:
            if not is_digit(ch) and is_digit(s[i-1]) and is_digit(s[i+1]):
                continue
            res.append(ch)
    return ''.join(res)",0.0004276,26.45839844,"['c', 'a', 'b']"
173,"
def prune_surrounded(s: str) -> str:
""""""
Return a new string where characters are removed if they are NOT digits,
but are immediately preceded and followed by a digit in the original string.

The first and last characters of the string are always preserved.

Examples:
prune_surrounded(""a1b2c"") == ""a12c""
prune_surrounded(""1x1y1"") == ""111""
prune_surrounded(""abc"") == ""abc""
prune_surrounded(""5A5"") == ""55""
""""""
","def filter_by_index_parity(lst):
    return sorted([n for i, n in enumerate(lst) if i % 2 == n % 2])",0.0003741,26.00058594,"def filter_by_index_parity(lst):
    result = []
    for x in lst[::2]:
        if x % 2 == 0:
            result.append(x)
    for x in lst[1::2]:
        if x % 2 == 1:
            result.append(x)
    result.sort()
    return result",0.0006021,26.00058594,"def filter_by_index_parity(lst):
    i = 0
    result = []
    while i < len(lst):
        if ((i ^ lst[i]) & 1) == 0:
            result.append(lst[i])
        i += 1
    result.sort()
    return result",0.0003736,26.00058594,"['c', 'a', 'b']"
174,"
def filter_by_index_parity(lst):
""""""
Given a list of non-negative integers, return a list containing only the elements
that have the same parity (even or odd) as their index in the original list.
The result must be sorted in ascending order.

filter_by_index_parity([1, 2, 3, 4]) == []
filter_by_index_parity([0, 1, 2, 3]) == [0, 1, 2, 3]
filter_by_index_parity([10, 21, 4, 5]) == [4, 5, 10, 21]
filter_by_index_parity([5, 2, 0, 9, 1]) == [0, 9]
""""""
","def cyclic_vowel_shift(text: str, shift: int) -> str:
    vowels = ['a', 'e', 'i', 'o', 'u']
    result = []
    for c in text:
        if c in vowels:
            idx = vowels.index(c)
            result.append(vowels[(idx + shift) % 5])
        else:
            result.append(c)
    return ''.join(result)",0.0004502,26.44902344,"def cyclic_vowel_shift(text: str, shift: int) -> str:
    vowels = ""aeiou""
    n = shift % 5
    target = vowels[n:] + vowels[:n]
    return text.translate(str.maketrans(vowels, target))",0.0004552,26.44902344,"def cyclic_vowel_shift(text: str, shift: int) -> str:
    vowels = 'aeiou'
    n = shift % 5
    mapping = {v: vowels[(i + n) % 5] for i, v in enumerate(vowels)}
    return ''.join(mapping.get(ch, ch) for ch in text)",0.0004379,26.44902344,"['c', 'a', 'b']"
175,"
def cyclic_vowel_shift(text: str, shift: int) -> str:
""""""
Given a string 'text' containing only lowercase English letters and spaces,
replace every vowel (a, e, i, o, u) with the vowel that appears 'shift'
positions later in the cyclic sequence ['a', 'e', 'i', 'o', 'u'].
Consonants and spaces remain unchanged.

>>> cyclic_vowel_shift(""hello world"", 1)
'hillo wurld'
>>> cyclic_vowel_shift(""apple"", 2)
'ipplu'
>>> cyclic_vowel_shift(""aeiou"", 3)
'ouaei'
>>> cyclic_vowel_shift(""xyz"", 10)
'xyz'
""""""
","def odd_digit_products(numbers: list) -> list:
    result = []
    for n in numbers:
        digits = [int(d) for d in str(abs(n))]
        product = 1
        for d in digits:
            product *= d
        if product % 2 == 1:
            result.append(product)
    return result",0,0,"def odd_digit_products(numbers: list) -> list:
    import math
    res = []
    for n in numbers:
        p = math.prod(map(int, str(abs(n))))
        if p % 2 != 0:
            res.append(p)
    return res",0,0,"def odd_digit_products(numbers: list) -> list:
    res = []
    for n in numbers:
        s = str(abs(n))
        all_odd = True
        for ch in s:
            if (ord(ch) - 48) % 2 == 0:
                all_odd = False
                break
        if not all_odd:
            continue
        prod = 1
        for ch in s:
            prod *= (ord(ch) - 48)
        res.append(prod)
    return res",0,0,"['a', 'b', 'c']"
176,"
def odd_digit_products(numbers: list) -> list:
""""""
Given a list of integers, calculate the product of the digits for each number.
Return a new list containing these products, but only for the numbers where the
calculated product is odd. Treat negative numbers as their absolute values.

Examples:
odd_digit_products([13, 24, 51, 77]) == [3, 5, 49]
odd_digit_products([2, 4, 8, 10]) == []
odd_digit_products([-11, 35, 111]) == [1, 15, 1]
""""""
","def interleave_and_flip_tail(a: list, b: list) -> list:
    result = []
    min_len = min(len(a), len(b))
    for i in range(min_len):
        result.append(a[i])
        result.append(b[i])
    if len(a) > min_len:
        result.extend(a[min_len:][::-1])
    elif len(b) > min_len:
        result.extend(b[min_len:][::-1])
    return result",0.0009097,26.50410156,"def interleave_and_flip_tail(a: list, b: list) -> list:
    res = []
    i = 0
    while i < len(a) and i < len(b):
        res.append(a[i])
        res.append(b[i])
        i += 1
    for j in range(len(a) - 1, i - 1, -1):
        res.append(a[j])
    for j in range(len(b) - 1, i - 1, -1):
        res.append(b[j])
    return res",0.0012168,26.50410156,"def interleave_and_flip_tail(a: list, b: list) -> list:
    inter = [x for pair in zip(a, b) for x in pair]
    if len(a) > len(b):
        inter.extend(reversed(a[len(b):]))
    elif len(b) > len(a):
        inter.extend(reversed(b[len(a):]))
    return inter",0.0008124,26.50410156,"['c', 'a', 'b']"
177,"
def interleave_and_flip_tail(a: list, b: list) -> list:
""""""
Create a new list by interleaving elements from lists `a` and `b`, starting with `a`.
Once the shorter list is exhausted, append the remaining elements of the longer list
strictly in reverse order.

If the lists are of equal length, no reversing occurs.

>>> interleave_and_flip_tail([1, 2, 3], [4, 5])
[1, 4, 2, 5, 3]
>>> interleave_and_flip_tail([1, 2], [3, 4, 5, 6])
[1, 3, 2, 4, 6, 5]
>>> interleave_and_flip_tail([], [10, 20])
[20, 10]
""""""
","def longest_alternating_parity(nums: list[int]) -> int:
    if not nums:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(nums)):
        if nums[i] % 2 != nums[i-1] % 2:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",0.0004882,26.59082031,"def longest_alternating_parity(nums: list[int]) -> int:
    if not nums:
        return 0
    n = len(nums)
    longest = 0
    i = 0
    while i < n:
        start = i
        while i + 1 < n and nums[i] % 2 != nums[i + 1] % 2:
            i += 1
        current_len = i - start + 1
        if current_len > longest:
            longest = current_len
        i += 1
    return longest",0.0004956,26.59082031,"def longest_alternating_parity(nums: list[int]) -> int:
    if not nums:
        return 0
    even_end = 0
    odd_end = 0
    max_len = 0
    for x in nums:
        if x % 2 == 0:
            new_even = odd_end + 1
            new_odd = 0
        else:
            new_odd = even_end + 1
            new_even = 0
        even_end = new_even
        odd_end = new_odd
        if new_even > max_len:
            max_len = new_even
        if new_odd > max_len:
            max_len = new_odd
    return max_len",0.0005036,26.59082031,"['a', 'b', 'c']"
178,"
def longest_alternating_parity(nums: list[int]) -> int:
""""""
Given a list of integers, return the length of the longest contiguous sub-list
where the integers alternate between even and odd parity.

If the list is empty, return 0. A single element counts as a sequence of length 1.

>>> longest_alternating_parity([1, 2, 3, 4])
4
>>> longest_alternating_parity([1, 3, 5])
1
>>> longest_alternating_parity([1, 2, 2, 3, 4])
3
>>> longest_alternating_parity([])
0
""""""
","def unique_char_balance(text: str) -> int:
    from collections import Counter
    counts = Counter(text)
    score = 0
    for c, cnt in counts.items():
        if cnt == 1 and c.isalpha():
            if c.isupper():
                score += ord(c)
            else:
                score -= ord(c)
    return score",0.0005094,26.94257813,"def unique_char_balance(text: str) -> int:
    balance = 0
    for char in text:
        if text.count(char) == 1:
            if char.isupper():
                balance += ord(char)
            elif char.islower():
                balance -= ord(char)
    return balance",0.0005002,26.94257813,"def unique_char_balance(text: str) -> int:
    seen_once = set()
    seen_multiple = set()
    for c in text:
        if not c.isalpha():
            continue
        if c in seen_multiple:
            continue
        if c in seen_once:
            seen_once.remove(c)
            seen_multiple.add(c)
        else:
            seen_once.add(c)
    score = 0
    for c in seen_once:
        if c.isupper():
            score += ord(c)
        elif c.islower():
            score -= ord(c)
    return score",0.0005056,26.94257813,"['b', 'c', 'a']"
179,"
def unique_char_balance(text: str) -> int:
""""""
Calculates a score for the input string based on characters that appear exactly once.

The score is determined by:
1. Identifying all characters that appear exactly once in the string.
2. Adding the ASCII value of such characters if they are uppercase letters.
3. Subtracting the ASCII value of such characters if they are lowercase letters.
4. Ignoring all non-alphabetic characters and characters with a frequency greater than 1.

Args:
text (str): Input string to evaluate.

Examples:
unique_char_balance(""a"") == -97
unique_char_balance(""Ab"") == -33 # 65 - 98
unique_char_balance(""Aaa"") == 65 # 'a' is repeated, so it is ignored
unique_char_balance(""xyXY"") == -64 # (88 + 89) - (120 + 121)
""""""
","def alternating_alpha_case(s: str) -> str:
    result = []
    is_upper = True
    for c in s:
        if c.isalpha():
            result.append(c.upper() if is_upper else c.lower())
            is_upper = not is_upper
        else:
            result.append(c)
    return ''.join(result)",0.0004343,25.99375,"def alternating_alpha_case(s: str) -> str:
    chars = list(s)
    count = 0
    for i in range(len(chars)):
        if chars[i].isalpha():
            if count % 2 == 0:
                chars[i] = chars[i].upper()
            else:
                chars[i] = chars[i].lower()
            count += 1
    return """".join(chars)",0.0003864,25.99375,"def alternating_alpha_case(s: str) -> str:
    alpha_chars = [c for c in s if c.isalpha()]
    transformed = [c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(alpha_chars)]
    it = iter(transformed)
    res = []
    for ch in s:
        if ch.isalpha():
            res.append(next(it))
        else:
            res.append(ch)
    return ''.join(res)",0.0003897,25.99375,"['b', 'c', 'a']"
180,"
def alternating_alpha_case(s: str) -> str:
""""""
Transform the input string `s` such that its alphabetic characters alternate between
uppercase and lowercase, beginning with uppercase for the first alphabetic character
encountered. Non-alphabetic characters remain unchanged and do not influence the
case alternation order.

examples:
alternating_alpha_case(""Hello World"") == ""HeLlO wOrLd""
alternating_alpha_case(""123a4b"") == ""123A4b""
alternating_alpha_case(""xy.z"") == ""Xy.Z""
alternating_alpha_case("""") == """"
""""""
","def transform_words_by_length(text: str) -> str:
    words = text.split(' ')
    result = []
    for word in words:
        if len(word) % 2 == 1:
            result.append(word[::-1])
        else:
            half = len(word) // 2
            result.append(word[half:] + word[:half])
    return ' '.join(result)",0,0,"def transform_words_by_length(text: str) -> str:
    def change_word(word):
        n = len(word)
        mid, odd = divmod(n, 2)
        if odd:
            return """".join(reversed(word))
        return f""{word[mid:]}{word[:mid]}""

    return "" "".join(map(change_word, text.split("" "")))",0,0,"def transform_words_by_length(text: str) -> str:
    def proc(word: str) -> str:
        n = len(word)
        if n & 1:
            return word[::-1]
        half = n // 2
        return word[half:] + word[:half]

    res = []
    current = []
    for ch in text:
        if ch == ' ':
            if current:
                res.append(proc(''.join(current)))
                current = []
            res.append(' ')
        else:
            current.append(ch)
    if current:
        res.append(proc(''.join(current)))
    return ''.join(res)",0,0,"['a', 'b', 'c']"
181,"
def transform_words_by_length(text: str) -> str:
""""""
Given a string containing space-separated words, transform each word based on its length:
- If the word length is odd, reverse the word.
- If the word length is even, swap the first half of the word with the second half.
Return the resulting string with words separated by a single space.

Constraints:
- The input string consists of only English letters and spaces.

transform_words_by_length(""Hello"") == ""olleH""
transform_words_by_length(""code"") == ""deco""
transform_words_by_length(""Hello world"") == ""olleH dlrow""
transform_words_by_length(""ab cd efgh"") == ""ba dc ghef""
""""""
","def alternate_alpha_case(s: str) -> str:
    result = []
    is_upper = True
    for c in s:
        if c.isalpha():
            result.append(c.upper() if is_upper else c.lower())
            is_upper = not is_upper
        else:
            result.append(c)
    return ''.join(result)",0.0004219,25.98496094,"def alternate_alpha_case(s: str) -> str:
    res = list(s)
    count = 0
    for i in range(len(s)):
        if res[i].isalpha():
            res[i] = res[i].upper() if count % 2 == 0 else res[i].lower()
            count += 1
    return """".join(res)",0.0007599,25.98496094,"def alternate_alpha_case(s: str) -> str:
    from itertools import cycle
    alt = cycle([True, False])
    res = []
    for ch in s:
        if ch.isalpha():
            res.append(ch.upper() if next(alt) else ch.lower())
        else:
            res.append(ch)
    return ''.join(res)
",0.0004235,25.98496094,"['a', 'c', 'b']"
182,"
def alternate_alpha_case(s: str) -> str:
""""""
Given a string s, transform it such that all alphabetic characters alternate case,
starting with uppercase for the first alphabetic character found.
Non-alphabetic characters remain unchanged and do not affect the alternating sequence.

Examples:
alternate_alpha_case(""hello"") == ""HeLlO""
alternate_alpha_case(""a.b.c"") == ""A.b.C""
alternate_alpha_case(""123a4b"") == ""123A4b""
alternate_alpha_case("""") == """"
""""""
","def flip_every_second_batch(lst: list, n: int) -> list:
    result = []
    batches = [lst[i:i+n] for i in range(0, len(lst), n)]
    for idx, batch in enumerate(batches):
        if idx % 2 == 1:
            result.extend(batch[::-1])
        else:
            result.extend(batch)
    return result",0.0004481,26.00136719,"def flip_every_second_batch(lst: list, n: int) -> list:
    result = lst[:]
    for i in range(n, len(result), 2 * n):
        result[i:i+n] = result[i:i+n][::-1]
    return result",0.0004008,26.00136719,"def flip_every_second_batch(lst: list, n: int) -> list:
    if n <= 0:
        return lst[:]
    res = []
    start = 0
    batch = 0
    length = len(lst)
    while start < length:
        end = min(start + n, length)
        if batch % 2 == 1:
            for j in range(end - 1, start - 1, -1):
                res.append(lst[j])
        else:
            for j in range(start, end):
                res.append(lst[j])
        start = end
        batch += 1
    return res",0.0005226,26.00136719,"['b', 'a', 'c']"
183,"
def flip_every_second_batch(lst: list, n: int) -> list:
""""""
Given a list of integers `lst` and a positive integer `n`, return a new list where
every second batch of `n` elements is reversed. The first batch should remain as is,
the second reversed, the third as is, and so on. Remaining elements that do not form
a full batch are treated as a final batch.

flip_every_second_batch([1, 2, 3, 4, 5], 2) == [1, 2, 4, 3, 5]
flip_every_second_batch([1, 2, 3, 4, 5, 6, 7, 8], 3) == [1, 2, 3, 6, 5, 4, 7, 8]
flip_every_second_batch([10, 20], 5) == [10, 20]
""""""
pass
","def sum_prime_index_powers(nums: list[int]) -> int:
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    total = 0
    for i, n in enumerate(nums):
        if is_prime(n):
            total += n ** i
    return total",0.0006746,27.17851563,"def sum_prime_index_powers(nums: list[int]) -> int:
    ans = 0
    pos = 0
    while pos < len(nums):
        n = nums[pos]
        divs = 0
        for i in range(1, n + 1):
            if n % i == 0:
                divs += 1
        if divs == 2:
            ans += n ** pos
        pos += 1
    return ans",0.0008181,27.17851563,"def sum_prime_index_powers(nums: list[int]) -> int:
    if not nums:
        return 0
    m = max(nums)
    if m < 2:
        return 0
    sieve = [True] * (m + 1)
    sieve[0] = sieve[1] = False
    p = 2
    while p * p <= m:
        if sieve[p]:
            for j in range(p * p, m + 1, p):
                sieve[j] = False
        p += 1
    total = 0
    for i, n in enumerate(nums):
        if 0 <= n <= m and sieve[n]:
            total += n ** i
    return total",0.0005568,27.17851563,"['c', 'a', 'b']"
184,"
def sum_prime_index_powers(nums: list[int]) -> int:
""""""
Calculates the sum of elements that are prime numbers, where each prime
is raised to the power of its 0-based index in the original list.

A prime number is a natural number greater than 1 that has no positive
divisors other than 1 and itself.

Examples:
sum_prime_index_powers([2, 3, 4]) == 4
# 2 is prime (idx 0) -> 2^0 = 1
# 3 is prime (idx 1) -> 3^1 = 3
# 4 is not prime
# Result: 1 + 3 = 4

sum_prime_index_powers([10, 11, 5]) == 36
# 10 is not prime
# 11 is prime (idx 1) -> 11^1 = 11
# 5 is prime (idx 2) -> 5^2 = 25
# Result: 11 + 25 = 36
""""""
","def filter_weighted_products(nums):
    if not nums:
        return []
    products = [val * idx for idx, val in enumerate(nums)]
    avg = sum(products) / len(products)
    result = sorted([p for p in products if p > avg])
    return result",0.000487,26.46191406,"def filter_weighted_products(nums):
    if not nums:
        return []
    
    n = len(nums)
    weighted_vals = []
    total_sum = 0
    
    for i in range(n):
        prod = nums[i] * i
        weighted_vals.append(prod)
        total_sum += prod
        
    average = total_sum / n
    result = []
    for value in weighted_vals:
        if value > average:
            result.append(value)
            
    result.sort()
    return result",0.0004744,26.46191406,"def filter_weighted_products(nums):
    """"""
    Given a list of non-negative integers nums, compute a new list where each element
    is the product of the original number and its index (i.e., val * index).
    Return a list of these products that are strictly greater than the average of
    all such products, sorted in ascending order.

    If the list is empty, return an empty list.
    """"""
    if not nums:
        return []
    total = 0
    for i, v in enumerate(nums):
        total += i * v
    avg = total / len(nums)
    result = []
    for i, v in enumerate(nums):
        prod = i * v
        if prod > avg:
            result.append(prod)
    return sorted(result)",0.0004656,26.46191406,"['c', 'b', 'a']"
185,"
def filter_weighted_products(nums):
""""""
Given a list of non-negative integers `nums`, compute a new list where each element
is the product of the original number and its index (i.e., val * index).
Return a list of these products that are strictly greater than the average of
all such products, sorted in ascending order.

If the list is empty, return an empty list.

>>> filter_weighted_products([1, 2, 3])
[6]
>>> filter_weighted_products([10, 5])
[5]
>>> filter_weighted_products([4, 0, 2, 1])
[4]
""""""
if not nums:
return []

products = [val * idx for idx, val in enumerate(nums)]
avg = sum(products) / len(products)

result = sorted([p for p in products if p > avg])
return result
","def manipulate_triplets(numbers: list) -> list:
    result = []
    for i in range(0, len(numbers), 3):
        chunk = numbers[i:i+3]
        if sum(chunk) % 2 == 0:
            result.extend(sorted(chunk))
        else:
            result.extend(chunk[::-1])
    return result",0.0005494,26.42773438,"def manipulate_triplets(numbers: list) -> list:
    res = []
    batch = []
    for i, x in enumerate(numbers):
        batch.append(x)
        if len(batch) == 3 or i == len(numbers) - 1:
            if sum(batch) % 2 == 0:
                batch.sort()
            else:
                batch.reverse()
            res.extend(batch)
            batch = []
    return res",0.000473,26.42773438,"def manipulate_triplets(numbers: list) -> list:
    if not numbers:
        return []
    chunk = numbers[:3]
    rest = numbers[3:]
    if sum(chunk) % 2 == 0:
        transformed = sorted(chunk)
    else:
        transformed = list(reversed(chunk))
    return transformed + manipulate_triplets(rest)
",0.0009129,26.42773438,"['b', 'a', 'c']"
186,"
def manipulate_triplets(numbers: list) -> list:
""""""
Given a list of integers, process the list in contiguous chunks of 3 elements.
For each chunk (including the last one, which may have fewer than 3 elements):
- If the sum of the elements in the chunk is even, sort the chunk in ascending order.
- If the sum of the elements in the chunk is odd, reverse the order of the chunk.
Return the modified list.

>>> manipulate_triplets([3, 1, 2, 5, 2])
[1, 2, 3, 2, 5]
>>> manipulate_triplets([1, 1, 1, 10])
[1, 1, 1, 10]
>>> manipulate_triplets([4, 2, 6, 1, 2])
[2, 4, 6, 2, 1]
""""""
pass
","def selective_word_reverse(sentence: str, limit: int) -> str:
    words = sentence.split(' ')
    result = []
    for word in words:
        if len(word) > limit:
            result.append(word[::-1])
        else:
            result.append(word)
    return ' '.join(result)",0.0008238,26.66875,"def selective_word_reverse(sentence: str, limit: int) -> str:
    res = """"
    while "" "" in sentence:
        word, space, sentence = sentence.partition("" "")
        res += (word[::-1] if len(word) > limit else word) + space
    return res + (sentence[::-1] if len(sentence) > limit else sentence)",0.0008211,26.66875,"def selective_word_reverse(sentence: str, limit: int) -> str:
    import re
    return re.sub(r'\S+', lambda m: m.group(0)[::-1] if len(m.group(0)) > limit else m.group(0), sentence)
",0.0004995,26.66875,"['c', 'b', 'a']"
187,"
def selective_word_reverse(sentence: str, limit: int) -> str:
""""""
Given a sentence where words are separated by spaces, return a new sentence where
every word with a length strictly greater than 'limit' is reversed. Words with a
length less than or equal to 'limit' should remain unchanged.

The order of the words in the sentence must be preserved.

Examples:
selective_word_reverse(""Hello World"", 4) -> ""olleH dlroW""
selective_word_reverse("" is cool"", 2) -> ""nohtyP is looc""
selective_word_reverse(""Keep it simple"", 5) -> ""Keep it elpmis""
selective_word_reverse(""a b c"", 1) -> ""a b c""
""""""
pass
","def least_frequent_smallest(numbers: list) -> int:
    if not numbers:
        return None
    from collections import Counter
    counts = Counter(numbers)
    min_freq = min(counts.values())
    candidates = [n for n in counts if counts[n] == min_freq]
    return min(candidates)",0,0,"def least_frequent_smallest(numbers: list) -> int:
    if not numbers:
        return None
    counts = {}
    for x in numbers:
        counts[x] = counts.get(x, 0) + 1
    return min(counts, key=lambda x: (counts[x], x))",0,0,"def least_frequent_smallest(numbers: list) -> int:
    if not numbers:
        return None
    unique_vals = set(numbers)
    min_freq = None
    min_val = None
    for v in unique_vals:
        freq = numbers.count(v)
        if min_freq is None or freq < min_freq or (freq == min_freq and v < min_val):
            min_freq = freq
            min_val = v
    return min_val
",0,0,"['a', 'b', 'c']"
188,"
def least_frequent_smallest(numbers: list) -> int:
""""""
Given a list of integers, identify the elements that appear the fewest number of times.
Return the smallest integer among those with the minimum frequency.
If the list is empty, return None.

Examples:
least_frequent_smallest([1, 1, 2, 3, 3]) == 2
least_frequent_smallest([5, 5, 4, 4, 3, 3]) == 3
least_frequent_smallest([10, 20, 10, 30, 20]) == 30
least_frequent_smallest([]) == None
""""""
","def split_on_descent(numbers: list[int]) -> list[list[int]]:
    if not numbers:
        return []
    result = []
    current = [numbers[0]]
    for i in range(1, len(numbers)):
        if numbers[i] > numbers[i-1]:
            current.append(numbers[i])
        else:
            result.append(current)
            current = [numbers[i]]
    result.append(current)
    return result",0.0005467,26.76640625,"def split_on_descent(numbers: list[int]) -> list[list[int]]:
    parts = []
    i = 0
    while i < len(numbers):
        j = i + 1
        while j < len(numbers) and numbers[j] > numbers[j - 1]:
            j += 1
        parts.append(numbers[i:j])
        i = j
    return parts",0.0005025,26.76640625,"def split_on_descent(numbers: list[int]) -> list[list[int]]:
    if not numbers:
        return []
    starts = [0]
    for i in range(1, len(numbers)):
        if numbers[i] <= numbers[i-1]:
            starts.append(i)
    result = []
    for idx, start in enumerate(starts):
        end = starts[idx+1] if idx+1 < len(starts) else len(numbers)
        result.append(numbers[start:end])
    return result",0.0004612,26.76640625,"['c', 'b', 'a']"
189,"
def split_on_descent(numbers: list[int]) -> list[list[int]]:
""""""
Partition the input list of integers into sub-lists where each sub-list is strictly increasing.
A new sub-list is started whenever the current element is less than or equal to the previous element.
Return the list of these sub-lists in their original order.

>>> split_on_descent([1, 2, 3, 2, 4, 5, 1])
[[1, 2, 3], [2, 4, 5], [1]]
>>> split_on_descent([10, 20, 30])
[[10, 20, 30]]
>>> split_on_descent([5, 4, 3, 2, 1])
[[5], [4], [3], [2], [1]]
>>> split_on_descent([])
[]
""""""
pass
","from typing import List

def balanced_split_swap(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    total = sum(numbers)
    half = total / 2
    best_idx = 0
    best_diff = float('inf')
    prefix_sum = 0
    for i in range(len(numbers)):
        prefix_sum += numbers[i]
        diff = abs(prefix_sum - half)
        if diff < best_diff:
            best_diff = diff
            best_idx = i
    return numbers[best_idx+1:] + numbers[:best_idx+1]",0.0004751,26.67695313,"from typing import List
from itertools import accumulate

def balanced_split_swap(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    total_half = sum(numbers) / 2.0
    prefix_sums = list(accumulate(numbers))
    best_idx = min(range(len(prefix_sums)), key=lambda i: abs(prefix_sums[i] - total_half))
    return numbers[best_idx + 1:] + numbers[:best_idx + 1]",0.0004619,26.67695313,"def balanced_split_swap(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    total = sum(numbers)
    pref = []
    s = 0
    for x in numbers:
        s += x
        pref.append(s)
    lo, hi = 0, len(pref) - 1
    pos = len(pref) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if 2 * pref[mid] >= total:
            pos = mid
            hi = mid - 1
        else:
            lo = mid + 1
    best_i = pos
    best_diff = abs(2 * pref[pos] - total)
    if pos > 0:
        diff_prev = abs(2 * pref[pos - 1] - total)
        if diff_prev <= best_diff:
            best_i = pos - 1
    return numbers[best_i + 1:] + numbers[:best_i + 1]",0.000482,26.67695313,"['b', 'a', 'c']"
190,"
from typing import List

def balanced_split_swap(numbers: List[int]) -> List[int]:
""""""
Find the index `i` in the list such that the sum of the prefix `numbers[:i+1]` is
closest to exactly half of the total sum of the list. Split the list after this index
and return a new list consisting of the right part followed by the left part.

In case of a tie (two prefixes are equally close to half the sum), choose the one
resulting from the smaller index (earlier split).

Examples:
balanced_split_swap([1, 2, 3, 4]) == [4, 1, 2, 3] # Half is 5. Prefix sum 6 (index 2) is closest.
balanced_split_swap([1, 10, 1]) == [10, 1, 1] # Half is 6. Prefix sums 1 (dist 5) and 11 (dist 5). Choose index 0.
balanced_split_swap([5, 5]) == [5, 5] # Half is 5. Prefix sum 5 (index 0) is exact match.
balanced_split_swap([2, 4, 10]) == [10, 2, 4] # Half is 8. Prefix sum 6 (index 1) is closest.
""""""
","def flip_and_reverse(sentence: str) -> str:
    words = sentence.split(' ')
    result = []
    for word in reversed(words):
        if len(word) % 2 == 1:
            result.append(word.swapcase())
        else:
            result.append(word)
    return ' '.join(result)",0.0004779,26.56152344,"def flip_and_reverse(sentence: str) -> str:
    words = sentence.split(' ')
    res = []
    while words:
        word = words.pop()
        if len(word) % 2 != 0:
            word = word.swapcase()
        res.append(word)
    return ' '.join(res)",0.0005323,26.56152344,"def flip_and_reverse(sentence: str) -> str:
    if not sentence:
        return """"
    res = []
    i = len(sentence)
    while i > 0:
        j = i - 1
        while j >= 0 and sentence[j] != ' ':
            j -= 1
        word = sentence[j+1:i]
        if len(word) % 2 == 1:
            word = word.swapcase()
        res.append(word)
        i = j
    return ' '.join(res)
",0,0,"['a', 'b', 'c']"
191,"
def flip_and_reverse(sentence: str) -> str:
""""""
Reverse the order of words in the given string. Additionally, if a word
has an odd length, swap the case of all its characters (uppercase becomes
lowercase and vice versa). Words are separated by a single space.

>>> flip_and_reverse(""Hello World"")
'wORLD hELLO'

>>> flip_and_reverse(""Code is fun"")
'FUN is Code'

>>> flip_and_reverse(""Keep it simple"")
'simple it Keep'
""""""
pass
","def circular_digit_sum(nums: list) -> list:
    def digit_sum(n):
        return sum(int(d) for d in str(n))
    n = len(nums)
    result = []
    for i in range(n):
        if nums[i] % 2 == 0:
            prev_idx = (i - 1) % n
            result.append(digit_sum(nums[prev_idx]))
        else:
            next_idx = (i + 1) % n
            result.append(digit_sum(nums[next_idx]))
    return result",0.0009098,26.01015625,"def circular_digit_sum(nums: list) -> list:
    totals = [sum(map(int, str(n))) for n in nums]
    n = len(nums)
    res = []
    for i, val in enumerate(nums):
        target_idx = i - 1 if val % 2 == 0 else (i + 1) % n
        res.append(totals[target_idx])
    return res",0.0007075,26.01015625,"def circular_digit_sum(nums: list) -> list:
    def digit_sum(n):
        s = 0
        while n:
            s += n % 10
            n //= 10
        return s
    n = len(nums)
    res = []
    for i in range(n):
        if nums[i] % 2 == 0:
            prev_idx = n - 1 if i == 0 else i - 1
            res.append(digit_sum(nums[prev_idx]))
        else:
            next_idx = 0 if i == n - 1 else i + 1
            res.append(digit_sum(nums[next_idx]))
    return res",0.0012644,26.01015625,"['b', 'a', 'c']"
192,"
def circular_digit_sum(nums: list) -> list:
""""""
Given a list of positive integers, create and return a new list where each element is
transformed based on its parity (even or odd) using the values from the original list:

- If an element is even, replace it with the sum of the digits of the element at the previous index (circularly).
- If an element is odd, replace it with the sum of the digits of the element at the next index (circularly).

Constraints:
- The input list 'nums' will contain at least one positive integer.
- Treat the list as circular (the element before index 0 is the last element; the element after the last is index 0).

>>> circular_digit_sum([10, 21, 4])
[4, 4, 3]

>>> circular_digit_sum([11, 22])
[4, 2]

>>> circular_digit_sum([5])
[5]
""""""
","from typing import List

def sum_increasing_sequences(numbers: List[int]) -> List[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    for i in range(1, len(numbers)):
        if numbers[i] > numbers[i-1]:
            current_sum += numbers[i]
        else:
            result.append(current_sum)
            current_sum = numbers[i]
    result.append(current_sum)
    return result",0.0005644,26.515625,"from typing import List

def sum_increasing_sequences(numbers: List[int]) -> List[int]:
    res = []
    i = 0
    while i < len(numbers):
        j = i + 1
        while j < len(numbers) and numbers[j] > numbers[j-1]:
            j += 1
        res.append(sum(numbers[i:j]))
        i = j
    return res",0.0005683,26.515625,"def sum_increasing_sequences(numbers: List[int]) -> List[int]:
    n = len(numbers)
    if n == 0:
        return []
    def sum_run(i: int) -> tuple:
        if i + 1 < n and numbers[i+1] > numbers[i]:
            s, end = sum_run(i + 1)
            return numbers[i] + s, end
        else:
            return numbers[i], i
    def build(i: int, acc: List[int]):
        if i >= n:
            return acc
        s, end = sum_run(i)
        acc.append(s)
        return build(end + 1, acc)
    return build(0, [])",0.0007936,26.515625,"['a', 'b', 'c']"
193,"
from typing import List

def sum_increasing_sequences(numbers: List[int]) -> List[int]:
""""""
Partition the input list into contiguous strictly increasing sequences
and return a new list containing the sum of each sequence.

A sequence continues as long as the next element is strictly greater
than the current element.

sum_increasing_sequences([1, 2, 3, 2, 4, 1]) == [6, 6, 1]
sum_increasing_sequences([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1]
sum_increasing_sequences([10, 20, 30]) == [60]
sum_increasing_sequences([]) == []
""""""
pass
","def filter_by_digit_sum(numbers):
    result = []
    for n in numbers:
        digit_sum = sum(int(d) for d in str(n))
        if digit_sum > 0 and n % digit_sum == 0:
            result.append(n)
    return result",0.0011669,26.66914063,"def filter_by_digit_sum(numbers):
    output = []
    for n in numbers:
        s = 0
        t = n
        while t:
            s += t % 10
            t //= 10
        if n % s == 0:
            output.append(n)
    return output",0.0010283,26.66914063,"def filter_by_digit_sum(numbers):
        if n == 0:
            return 0
        return n % 10 + digit_sum(n // 10)
    result = []
    for n in numbers:
        s = digit_sum(n)
        if s != 0 and n % s == 0:
            result.append(n)
    return result
",0,0,"['b', 'a', 'c']"
194,"
def filter_by_digit_sum(numbers):
""""""
Given a list of positive integers, return a new list containing only the integers
that are evenly divisible by the sum of their own digits.
The result should preserve the original order of the elements.

args:
numbers: A list of positive integers.

Examples:
>>> filter_by_digit_sum([10, 11, 12, 13])
[10, 12]
>>> filter_by_digit_sum([20, 21, 22, 24])
[20, 24]
>>> filter_by_digit_sum([105, 125])
[]
""""""
pass
","def encrypt_index_shift(s: str) -> str:
    result = []
    for i, c in enumerate(s):
        if c.isalpha():
            base = ord('A') if c.isupper() else ord('a')
            shifted = chr((ord(c) - base + i) % 26 + base)
            result.append(shifted)
        else:
            result.append(c)
    return ''.join(result)",0.0011539,26.50722656,"def encrypt_index_shift(s: str) -> str:
    abc = ""abcdefghijklmnopqrstuvwxyz""
    ABC = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    res = """"
    for i in range(len(s)):
        c = s[i]
        if c in abc:
            res += abc[(abc.find(c) + i) % 26]
        elif c in ABC:
            res += ABC[(ABC.find(c) + i) % 26]
        else:
            res += c
    return res",0.0009295,26.50722656,"def encrypt_index_shift(s: str) -> str:
    import re
    pattern = re.compile(r'[A-Za-z]')
    def repl(m):
        c = m.group(0)
        i = m.start()
        shift = i % 26
        if c.isupper():
            base = ord('A')
        else:
            base = ord('a')
        return chr((ord(c) - base + shift) % 26 + base)
    return pattern.sub(repl, s)",0,0,"['b', 'a', 'c']"
195,"
def encrypt_index_shift(s: str) -> str:
""""""
Return a string where every alphabet character is shifted forward in the alphabet
by an amount equal to its index in the string.

- Non-alphabet characters remain unchanged.
- The shift is circular (e.g., 'z' shifted by 1 becomes 'a').
- Case is preserved (uppercase stays uppercase, lowercase stays lowercase).

Examples:
encrypt_index_shift(""abc"") == ""ace""
encrypt_index_shift(""Hi!"") == ""Hj!""
encrypt_index_shift(""xyz"") == ""xzb""
""""""
","def clipped_differences(numbers: list[int]) -> list[int]:
    if len(numbers) < 2:
        return []
    return [max(0, numbers[i+1] - numbers[i]) for i in range(len(numbers) - 1)]",0.0005428,25.99433594,"def clipped_differences(numbers: list[int]) -> list[int]:
    diffs = []
    for i in range(1, len(numbers)):
        change = numbers[i] - numbers[i-1]
        if change > 0:
            diffs.append(change)
        else:
            diffs.append(0)
    return diffs",0.000644,25.99433594,"def clipped_differences(numbers: list[int]) -> list[int]:
    if len(numbers) < 2:
        return []
    import itertools
    a, b = itertools.tee(numbers)
    next(b, None)
    return [max(0, y - x) for x, y in zip(a, b)]",0.0011529,25.99433594,"['a', 'b', 'c']"
196,"
def clipped_differences(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, generate a new list where each element is the difference
between the adjacent elements (next_element - current_element).
However, if the calculated difference is negative, store 0 instead.

The resulting list will always have a length equal to len(numbers) - 1.
If the input list has fewer than 2 elements, return an empty list.

Examples:
clipped_differences([1, 5, 2, 9]) == [4, 0, 7]
clipped_differences([10, 5, 2]) == [0, 0]
clipped_differences([3, 3, 3]) == [0, 0]
clipped_differences([100]) == []
""""""
pass
","def xor_affix(strings: list[str], prefix: str, suffix: str) -> list[str]:
    result = []
    for s in strings:
        starts = s.startswith(prefix)
        ends = s.endswith(suffix)
        if starts != ends:
            result.append(s)
    return result",0.0004833,26.47617188,"def xor_affix(strings: list[str], prefix: str, suffix: str) -> list[str]:
    result = []
    for s in strings:
        if (s.startswith(prefix), s.endswith(suffix)) in {(True, False), (False, True)}:
            result.append(s)
    return result",0.0004517,26.47617188,"def xor_affix(strings: list[str], prefix: str, suffix: str) -> list[str]:
    starts = {s for s in strings if s.startswith(prefix)}
    ends = {s for s in strings if s.endswith(suffix)}
    return [s for s in strings if (s in starts) ^ (s in ends)]",0.0004601,26.47617188,"['b', 'c', 'a']"
197,"
def xor_affix(strings: list[str], prefix: str, suffix: str) -> list[str]:
""""""
Given a list of strings, return a new list containing only the strings that start with
the given prefix or end with the given suffix, but not both (exclusive or).

>>> xor_affix([""apple"", ""apply"", ""ample"", ""apricot""], ""ap"", ""le"")
['apply', 'ample', 'apricot']
>>> xor_affix([""test"", ""toast"", ""best""], ""te"", ""st"")
['toast', 'best']
>>> xor_affix([""tree"", ""treat"", ""free""], ""tr"", ""ee"")
['treat', 'free']
""""""
","from typing import List

def count_increasing_subarrays(lst: List[int], k: int) -> int:
    if k <= 0 or k > len(lst):
        return 0
    count = 0
    for i in range(len(lst) - k + 1):
        is_increasing = True
        for j in range(i, i + k - 1):
            if lst[j] >= lst[j+1]:
                is_increasing = False
                break
        if is_increasing:
            count += 1
    return count",0.0005204,27.06777344,"from typing import List

def count_increasing_subarrays(lst: List[int], k: int) -> int:
    n = len(lst)
    if k <= 0 or k > n:
        return 0
    
    violations = [i for i in range(n - 1) if lst[i] >= lst[i+1]]
    stops = [-1] + violations + [n - 1]
    
    total = 0
    for i in range(len(stops) - 1):
        length = stops[i+1] - stops[i]
        if length >= k:
            total += (length - k + 1)
            
    return total",0.000505,27.06777344,"def count_increasing_subarrays(lst, k):
    n = len(lst)
    if k <= 0 or k > n:
        return 0
    total = 0
    run = 1
    for i in range(1, n):
        if lst[i] > lst[i-1]:
            run += 1
        else:
            if run >= k:
                total += run - k + 1
            run = 1
    if run >= k:
        total += run - k + 1
    return total
",0.0005194,27.06777344,"['b', 'c', 'a']"
198,"
from typing import List

def count_increasing_subarrays(lst: List[int], k: int) -> int:
""""""
Return the number of contiguous subarrays of length k from the list lst that are strictly increasing.
If k is greater than the length of lst or k <= 0, return 0.
A subarray is strictly increasing if each element is strictly larger than the previous element.

>>> count_increasing_subarrays([1, 2, 3, 4, 5], 3)
3
>>> count_increasing_subarrays([1, 3, 2, 4], 3)
0
>>> count_increasing_subarrays([10, 20, 30, 25, 40], 2)
3
>>> count_increasing_subarrays([5, 4, 3, 2, 1], 2)
0
""""""
","def count_even_sum_slices(nums: list[int], k: int) -> int:
    if k < 1 or k > len(nums):
        return 0
    count = 0
    for i in range(len(nums) - k + 1):
        if sum(nums[i:i+k]) % 2 == 0:
            count += 1
    return count",0.0005217,26.78808594,"def count_even_sum_slices(nums: list[int], k: int) -> int:
    n = len(nums)
    if k < 1 or k > n:
        return 0
    
    prefix_parity = [0] * (n + 1)
    for i in range(n):
        prefix_parity[i + 1] = (prefix_parity[i] + nums[i]) % 2
    
    count = 0
    for i in range(n - k + 1):
        if prefix_parity[i] == prefix_parity[i + k]:
            count += 1
    return count",0.0006416,26.78808594,"def count_even_sum_slices(nums: list[int], k: int) -> int:
    if k < 1 or k > len(nums):
        return 0
    p = 0
    for j in range(k):
        p ^= nums[j] & 1
    count = 0
    if p == 0:
        count += 1
    n = len(nums)
    for i in range(k, n):
        p ^= nums[i - k] & 1
        p ^= nums[i] & 1
        if p == 0:
            count += 1
    return count",0.0005509,26.78808594,"['a', 'c', 'b']"
199,"
def count_even_sum_slices(nums: list[int], k: int) -> int:
""""""
Return the number of contiguous sub-slices of the list `nums` of length `k`
such that the sum of the elements in the slice is an even number.

If `k` is greater than the length of `nums` or less than 1, return 0.

>>> count_even_sum_slices([1, 1, 2, 2], 2)
2
>>> count_even_sum_slices([1, 2, 3, 4], 2)
0
>>> count_even_sum_slices([10, 20, 30], 1)
3
>>> count_even_sum_slices([], 5)
0
""""""
","def consecutive_parity_sums(numbers: list[int]) -> list[int]:
    if not numbers:
        return []
    result = []
    current_sum = numbers[0]
    current_parity = numbers[0] % 2
    for n in numbers[1:]:
        if n % 2 == current_parity:
            current_sum += n
        else:
            result.append(current_sum)
            current_sum = n
            current_parity = n % 2
    result.append(current_sum)
    return result",0.0005602,26.7890625,"def consecutive_parity_sums(numbers: list[int]) -> list[int]:
    res = []
    i = 0
    while i < len(numbers):
        start = i
        while i < len(numbers) and numbers[i] % 2 == numbers[start] % 2:
            i += 1
        res.append(sum(numbers[start:i]))
    return res",0.0006332,26.7890625,"def consecutive_parity_sums(numbers: list[int]) -> list[int]:
    from itertools import groupby
    return [sum(group) for _, group in groupby(numbers, key=lambda x: x % 2)]",0.0005163,26.7890625,"['c', 'a', 'b']"
200,"
def consecutive_parity_sums(numbers: list[int]) -> list[int]:
""""""
Given a list of integers, identify runs of consecutive numbers that share the
same parity (all even or all odd). Calculate the sum of elements for each
identified run and return these sums in a new list.

If the input list is empty, return an empty list.

>>> consecutive_parity_sums([1, 5, 2, 4, 3])
[6, 6, 3]
>>> consecutive_parity_sums([10, 20, 30, 40])
[100]
>>> consecutive_parity_sums([1, 2, 3, 4])
[1, 2, 3, 4]
""""""
pass
","def shift_k_blocks(lst: list, k: int) -> list:
    result = []
    for i in range(0, len(lst), k):
        block = lst[i:i+k]
        if len(block) == k:
            result.append(block[-1])
            result.extend(block[:-1])
        else:
            result.extend(block)
    return result",0.0005147,27.09101563,"def shift_k_blocks(lst: list, k: int) -> list:
    n = len(lst)
    res = []
    limit = (n // k) * k
    for i in range(n):
        if i < limit:
            base = (i // k) * k
            res.append(lst[base + (i - 1) % k])
        else:
            res.append(lst[i])
    return res",0.000765,27.09101563,"def shift_k_blocks(lst: list, k: int) -> list:
    n = len(lst)
    res = [None] * n
    full = n // k
    for b in range(full):
        base = b * k
        res[base] = lst[base + k - 1]
        for j in range(1, k):
            res[base + j] = lst[base + j - 1]
    rem_pos = full * k
    if rem_pos < n:
        res[rem_pos:] = lst[rem_pos:]
    return res",0.0007243,27.09101563,"['a', 'c', 'b']"
201,"
def shift_k_blocks(lst: list, k: int) -> list:
""""""
Given a list of integers `lst` and a positive integer `k`, return a new list where
every consecutive block of `k` elements is rotated to the right by 1 position.

If the number of elements in `lst` is not divisible by `k`, the remaining elements
at the end that do not form a full block of size `k` should remain unchanged.

Examples:
shift_k_blocks([1, 2, 3, 4, 5], 2) == [2, 1, 4, 3, 5]
shift_k_blocks([1, 2, 3, 4, 5], 3) == [3, 1, 2, 4, 5]
shift_k_blocks([10, 20, 30], 5) == [10, 20, 30]
""""""
pass
","def special_shuffle(nums: list[int]) -> list[int]:
    evens = [n for n in nums if n % 2 == 0]
    odds = [n for n in nums if n % 2 == 1]
    if len(odds) > len(evens):
        first, second = odds, evens
    else:
        first, second = evens, odds
    result = []
    for i in range(max(len(first), len(second))):
        if i < len(first):
            result.append(first[i])
        if i < len(second):
            result.append(second[i])
    return result",0.0006458,26.91835938,"def special_shuffle(nums: list[int]) -> list[int]:
    evens = [x for x in nums if x % 2 == 0]
    odds = [x for x in nums if x % 2 != 0]
    if len(odds) > len(evens):
        first, second = odds, evens
    else:
        first, second = evens, odds
    it = iter(second)
    res = []
    for x in first:
        res.append(x)
        val = next(it, None)
        if val is not None:
            res.append(val)
    return res",0.0004801,26.91835938,"def special_shuffle(nums: list[int]) -> list[int]:
    ev = [n for n in nums if n % 2 == 0]
    od = [n for n in nums if n % 2 != 0]
    from itertools import zip_longest
    if len(ev) >= len(od):
        zipped = zip_longest(ev, od, fillvalue=None)
        res = []
        for a, b in zipped:
            if a is not None:
                res.append(a)
            if b is not None:
                res.append(b)
        return res
    else:
        zipped = zip_longest(od, ev, fillvalue=None)
        res = []
        for a, b in zipped:
            if a is not None:
                res.append(a)
            if b is not None:
                res.append(b)
        return res",0.000569,26.91835938,"['b', 'c', 'a']"
202,"
def special_shuffle(nums: list[int]) -> list[int]:
""""""
Separate the input list of integers into two groups: even numbers and odd numbers.
Return a new list that interleaves these two groups, starting with the group
that has more elements. The internal order of elements within each group must be preserved.

If both groups have the same number of elements, start the interleaving with the even group.
Any remaining elements from the larger group should be appended to the end.

Examples:
special_shuffle([1, 2, 3, 4]) == [2, 1, 4, 3]
special_shuffle([10, 20, 5]) == [10, 5, 20]
special_shuffle([7, 9, 13]) == [7, 9, 13]
special_shuffle([8, 2, 5, 7, 9]) == [5, 8, 7, 2, 9]
""""""
","def special_shuffle(nums: list[int]) -> list[int]:
    evens = [x for x in nums if x % 2 == 0]
    odds = [x for x in nums if x % 2 != 0]
    f, s = (evens, odds) if len(evens) >= len(odds) else (odds, evens)
    res = []
    for i in range(min(len(f), len(s))):
        res.extend([f[i], s[i]])
    return res + f[len(s):] + s[len(f):]",0.0004695,26.64804688,"def special_shuffle(nums: list[int]) -> list[int]:
    evens = []
    odds = []
    for x in nums:
        if x % 2 == 0:
            evens.append(x)
        else:
            odds.append(x)
    res = []
    if len(evens) >= len(odds):
        first, second = evens, odds
    else:
        first, second = odds, evens
    for i in range(max(len(first), len(second))):
        if i < len(first):
            res.append(first[i])
        if i < len(second):
            res.append(second[i])
    return res",0.0004641,26.64804688,"def special_shuffle(nums: list[int]) -> list[int]:
    evens = [n for n in nums if n % 2 == 0]
    odds = [n for n in nums if n % 2 == 1]
    if len(odds) > len(evens):
        first, second = odds, evens
    else:
        first, second = evens, odds
    result = []
    for i in range(max(len(first), len(second))):
        if i < len(first):
            result.append(first[i])
        if i < len(second):
            result.append(second[i])
    return result",0.000474,26.64804688,"['b', 'a', 'c']"
